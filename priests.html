<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catholic Resistance Globe</title>
  <link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three-globe@2.24.4/dist/three-globe.min.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>
  <style>
    :root {
      --background-color: #f5f5f5;
      --text-color: #333;
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-text: #333;
      --atmospheric-color: #ccc;
      --search-bg: white;
      --search-text: #333;
      --search-placeholder: #999;
      --search-results-bg: white;
      --search-results-hover: #f0f0f0;
      --link-color: #8b0000;
      --focus-col: rgb(61, 99, 170);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #121212;
        --text-color: #f5f5f5;
        --panel-bg: rgba(33, 33, 33, 0.95);
        --panel-text: #f5f5f5;
        --atmospheric-color: #3a228a;
        --search-bg: #333;
        --search-text: #f5f5f5;
        --search-placeholder: #777;
        --search-results-bg: #333;
        --search-results-hover: #444;
        --link-color: #ff6b6b;
      }
    }
    
    * {
        margin: 0px;
        padding: 0px;
    }

    html {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background-color);
      font-family: Arial, sans-serif;
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      height: 100%;
    }
    
    #globeContainer {
        position: absolute;
        height: 100%;
        width: 100%;
    }
    
    .title {
        mix-blend-mode: difference;
        width: 100%;
        text-align: center;
        font-family: 'UnifrakturMaguntia', serif;
        font-size: 5rem;
        color: #ffffff;
        z-index: 10;
        margin: 2rem 0px;
    }
    
    .search-container {
        display: flex;
        justify-content: space-between;
        flex-direction: column;
        pointer-events: none;
        z-index: 10;
        flex-grow: 1;
        max-width: 500px;
        width: 100%;
    }

    #priestInfo {
        display: flex;
        flex-direction: column;
    }

    .search-input {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        padding: 10px;
        font-style: italic;
        border: none;
        background: var(--search-bg);
        color: var(--search-text);
        font-size: 1.5rem;
        outline: none;
        border: 3px solid var(--search-bg);
        pointer-events: all;
        margin-left: 10px;
        margin-right: 10px;
    }
    
    .search-input:focus {
        border: 3px solid var(--focus-col);
    }

    .search-input::placeholder {
      color: var(--search-placeholder);
    }
    
    .search-results {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        font-style: italic;
        overflow-y: scroll;
        background: var(--search-results-bg);
        border-radius: 0 0 5px 5px;
        z-index: 11;
        display: none;
        pointer-events: all;
        margin-left: 10px;
        margin-right: 10px;
        max-height: 200px;
        overflow-y: scroll;
    }
    
    .search-result-item {
      padding: 10px;
      cursor: pointer;
      transition: background-color 0.2s;
      border: 3px solid transparent;
      font-size: 1.5rem;
    }
    
    .search-result-item:focus {
        border: 3px solid var(--focus-col);
        background-color: var(--search-results-hover);
    }

    .info-panel {
        margin-left: 10px;
        margin-right: 10px;
        margin-bottom: 10px;
        box-shadow: 2.5px 2.5px 5px black;
        pointer-events: all;
        position: relative;
        background: white;
        padding: 20px;
        max-height: 70vh;
        overflow-y: auto;
        z-index: 10;
        display: none;
        background: var(--panel-bg);
        color: var(--panel-text);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        font-family: 'Times';
        font-style: italic;
    }
    
    .info-panel h2 {
        margin-top: 0;
        margin-bottom: 21px;
        font-size: 2rem;
        text-transform: uppercase;
        font-weight: bold;
    }
    
    .info-row {
        margin-bottom: 4px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
    }
    
    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        background: #cc0000;
        font-size: 2rem;
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    .info-link {
      background: #004970;
      color: white;
      font-weight: bold;
      text-decoration: underline;
    }
    .info-link.maps {
        background: #700000;
        color: white;
        padding: 10px;
        font-weight: bold;
        font-style: normal;
        font-family: sans-serif;
        margin-top: 1rem;
        text-decoration: none;
    }
    
    .info-link.maps:hover {
      text-decoration: underline;
    }
    
    @media (max-width: 600px) {
      .title {
        display: none;
      }
      
      .search-container {
        margin-top: 20px;
      }

      .info-panel {
        max-height: 60vh;
      }
    }
  </style>
</head>
<body>

  <h1 class="title">Catholic Resistance</h1>

  <div class="search-container">
    <div style="display: flex; flex-direction: column;">
        <input autofocus="true" type="text" class="search-input" placeholder="Search Resistance priests..." id="searchInput">
        <div class="search-results" id="searchResults"></div>
    </div>

    <div class="info-panel" id="infoPanel">
        <button class="close-btn" id="closeBtn">Ã—</button>
        <h2 id="priestName"></h2>
        <div id="priestInfo"></div>
      </div>
  </div>
  
  <div id="globeContainer"></div>

  <script>
    // Configuration - Change these values to configure the application
    const CONFIG = {
      currentZoomLevel: isMobile() ? 400.0 : 300.0,
      dataUrl: null, // Set to CSV URL or null to use the default data
      fieldOrder: [
        'Type', 'Born Year', 'Associates With', 'Beliefs', 'Location/Area',
        'Contact/Website', 'Ordained in Rite', 'Ordained By', 'Consecrated in Rite',
        'Consecrated By', 'Bishop Line', 'Notes'
      ],
      markerColor: '#ff0000',
      markerPulseColor: '#ff0000',
      markerSize: 0.4,
      markerRingSize: 1.5,
      labelAltitude: 0.05, // Adjusted to work better with large Earth radius
      autoRotate: false,
      autoRotateSpeed: 0.1,
      theme: null, // 'light', 'dark', or null for system preference
      focusAnimationDuration: 1000, // ms to animate to a point
      focusDistanceFactor: 0.8, // distance factor when focusing on a point (lower = closer)
      cloudOpacity: 0.8, // Add this line for cloud opacity
      cloudBrightness: 1.2 // Add this line for cloud brightness
    };

    // Global variables
    let renderer, scene, camera, controls, globe;
    let priests = [];
    let selectedPoint = null;
    let isGlobeReady = false;
    let raycaster, mouse;
    let dayNightMaterial;
    let currentTheme = getTheme();
    let pulseMeshes = [];
    let searchResults = [];
    let selectedSearchIndex = -1;
    let enhancedEarth = null;
    
    function isMobile() {
      // Check for touch capability
      if ('ontouchstart' in window || navigator.maxTouchPoints > 0)
        return true;
      
      // Check screen width
      if (window.innerWidth <= 768)
        return true;
      
      // Check user agent as fallback
      const ua = navigator.userAgent.toLowerCase();
      return /android|webos|iphone|ipad|ipod|blackberry|windows phone/i.test(ua);
    };

    // Language mapping and geography functions
    const languageLatitudeMap = {
      // Top languages by number of speakers + European languages + CJK + Filipino
      "zh": 35.0, // Chinese (Mandarin)
      "es": 40.0, // Spanish - Spain (will adjust based on longitude)
      "en": 51.0, // English - UK (will adjust based on longitude)
      "hi": 20.0, // Hindi - Northern India
      "ar": 25.0, // Arabic - Arabian Peninsula
      "pt": -10.0, // Portuguese - Brazil (will adjust based on longitude)
      "bn": 23.0, // Bengali - Bangladesh/East India
      "ru": 55.0, // Russian
      "ja": 36.0, // Japanese
      "pa": 30.0, // Punjabi
      "de": 51.0, // German
      "jv": -7.5, // Javanese
      "ko": 37.5, // Korean
      "fr": 46.0, // French (will adjust based on longitude)
      "te": 16.0, // Telugu
      "mr": 18.0, // Marathi
      "tr": 39.0, // Turkish
      "ta": 11.0, // Tamil
      "vi": 16.0, // Vietnamese
      "ur": 30.0, // Urdu
      "it": 42.0, // Italian
      "th": 15.0, // Thai
      "gu": 22.0, // Gujarati
      "pl": 52.0, // Polish
      "uk": 49.0, // Ukrainian
      "fa": 32.0, // Persian
      "ro": 46.0, // Romanian
      "nl": 52.0, // Dutch
      "fil": 14.0, // Filipino
      "sv": 60.0, // Swedish
      "cs": 50.0, // Czech
      "hu": 47.0, // Hungarian
      "el": 38.0, // Greek
      "da": 56.0, // Danish
      "fi": 62.0, // Finnish
      "no": 60.0, // Norwegian
      "bg": 42.0, // Bulgarian
      "hr": 45.0, // Croatian
      "sk": 48.0, // Slovak
      "sr": 44.0, // Serbian
      "lt": 55.0, // Lithuanian
      "lv": 57.0, // Latvian
      "et": 59.0, // Estonian
      "sl": 46.0, // Slovenian
      "is": 65.0, // Icelandic
      "ca": 41.0, // Catalan
      "eu": 43.0, // Basque
      "ga": 53.0, // Irish
      "gl": 42.0, // Galician
      "cy": 52.0, // Welsh
      "gd": 57.0, // Scottish Gaelic
      "be": 53.0, // Belarusian
      "mk": 41.5, // Macedonian
      "sq": 41.0, // Albanian
      "mt": 35.9, // Maltese
      "id": -0.8, // Indonesian
      "ms": 2.5,  // Malay
      "sw": -6.0, // Swahili
      "am": 9.0,  // Amharic
      "yo": 7.5,  // Yoruba
      "zu": -29.0, // Zulu
      "xh": -33.0, // Xhosa
      "he": 31.0, // Hebrew
      "tl": 14.6  // Tagalog
    };

    function languageLongitudeRanges() {
  return {
    "en": [
      { min: -170, max: -30, lat: 40.0 },    // North America
      { min: -10, max: 2, lat: 51.0 },       // UK (narrower range)
      { min: 65, max: 90, lat: 20.0 },       // South Asia (India)
      { min: 110, max: 155, lat: -25.0 }     // Australia/NZ
    ],
    "de": [
      { min: 5, max: 15, lat: 51.0 }         // Germany
    ],
    "ru": [
      { min: 20, max: 180, lat: 55.0 }       // Russia
    ],
    "es": [
      { min: -120, max: -30, lat: 15.0 },    // Latin America
      { min: -10, max: 5, lat: 40.0 }        // Spain
    ],
    "pt": [
      { min: -70, max: -35, lat: -10.0 },    // Brazil
      { min: -10, max: 0, lat: 39.0 }        // Portugal
    ],
    "fr": [
      { min: -80, max: -60, lat: 45.0 },     // Quebec/Canada
      { min: -5, max: 8, lat: 46.0 },        // France
      { min: 0, max: 20, lat: 14.0 }         // Francophone Africa
    ],
    "ar": [
      { min: -10, max: 0, lat: 30.0 },       // North Africa
      { min: 25, max: 60, lat: 25.0 }        // Middle East
    ],
    "zh": [
      { min: 70, max: 135, lat: 35.0 }       // China
    ],
    "hi": [
      { min: 70, max: 90, lat: 20.0 }        // India
    ],
    "ja": [
      { min: 125, max: 150, lat: 36.0 }      // Japan
    ],
    "ko": [
      { min: 125, max: 130, lat: 37.5 }      // Korea
    ],
    "it": [
      { min: 7, max: 18, lat: 42.0 }         // Italy
    ],
    "pl": [
      { min: 14, max: 24, lat: 52.0 }        // Poland
    ]
  };
}

    // Language-based latitude estimation with geographical consistency check
    function estimateLatitude(longitude) {
  const languages = getBrowserLanguages();
  const llr = languageLongitudeRanges();
  
  // 1. First try non-English languages for geographical consistency
  const nonEnglishLangs = languages.filter(lang => !getLanguageCode(lang).startsWith('en'));
  
  // Try non-English languages first
  for (const language of nonEnglishLangs) {
    const langCode = getLanguageCode(language);
    
    // Check if this language has specific longitude ranges defined
    if (llr[langCode]) {
      for (const range of llr[langCode]) {
        // Check if the detected longitude falls within this language's expected range
        if (longitude >= range.min && longitude <= range.max) {
          console.log(`Found matching non-English language ${langCode} for longitude ${longitude}, using latitude ${range.lat}`);
          return range.lat;
        }
      }
    }
  }
  
  // 2. If no non-English match, try all languages
  for (const language of languages) {
    const langCode = getLanguageCode(language);
    
    if (llr[langCode]) {
      for (const range of llr[langCode]) {
        if (longitude >= range.min && longitude <= range.max) {
          console.log(`Found matching language ${langCode} for longitude ${longitude}, using latitude ${range.lat}`);
          return range.lat;
        }
      }
    }
  }
  
  // 3. If no geographically consistent language found, try the general language map
  // Prioritize non-English languages first
  for (const language of nonEnglishLangs) {
    const langCode = getLanguageCode(language);
    if (languageLatitudeMap[langCode]) {
      return languageLatitudeMap[langCode];
    }
  }
  
  // Then try any language
  for (const language of languages) {
    const langCode = getLanguageCode(language);
    if (languageLatitudeMap[langCode]) {
      return languageLatitudeMap[langCode];
    }
  }
  
  // 4. Regional longitude-based fallback
  if (longitude > 10 && longitude < 40) {
    // Eastern Europe
    return 50.0;
  } else if (longitude >= 40 && longitude < 60) {
    // Western Russia
    return 55.0;
  } else if (longitude >= 60 && longitude < 90) {
    // Central Asia
    return 45.0;
  } else if (longitude >= 90 && longitude < 120) {
    // East Asia
    return 35.0;
  } else if (longitude >= 120 && longitude < 150) {
    // Far East Asia
    return 35.0;
  } else if (longitude > -10 && longitude <= 10) {
    // Western Europe
    return 48.0;
  } else if (longitude > -30 && longitude <= -10) {
    // Atlantic/Western Europe
    return 45.0;
  } else if (longitude > -60 && longitude <= -30) {
    // Eastern Americas
    return 40.0;
  } else if (longitude > -120 && longitude <= -60) {
    // Americas
    return 35.0;
  } else if (longitude > -180 && longitude <= -120) {
    // Western Americas/Pacific
    return 45.0;
  } else if (longitude > 150 || longitude <= -150) {
    // Pacific region
    return 0.0;
  }
  
  // Final fallback - estimate hemisphere based on longitude
  return (longitude > -120 && longitude < -30) || (longitude > 100 && longitude < 180) ? -20.0 : 20.0;
}

    // Get all browser languages
    function getBrowserLanguages() {
      if (navigator.languages && navigator.languages.length) {
        return Array.from(navigator.languages);
      }
      return [navigator.language || navigator.userLanguage || 'en'];
    }

    // Extract language code from full locale string
    function getLanguageCode(locale) { 
      return locale.split('-')[0].toLowerCase(); 
    }

    // 7. Improved click detection to prevent clicking through the globe
    function isPointOnFrontSide(hitPoint, camera) {
      // Vector from camera to hit point
      const cameraToHit = new THREE.Vector3().subVectors(hitPoint, camera.position);
      
      // Vector from camera to globe center
      const cameraToCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), camera.position);
      
      // If dot product is positive, the hit is on back side
      return cameraToHit.dot(cameraToCenter) <= 0;
    }

    // Calculate solar position with accurate Earth tilt
    function calculateSolarPosition(dt) {
      // Day of year (0-365)
      const start = new Date(dt.getUTCFullYear(), 0, 0);
      const diff = dt - start;
      const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));
      
      // Convert to radians for the calculations
      const dayAngle = 2 * Math.PI * dayOfYear / 365.25;
      
      // Axial tilt calculation (more accurate declination angle)
      // Uses astronomical formula with the obliquity of the ecliptic
      const declination = 0.4093 * Math.sin(dayAngle - 1.405);
      
      // Equation of time (difference between solar time and mean time)
      const eqTime = 229.18 * (0.000075 + 0.001868 * Math.cos(dayAngle) 
                - 0.032077 * Math.sin(dayAngle) 
                - 0.014615 * Math.cos(2 * dayAngle) 
                - 0.040849 * Math.sin(2 * dayAngle));
      
      // Calculate solar hour angle
      const hour = dt.getUTCHours();
      const minutes = dt.getUTCMinutes();
      const seconds = dt.getUTCSeconds();
      const totalSeconds = hour * 3600 + minutes * 60 + seconds;
      
      // Convert to longitude (-180 to 180)
      const longitude = (totalSeconds / 86400) * 360 - 180;
      
      // Adjust for equation of time
      const adjustedLongitude = longitude + eqTime / 60 * 15;
      
      // Convert declination from radians to degrees
      const declinationDegrees = declination * (180 / Math.PI);
      
      return [adjustedLongitude, declinationDegrees];
    }

    // Add a blue marker for user location
    function addUserLocationMarker(lat, lng) {
      // Remove any existing user location marker
      const existingMarker = scene.getObjectByName('user-location');
      if (existingMarker) {
        scene.remove(existingMarker);
      }
      
      // Create blue marker geometry
      const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({ color: '#0066ff' });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      
      // Set marker position
      const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
      marker.position.set(position.x, position.y, position.z);
      marker.name = 'user-location';
      
      // Add to scene
      scene.add(marker);
    }

    function centerOnTimezone() {
  try {
    // Get the IANA timezone identifier
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    console.log(`Detected timezone: ${timezone}`);
    
    // Get coordinates from timezone
    const coords = getTimezoneCoordinates(timezone);
    
    if (coords) {
      console.log(`Using timezone coordinates: ${coords.lat}, ${coords.lng} (${timezone})`);
      // Center globe on these coordinates
      focusOnPoint(coords.lat, coords.lng);
      
      // Add a blue marker for user's timezone location
      addUserLocationMarker(coords.lat, coords.lng);
      return;
    }
  } catch (err) {
    console.warn("Error detecting timezone:", err);
  }
  
  // Fallback to original method if timezone detection fails
  fallbackTimezoneDetection();
}

function getTimezoneCoordinates(timezone) {
  const timezoneMap = {
    // Europe
    "Europe/Berlin": { lat: 52.5200, lng: 13.4050 },
    "Europe/London": { lat: 51.5074, lng: -0.1278 },
    "Europe/Paris": { lat: 48.8566, lng: 2.3522 },
    "Europe/Rome": { lat: 41.9028, lng: 12.4964 },
    "Europe/Madrid": { lat: 40.4168, lng: -3.7038 },
    "Europe/Moscow": { lat: 55.7558, lng: 37.6173 },
    "Europe/Kiev": { lat: 50.4501, lng: 30.5234 },
    "Europe/Warsaw": { lat: 52.2297, lng: 21.0122 },
    "Europe/Vienna": { lat: 48.2082, lng: 16.3738 },
    "Europe/Stockholm": { lat: 59.3293, lng: 18.0686 },
    "Europe/Athens": { lat: 37.9838, lng: 23.7275 },
    "Europe/Istanbul": { lat: 41.0082, lng: 28.9784 },
    "Europe/Amsterdam": { lat: 52.3676, lng: 4.9041 },
    "Europe/Brussels": { lat: 50.8503, lng: 4.3517 },
    "Europe/Prague": { lat: 50.0755, lng: 14.4378 },
    "Europe/Lisbon": { lat: 38.7223, lng: -9.1393 },
    "Europe/Dublin": { lat: 53.3498, lng: -6.2603 },
    "Europe/Budapest": { lat: 47.4979, lng: 19.0402 },
    "Europe/Copenhagen": { lat: 55.6761, lng: 12.5683 },
    "Europe/Oslo": { lat: 59.9139, lng: 10.7522 },
    "Europe/Helsinki": { lat: 60.1699, lng: 24.9384 },
    "Europe/Zurich": { lat: 47.3769, lng: 8.5417 },
    
    // North America
    "America/New_York": { lat: 40.7128, lng: -74.0060 },
    "America/Chicago": { lat: 41.8781, lng: -87.6298 },
    "America/Denver": { lat: 39.7392, lng: -104.9903 },
    "America/Los_Angeles": { lat: 34.0522, lng: -118.2437 },
    "America/Toronto": { lat: 43.6532, lng: -79.3832 },
    "America/Vancouver": { lat: 49.2827, lng: -123.1207 },
    "America/Mexico_City": { lat: 19.4326, lng: -99.1332 },
    
    // Asia
    "Asia/Tokyo": { lat: 35.6762, lng: 139.6503 },
    "Asia/Shanghai": { lat: 31.2304, lng: 121.4737 },
    "Asia/Hong_Kong": { lat: 22.3193, lng: 114.1694 },
    "Asia/Singapore": { lat: 1.3521, lng: 103.8198 },
    "Asia/Seoul": { lat: 37.5665, lng: 126.9780 },
    "Asia/Dubai": { lat: 25.2048, lng: 55.2708 },
    "Asia/Kolkata": { lat: 28.6139, lng: 77.2090 },
    "Asia/Bangkok": { lat: 13.7563, lng: 100.5018 },
    "Asia/Jakarta": { lat: -6.2088, lng: 106.8456 },
    "Asia/Manila": { lat: 14.5995, lng: 120.9842 },
    "Asia/Taipei": { lat: 25.0330, lng: 121.5654 },
    "Asia/Jerusalem": { lat: 31.7683, lng: 35.2137 },
    
    // Australia and Oceania
    "Australia/Sydney": { lat: -33.8688, lng: 151.2093 },
    "Australia/Melbourne": { lat: -37.8136, lng: 144.9631 },
    "Australia/Brisbane": { lat: -27.4698, lng: 153.0251 },
    "Australia/Perth": { lat: -31.9505, lng: 115.8605 },
    "Pacific/Auckland": { lat: -36.8485, lng: 174.7633 },
    
    // South America
    "America/Sao_Paulo": { lat: -23.5505, lng: -46.6333 },
    "America/Buenos_Aires": { lat: -34.6037, lng: -58.3816 },
    "America/Santiago": { lat: -33.4489, lng: -70.6693 },
    "America/Lima": { lat: -12.0464, lng: -77.0428 },
    "America/Bogota": { lat: 4.7110, lng: -74.0721 },
    
    // Africa
    "Africa/Cairo": { lat: 30.0444, lng: 31.2357 },
    "Africa/Johannesburg": { lat: -26.2041, lng: 28.0473 },
    "Africa/Lagos": { lat: 6.5244, lng: 3.3792 },
    "Africa/Nairobi": { lat: -1.2921, lng: 36.8219 },
    "Africa/Casablanca": { lat: 33.5731, lng: -7.5898 }
  };
  
  // Try exact match
  if (timezoneMap[timezone]) {
    return timezoneMap[timezone];
  }
  
  // If exact match not found, try to find a city in the same region
  // Extract the region part (e.g., "Europe" from "Europe/Berlin")
  const region = timezone.split('/')[0];
  
  // Find any timezone in the same region
  for (const [tz, coords] of Object.entries(timezoneMap)) {
    if (tz.startsWith(region + '/')) {
      console.log(`No exact match for ${timezone}, using ${tz} as approximate match`);
      return coords;
    }
  }
  
  // No match found
  return null;
}

    function fallbackTimezoneDetection() {
      // Get local timezone offset in minutes
      const timezoneOffsetMinutes = new Date().getTimezoneOffset();
      
      console.log("timezoneOffsetMinutes " + timezoneOffsetMinutes);

      // Convert to hours (negative because getTimezoneOffset returns difference from UTC)
      const timezoneOffsetHours = -timezoneOffsetMinutes / 60;
      
      // Calculate approximate longitude (15 degrees per hour)
      const approximateLongitude = timezoneOffsetHours * 15;
      
      // Get browser languages and estimate latitude based on geographical consistency
      const estimatedLatitude = estimateLatitude(approximateLongitude);
      
      console.log(`Browser languages: ${getBrowserLanguages().join(', ')}, approximate longitude: ${approximateLongitude}, estimated latitude: ${estimatedLatitude}`);
      
      // Center globe on this position
      focusOnPoint(estimatedLatitude, approximateLongitude);
    }

    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          // Success callback
          (position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;
            
            // Add a blue marker for user location
            addUserLocationMarker(userLat, userLng);
            
            // Center globe on user location
            focusOnPoint(userLat, userLng);
          },
          // Error callback
          (error) => {
            console.log('Geolocation error:', error);
            // Center on timezone if location isn't available
            centerOnTimezone();
          }
        );
      } else {
        // Geolocation not supported
        console.log('Geolocation not supported by this browser');
        centerOnTimezone();
      }
    }

    // Adjust rotation speed based on zoom level - slower when zoomed in
    function adjustRotationSpeed() {
      const distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
      const zoomRange = controls.maxDistance - controls.minDistance;
      const zoomFactor = (distance - controls.minDistance) / zoomRange;
      
      const minSpeed = 0.2; // Min rotation speed when fully zoomed in
      const maxSpeed = 1.0; // Max rotation speed when zoomed out
      
      controls.rotateSpeed = minSpeed + zoomFactor * (maxSpeed - minSpeed);
    }

    async function initEnhancedGlobe() {
      // Create new Earth object
      enhancedEarth = new EnhancedEarth(scene, camera);
      
      // Set cloud options from CONFIG
      enhancedEarth.options.cloudOpacity = CONFIG.cloudOpacity;
      enhancedEarth.options.cloudBrightness = CONFIG.cloudBrightness;
      
      await enhancedEarth.init();
      
      // Set the globe reference to the earth mesh for compatibility
      globe = enhancedEarth.getEarthMesh();
      isGlobeReady = true;
      
      // Load priests data
      loadPriestsData();
      
      // Initial solar position
      const dt = new Date();
      const [longitude, declination] = calculateSolarPosition(dt);
      enhancedEarth.updateSunDirection(longitude, declination);
      
      // Center globe based on user location/timezone
      centerOnTimezone();
      
      // Remove this line - no UI control for cloud opacity
      // addCloudOpacityControl();
      
      // Update solar position periodically
      setInterval(() => {
        const dt = new Date();
        const [longitude, declination] = calculateSolarPosition(dt);
        enhancedEarth.updateSunDirection(longitude, declination);
      }, 60000); // Update every minute
    }

    // Main initialization function
    function init() {
      // Initialize Three.js scene
      initScene();
      
      // Initialize raycaster for interactions
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // Initialize enhanced globe
      initEnhancedGlobe();
      
      // Set up event listeners
      setupEventListeners();
      
      // Request user location
      getUserLocation();
      
      // Start animation loop
      enhancedAnimate();
    }
    
    // Get current theme (light/dark)
    function getTheme() {
      if (CONFIG.theme) {
        return CONFIG.theme;
      }
      
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark';
      }
      
      return 'light';
    }
    
    // Initialize Three.js scene
    function initScene() {
      // Initialize renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('globeContainer').appendChild(renderer.domElement);

      // Initialize scene
      scene = new THREE.Scene();
      
      // Set background color based on theme
      const backgroundColor = currentTheme === 'dark' ? 0x121212 : 0xf5f5f5;
      scene.background = new THREE.Color(backgroundColor);
      
      scene.add(new THREE.AmbientLight(0xeeeeee, 0.3));
      
      // Initialize camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      
      const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dLight.position.set(-800, 2000, 400);
      camera.add(dLight);
      
      const dLight1 = new THREE.DirectionalLight(0x7982f6, 1);
      dLight1.position.set(-200, 500, 200);
      camera.add(dLight1);
      
      const dLight2 = new THREE.PointLight(0x8566cc, 0.5);
      dLight2.position.set(-200, 500, 200);
      camera.add(dLight2);
      
      camera.position.z = CONFIG.currentZoomLevel;
      camera.position.x = 0;
      camera.position.y = 0;
      
      scene.add(camera);
      
      // Add fog for atmospheric effect
      const fogColor = currentTheme === 'dark' ? 0x333333 : 0xcccccc;
      scene.fog = new THREE.Fog(fogColor, 400, 2000);
      
      // Initialize orbit controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dynamicDampingFactor = 0.01;
      controls.enablePan = false;
      controls.minDistance = 150;
      controls.maxDistance = 400;
      controls.rotateSpeed = 0.8;
      controls.zoomSpeed = 1;
      controls.autoRotate = CONFIG.autoRotate;
      controls.autoRotateSpeed = CONFIG.autoRotateSpeed;
         
      controls.minPolarAngle = 5 * (Math.PI / 180);  // 5 degrees from north pole
      controls.maxPolarAngle = 175 * (Math.PI / 180); // 5 degrees from south pole
    }
    
    // Texture cache using IndexedDB
    const TextureCache = {
      dbName: 'earth-texture-cache',
      dbVersion: 1,
      db: null,

      init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('textures')) {
              db.createObjectStore('textures', { keyPath: 'url' });
            }
          };
          
          request.onsuccess = (event) => {
            this.db = event.target.result;
            resolve();
          };
          
          request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
          };
        });
      },

      storeTexture(url, blob) {
        return new Promise((resolve, reject) => {
          if (!this.db) return reject(new Error('Database not initialized'));
          
          const transaction = this.db.transaction(['textures'], 'readwrite');
          const store = transaction.objectStore('textures');
          
          const item = { url, blob, timestamp: Date.now() };
          const request = store.put(item);
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      },

      getTexture(url) {
        return new Promise((resolve, reject) => {
          if (!this.db) return reject(new Error('Database not initialized'));
          
          const transaction = this.db.transaction(['textures'], 'readonly');
          const store = transaction.objectStore('textures');
          
          const request = store.get(url);
          
          request.onsuccess = (event) => {
            resolve(event.target.result ? event.target.result.blob : null);
          };
          
          request.onerror = (event) => reject(event.target.error);
        });
      },
    
      async hasTexture(url) {
        if (!this.db) return false;
        
        return new Promise((resolve) => {
          try {
            const transaction = this.db.transaction(['textures'], 'readonly');
            const store = transaction.objectStore('textures');
            
            // Use the faster .count() method instead of .get() to just check existence
            const request = store.count(url);
            
            request.onsuccess = (event) => {
              resolve(event.target.result > 0);
            };
            
            request.onerror = () => {
              resolve(false);
            };
            
            // Safety in case transaction takes too long
            transaction.oncomplete = () => {
              // This might never be reached if the request completes first
            };
            
            transaction.onerror = () => {
              resolve(false);
            };
            
            transaction.onabort = () => {
              resolve(false);
            };
          } catch (err) {
            console.warn('Error checking texture cache:', err);
            resolve(false);
          }
        });
      }
    };

    // Progressive texture loader
    const TextureManager = {
      baseUrl: 'https://dubia.cc/',
      resolutions: {
        low: '2k_',
        high: '8k_'
      },
      textureTypes: [
        'earth_daymap',
        'earth_nightmap',
        'earth_normal_map',
        'earth_specular_map',
        'earth_clouds'
      ],
      loadedTextures: {
        low: {},
        high: {}
      },
      
      async init() {
        await TextureCache.init();
        return this;
      },
      
      getTextureUrl(type, resolution) {
        const prefix = this.resolutions[resolution];
        return `${this.baseUrl}${prefix}${type}.avif`;
      },
      
      async loadTexture(type, resolution, retryCount = 0, maxRetries = 3) {
  
        const url = this.getTextureUrl(type, resolution);
  
        // Return cached texture if already loaded
        if (this.loadedTextures[resolution][type]) {
          return this.loadedTextures[resolution][type];
        }
        
        // Try to get from cache
        try {
          const cachedBlob = await TextureCache.getTexture(url);
          if (cachedBlob) {
            console.log(`Using cached texture: ${type} (${resolution})`);
            const texture = await this._createTextureFromBlob(cachedBlob);
            this.loadedTextures[resolution][type] = texture;
            return texture;
          }
        } catch (err) {
          console.warn('Error loading texture from cache:', err);
        }
        
        // Fetch from network with retry logic
        try {
          console.log(`Fetching texture: ${type} (${resolution})`);
          const response = await fetch(url, {
            // Add cache control headers
            headers: {
              'Cache-Control': 'max-age=86400', // Cache for 24 hours
            },
            // Use cache-first strategy
            cache: 'force-cache'
          });
          
          if (!response.ok) throw new Error(`Failed to load texture: ${url} (${response.status})`);
          
          const blob = await response.blob();
          
          // Store in cache
          try {
            await TextureCache.storeTexture(url, blob);
            console.log(`Texture cached: ${type} (${resolution})`);
          } catch (err) {
            console.warn('Error storing texture in cache:', err);
          }
          
          // Create texture
          const texture = await this._createTextureFromBlob(blob);
          this.loadedTextures[resolution][type] = texture;
          return texture;
        } catch (err) {
          // Retry logic
          if (retryCount < maxRetries) {
            console.warn(`Retry ${retryCount + 1}/${maxRetries} for texture: ${url}`);
            // Exponential backoff - wait longer between each retry
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retryCount)));
            return this.loadTexture(type, resolution, retryCount + 1, maxRetries);
          }
          
          console.error('Error loading texture after retries:', err);
          // Return a default fallback texture
          return this._createFallbackTexture(type);
        }
      },

      // 2. Add a new method to TextureManager to create fallback textures
      _createFallbackTexture(type) {
        console.log(`Creating fallback texture for: ${type}`);
        
        // Create a canvas with a solid color
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Different colors for different texture types
        let color;
        switch (type) {
          case 'earth_daymap':
            color = '#1a4d7e'; // Dark blue for day
            break;
          case 'earth_nightmap':
            color = '#000020'; // Near black for night
            break;
          case 'earth_normal_map':
            color = '#8080ff'; // Normal map blue
            break;
          case 'earth_specular_map':
            color = '#000000'; // Black for no specular
            break;
          case 'earth_clouds':
            color = '#ffffff'; // White with transparancy
            ctx.globalAlpha = 0.2;
            break;
          default:
            color = '#000000'; // Default black
        }
        
        // Fill with base color
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Create texture from canvas
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      },

      _createTextureFromBlob(blob) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(blob);
          const loader = new THREE.TextureLoader();
          
          loader.load(
            url,
            (texture) => {
              URL.revokeObjectURL(url);
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.encoding = THREE.sRGBEncoding;
              resolve(texture);
            },
            undefined,
            (err) => {
              URL.revokeObjectURL(url);
              reject(err);
            }
          );
        });
      },
      
      async loadAllTextures(resolution) {
        const promises = this.textureTypes.map(type => 
          this.loadTexture(type, resolution)
        );
        
        try {
          const textures = await Promise.all(promises);
          const result = {};
          
          this.textureTypes.forEach((type, index) => {
            result[type] = textures[index];
          });
          
          return result;
        } catch (err) {
          console.error('Error loading all textures:', err);
          throw err;
        }
      }
    };

    // Earth PBR shader
    const EarthPBRShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        
        void main() {
          vUv = uv;
          
          // Properly compute and output the normal
          vNormal = normalize(normalMatrix * normal);
          
          // Calculate world position
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          vec4 mvPosition = viewMatrix * worldPosition;
          vViewPosition = -mvPosition.xyz;
          
          // Output position
          gl_Position = projectionMatrix * mvPosition;
          
          // Calculate tangent space for normal mapping
          // This improves normal calculations for smooth shading
          vec3 objectTangent = vec3(1.0, 0.0, 0.0);
          vec3 objectBitangent = vec3(0.0, 1.0, 0.0);
          
          // Ensure tangent is perpendicular to normal
          objectTangent = normalize(objectTangent - normal * dot(objectTangent, normal));
          objectBitangent = normalize(cross(normal, objectTangent));
          
          // Transform to view space
          vTangent = normalize(normalMatrix * objectTangent);
          vBitangent = normalize(normalMatrix * objectBitangent);
        }
      `,
      
      fragmentShader: `
        uniform sampler2D dayMap;
        uniform sampler2D nightMap;
        uniform sampler2D normalMap;
        uniform sampler2D specularMap;
        uniform vec3 sunDirection;
        
        // Earth properties
        uniform float normalScale;
        uniform float specularIntensity;
        uniform float roughness;
        uniform float fresnelPower;
        uniform float atmosphereIntensity;
        
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        
        // Improved normal mapping function for smooth shading
        vec3 perturbNormal() {
          // Ensure normalized vectors for smooth shading
          vec3 normal = normalize(vNormal);
          vec3 tangent = normalize(vTangent);
          vec3 bitangent = normalize(vBitangent);
          
          // Get normal map value and convert to world space
          vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;
          mapN.xy *= normalScale;
          
          // Create TBN matrix for normal map transformation
          mat3 tbn = mat3(tangent, bitangent, normal);
          
          // Return perturbed normal in view space, correctly normalized
          return normalize(tbn * mapN);
        }
        
        // Improved Fresnel function
        float fresnel(float cosTheta, float F0, float power) {
          return F0 + (1.0 - F0) * pow(max(0.0, 1.0 - cosTheta), power);
        }
        
        void main() {
          // Ensure normalized vectors for smooth shading
          vec3 viewDir = normalize(vViewPosition);
          vec3 normal = normalize(vNormal);
          
          // Apply normal mapping with reduced intensity for smoother look
          if (normalScale > 0.0) {
            normal = mix(normal, perturbNormal(), 0.7);
          }
          
          // Calculate day/night based on dot product of position and sun direction
          vec3 positionOnGlobe = normalize(vWorldPosition);
          float dayNightMix = dot(positionOnGlobe, sunDirection);
          
          // Smoother transition between day and night
          float lightIntensity = smoothstep(-0.15, 0.15, dayNightMix);
          
          // Sample the day and night textures
          vec3 dayColor = texture2D(dayMap, vUv).rgb;
          vec3 nightColor = texture2D(nightMap, vUv).rgb * 0.5;
          
          // Sample the specular map
          float specular = texture2D(specularMap, vUv).r;
          
          // Base color with day/night transition
          vec3 color = mix(nightColor, dayColor, lightIntensity);
          
          // Add specular highlights when lit by the sun
          if (dayNightMix > 0.0) {
            // Blinn-Phong specular with softer falloff for smoother look
            vec3 halfVector = normalize(sunDirection + viewDir);
            float NdotH = max(0.0, dot(normal, halfVector));
            float specularFactor = pow(NdotH, (1.0 - roughness) * 80.0) * specular * specularIntensity;
            
            color += specularFactor * vec3(1.0);
          }
          
          // Calculate fresnel effect (rim lighting)
          float NdotV = max(0.001, dot(normal, viewDir));
          float fresnelFactor = fresnel(NdotV, 0.0, fresnelPower);
          
          // Add atmosphere rim without darkening center
          vec3 atmosphereColor = vec3(0.3, 0.6, 1.0) * atmosphereIntensity;
          color = mix(color, atmosphereColor, fresnelFactor * 0.3);
          
          // Brighten the overall result
          color *= 1.3;
          
          // Output final color
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      
      uniforms: {
        dayMap: { value: null },
        nightMap: { value: null },
        normalMap: { value: null },
        specularMap: { value: null },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
        normalScale: { value: 1.0 },
        specularIntensity: { value: 0.2 },
        roughness: { value: 1.2 },
        fresnelPower: { value: 1.0 },
        atmosphereIntensity: { value: 1.0 }
      }
    };
  
    // Cloud shader
    const CloudShader = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      
      fragmentShader: `
        uniform sampler2D cloudMap;
        uniform vec3 sunDirection;
        uniform float cloudOpacity;
        uniform float cloudBrightness;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
    
        void main() {
          // Get the cloud texture
          vec4 cloudTexel = texture2D(cloudMap, vUv);
          
          // Calculate day/night based on dot product of position and sun direction
          vec3 positionOnGlobe = normalize(vWorldPosition);
          float dayNightMix = dot(positionOnGlobe, sunDirection);
          
          // Smoother transition for cloud lighting
          float lightIntensity = smoothstep(-0.2, 0.3, dayNightMix);
          
          // Cloud brightness based on sunlight (brighter in day, darker at night)
          // But never completely black - minimum 0.3 intensity
          float adjustedBrightness = mix(0.3, 1.0, lightIntensity) * cloudBrightness;
          
          // Cloud color - pure white but affected by light intensity
          vec3 cloudColor = vec3(1.0) * adjustedBrightness;
          
          // Extract alpha from the luminance/brightness of the cloud texture
          // This properly makes dark areas transparent and white areas visible
          float alpha = (cloudTexel.r + cloudTexel.g + cloudTexel.b) / 3.0;
          
          // Apply overall cloud opacity
          alpha *= cloudOpacity;
          
          // Output with correct transparency
          gl_FragColor = vec4(cloudColor, alpha);
        }
      `,
      
      uniforms: {
        cloudMap: { value: null },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
        cloudOpacity: { value: 0.9 },  // Increased from 0.8
        cloudBrightness: { value: 1.2 }
      }
    };

    // Atmospheric glow shader
    const AtmosphereShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float power;
        uniform float atmosphereIntensity;
        uniform vec3 sunDirection;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
    
        void main() {
          // Fresnel-like glow effect based on viewing angle
          float intensity = pow(0.75 - dot(vNormal, vec3(0, 0, 1.0)), power);
          
          // Calculate day/night based on dot product of position and sun direction
          vec3 positionOnGlobe = normalize(vWorldPosition);
          float dayNightMix = dot(positionOnGlobe, sunDirection);
          
          // Adjust glow based on day/night (stronger on day side)
          // Check if this point on the atmosphere is in day or night
          float sunEffect = smoothstep(-0.2, 0.3, dayNightMix);
          
          // Blend atmosphere colors - bluer in day, more purple at night
          vec3 dayGlow = glowColor;
          vec3 nightGlow = vec3(0.2, 0.1, 0.4); // More purple for night
          vec3 finalGlowColor = mix(nightGlow, dayGlow, sunEffect);
          
          // Apply atmosphere intensity
          vec3 glow = finalGlowColor * intensity * atmosphereIntensity;
          
          // Output with proper transparency
          gl_FragColor = vec4(glow, intensity * 0.8);
        }
      `,
      
      uniforms: {
        glowColor: { value: new THREE.Color(0x3a88ff) },
        power: { value: 2.0 },
        atmosphereIntensity: { value: 1.0 },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) }
      }
    };

    // Earth object with PBR rendering
    class EnhancedEarth {
      constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.textureManager = null;
        this.earthMesh = null;
        this.cloudMesh = null;
        this.atmosphereMesh = null;
        this.currentResolution = 'low';
        this.earthRadius = 100.0;      // Changed from 1.0
        this.cloudRadius = 100.1;      // Changed from 1.02
        this.atmosphereRadius = 102.0; // Changed from 1.1
        this.zoomThreshold = 250;
        
        // Shader materials
        this.earthMaterial = null;
        this.cloudMaterial = null;
        this.atmosphereMaterial = null;
        
        // Options
        this.options = {
          normalScale: 1.0,
          specularIntensity: 0.5,
          roughness: 0.7,
          fresnelPower: 1.0,
          atmosphereIntensity: 0.6,
          cloudOpacity: 0.5,
          cloudBrightness: 2.0,
          cloudRotationSpeed: 0.0,
        };
      }
      
      async init() {
        
        // Initialize texture manager
        this.textureManager = await TextureManager.init();
        
        // Create geometries
        const earthGeometry = new THREE.SphereGeometry(this.earthRadius, 64, 64);
        const cloudGeometry = new THREE.SphereGeometry(this.cloudRadius, 64, 64);
        const atmosphereGeometry = new THREE.SphereGeometry(this.atmosphereRadius, 64, 64);
        
        // Create materials (shader creation is unchanged)
        this.earthMaterial = new THREE.ShaderMaterial({
          vertexShader: EarthPBRShader.vertexShader,
          fragmentShader: EarthPBRShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(EarthPBRShader.uniforms),
          flatShading: false,
          derivatives: true
        });
        
        this.cloudMaterial = new THREE.ShaderMaterial({
          vertexShader: CloudShader.vertexShader,
          fragmentShader: CloudShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(CloudShader.uniforms),
          transparent: true,
          flatShading: false,
          blending: THREE.CustomBlending,
          blendSrc: THREE.SrcAlphaFactor,
          blendDst: THREE.OneMinusSrcAlphaFactor
        });
        
        this.atmosphereMaterial = new THREE.ShaderMaterial({
          vertexShader: AtmosphereShader.vertexShader,
          fragmentShader: AtmosphereShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(AtmosphereShader.uniforms),
          transparent: true,
          flatShading: false,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide
        });
        
        // Create meshes
        this.earthMesh = new THREE.Mesh(earthGeometry, this.earthMaterial);
        this.earthMesh.name = 'earth-mesh';
        
        this.cloudMesh = new THREE.Mesh(cloudGeometry, this.cloudMaterial);
        this.cloudMesh.name = 'cloud-mesh';
        
        this.atmosphereMesh = new THREE.Mesh(atmosphereGeometry, this.atmosphereMaterial);
        this.atmosphereMesh.name = 'atmosphere-mesh';
        
        // Add to scene
        this.scene.add(this.earthMesh);
        this.scene.add(this.cloudMesh);
        this.scene.add(this.atmosphereMesh);
        
        // STEP 1: Start with empty textures for immediate rendering
        this.loadEmptyTextures();
        
        // Update shader properties with initial settings
        this.updateShaderProperties();
        
        // STEP 2-5: Begin progressive texture loading (non-blocking)
        this.progressivelyLoadTextures();
        
        // Set up solar position and other initializations
        const dt = new Date();
        const [longitude, declination] = calculateSolarPosition(dt);
        this.updateSunDirection(longitude, declination);
        
        // Update solar position every minute
        setInterval(() => {
          const dt = new Date();
          const [longitude, declination] = calculateSolarPosition(dt);
          this.updateSunDirection(longitude, declination);
        }, 60000);
        
        return this;
      }
      
      areLowResTexturesCached = async function() {
        try {
          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Cache check timeout')), 50)
          );
          
          for (const type of this.textureManager.textureTypes) {
            const url = this.textureManager.getTextureUrl(type, 'low');
            
            const isCached = await Promise.race([
              TextureCache.hasTexture(url),
              timeout
            ]);
            
            if (!isCached) {
              return false; // Early return if any texture isn't cached
            }
          }
          
          return true;
        } catch (err) {
          console.warn('Fast low-res cache check failed:', err);
          return false;
        }
      }

      loadEmptyTextures() {
        console.log('Using empty textures for initial rendering');
        
        // Create empty textures for each type
        const textures = {};
        this.textureManager.textureTypes.forEach(type => {
          textures[type] = this.textureManager._createFallbackTexture(type);
        });
        
        // Update material uniforms with empty textures
        this.earthMaterial.uniforms.dayMap.value = textures.earth_daymap;
        this.earthMaterial.uniforms.nightMap.value = textures.earth_nightmap;
        this.earthMaterial.uniforms.normalMap.value = textures.earth_normal_map;
        this.earthMaterial.uniforms.specularMap.value = textures.earth_specular_map;
        this.cloudMaterial.uniforms.cloudMap.value = textures.earth_clouds;
      }

      async progressivelyLoadTextures() {
        try {
          // STEP 2: Check if low-resolution textures are cached
          const lowResCached = await this.areLowResTexturesCached();
          
          if (lowResCached) {
            // If low-res textures are cached, load them immediately (still faster than high-res)
            console.log('Found cached low-resolution textures, loading them first');
            this.loadTextures('low').catch(err => console.warn('Error loading low-res textures:', err));
          } else {
            // If not cached, need to load from network after a short delay
            // to allow the empty textures to render first
            setTimeout(() => {
              console.log('Loading low-resolution textures from network');
              this.loadTextures('low').catch(err => console.warn('Error loading low-res textures:', err));
            }, 100);
          }
          
          // STEP 4: Check if high-resolution textures are cached
          setTimeout(async () => {
            const highResCached = await this.areHighResTexturesCached();
            
            if (highResCached) {
              // Load high-res textures from cache after low-res textures have loaded
              console.log('Found cached high-resolution textures, upgrading');
              this.loadTextures('high').catch(err => console.warn('Error loading high-res textures:', err));
            } else {
              // STEP 5: Load high-res from network with longer delay
              setTimeout(() => {
                console.log('Loading high-resolution textures from network');
                this.loadTextures('high').catch(err => console.warn('Error loading high-res textures:', err));
              }, 5000); // 5 second delay to ensure low-res textures are loaded and displayed first
            }
          }, 850); // Small delay to ensure we don't block loading low-res textures
          
        } catch (err) {
          console.error('Error in progressive texture loading:', err);
        }
      }

      async loadTextures(resolution) {
        try {
          // Start loading textures
          const startTime = performance.now();
          console.log(`Loading ${resolution} resolution textures...`);
          
          const textures = await this.textureManager.loadAllTextures(resolution);
          
          // Update the materials with new textures
          this.earthMaterial.uniforms.dayMap.value = textures.earth_daymap;
          this.earthMaterial.uniforms.nightMap.value = textures.earth_nightmap;
          this.earthMaterial.uniforms.normalMap.value = textures.earth_normal_map;
          this.earthMaterial.uniforms.specularMap.value = textures.earth_specular_map;
          this.cloudMaterial.uniforms.cloudMap.value = textures.earth_clouds;
          
          // Update current resolution
          this.currentResolution = resolution;
          
          // Log performance
          const loadTime = (performance.now() - startTime).toFixed(0);
          console.log(`âœ“ Completed loading ${resolution} textures in ${loadTime}ms`);
          
          return true;
        } catch (err) {
          console.error(`Error loading ${resolution} textures:`, err);
          
          // Only create fallback if we failed to load low-res textures
          // (we already have empty textures loaded)
          if (resolution === 'low' && !this.textureLoadingFailed) {
            this.createFallbackEarth();
          }
          
          return false;
        }
      }

      createFallbackEarth() {
        console.warn('Creating fallback Earth due to texture loading failures');
        
        // Create a simple material for Earth
        const fallbackEarthMaterial = new THREE.MeshPhongMaterial({
          color: 0x2233aa,  // Blue color
          emissive: 0x112244,
          emissiveIntensity: 0.5, // Add emissive to ensure earth is never too dark
          specular: 0x333333,
          shininess: 25
        });
        
        // Apply the fallback material
        this.earthMesh.material = fallbackEarthMaterial;
        
        // Create a simple material for clouds
        const fallbackCloudMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.1
        });
        
        // Apply the fallback cloud material
        this.cloudMesh.material = fallbackCloudMaterial;
        
        // Create a simple material for atmosphere
        const fallbackAtmosphereMaterial = new THREE.MeshBasicMaterial({
          color: 0x3366ff,
          transparent: true,
          opacity: 0.2,
          side: THREE.BackSide
        });
        
        // Apply the fallback atmosphere material
        this.atmosphereMesh.material = fallbackAtmosphereMaterial;
        
        // Set flag to prevent further texture loading attempts
        this.textureLoadingFailed = true;
      }

      updateShaderProperties() {
        // Update Earth material uniforms
        this.earthMaterial.uniforms.normalScale.value = this.options.normalScale;
        this.earthMaterial.uniforms.specularIntensity.value = this.options.specularIntensity;
        this.earthMaterial.uniforms.roughness.value = this.options.roughness;
        this.earthMaterial.uniforms.fresnelPower.value = this.options.fresnelPower;
        this.earthMaterial.uniforms.atmosphereIntensity.value = this.options.atmosphereIntensity;
        
        // Update Cloud material uniforms
        this.cloudMaterial.uniforms.cloudOpacity.value = this.options.cloudOpacity;
        this.cloudMaterial.uniforms.cloudBrightness.value = this.options.cloudBrightness;
        
        // Update Atmosphere material uniforms
        this.atmosphereMaterial.uniforms.atmosphereIntensity.value = this.options.atmosphereIntensity;
      }
      
      updateSunDirection(longitude, declination) {
        // Convert longitude and declination to Cartesian coordinates
        const phi = (90 - declination) * Math.PI / 180;
        const theta = longitude * Math.PI / 180;
        
        const sunX = Math.sin(phi) * Math.cos(theta);
        const sunY = Math.cos(phi);
        const sunZ = Math.sin(phi) * Math.sin(theta);
        
        const sunDirection = new THREE.Vector3(sunX, sunY, sunZ);
        
        // Update shader uniforms
        this.earthMaterial.uniforms.sunDirection.value = sunDirection;
        this.cloudMaterial.uniforms.sunDirection.value = sunDirection;
        this.atmosphereMaterial.uniforms.sunDirection.value = sunDirection;
        
        // Debug info
        console.log(`Sun direction updated: longitude=${longitude}, declination=${declination}`);
        console.log(`Sun vector: x=${sunX.toFixed(2)}, y=${sunY.toFixed(2)}, z=${sunZ.toFixed(2)}`);
      }
      
      update() {
        if (this.cloudMesh) {
          this.cloudMesh.rotation.y += this.options.cloudRotationSpeed;
        }
      }
      
      // New method to check if all high-res textures are cached
      async areHighResTexturesCached() {
        try {
          // Set a timeout for cache checking to avoid long startup delays
          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Cache check timeout')), 500)
          );
          
          // Check textures one by one and fail fast if any aren't cached
          for (const type of this.textureManager.textureTypes) {
            const url = this.textureManager.getTextureUrl(type, 'high');
            
            // Use Promise.race to implement timeout for each check
            const isCached = await Promise.race([
              TextureCache.hasTexture(url),
              timeout
            ]);
            
            if (!isCached) {
              console.log(`High-res texture not cached: ${type}`);
              return false; // Early return if any texture isn't cached
            }
          }
          
          console.log('All high-resolution textures are cached');
          return true;
        } catch (err) {
          console.warn('Fast cache check failed:', err);
          return false; // Safely default to low-res on any error
        }
      }

      // Modified zoom listener to avoid redundant loading attempts
      setupZoomListener() {
        // Just monitor for fallback to low-res if high-res fails
        setInterval(() => {
          if (this.textureLoadingFailed) return;
          
          // If for some reason we're still on empty textures after a while,
          // attempt to load low-res textures
          if (!this.earthMaterial.uniforms.dayMap.value || 
              this.earthMaterial.uniforms.dayMap.value.image.width <= 64) {
            console.log('Still using empty textures, attempting to load low-resolution textures');
            this.loadTextures('low');
          }
        }, 10000); // Check after 10 seconds
      }

      update() {
        if (this.cloudMesh) {
          this.cloudMesh.rotation.y += this.options.cloudRotationSpeed;
        }
      }
      
      setCloudOpacity(opacity) {
        this.options.cloudOpacity = opacity;
        if (this.cloudMaterial && this.cloudMaterial.uniforms.cloudOpacity) {
          this.cloudMaterial.uniforms.cloudOpacity.value = opacity;
        }
      }
      
      getEarthMesh() {
        return this.earthMesh;
      }
    }


    function getKeyboardFocusableElements(element = document) {
        return Array.from(element.querySelectorAll(
            'a, button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])'
        ))
        .filter(el => !el.hasAttribute('disabled'))
        .sort((a, b) => {
            // Get explicit tabindex values
            const aTabIndex = parseInt(a.getAttribute('tabindex') || '0', 10);
            const bTabIndex = parseInt(b.getAttribute('tabindex') || '0', 10);
            
            // Sort by tabindex (elements with tabindex > 0 come first, in numerical order)
            if (aTabIndex > 0 && bTabIndex > 0) {
                return aTabIndex - bTabIndex;
            }
            
            // Elements with tabindex > 0 come before elements with tabindex = 0
            if (aTabIndex > 0) return -1;
            if (bTabIndex > 0) return 1;
            
            // Elements with tabindex = 0 are sorted by their DOM position
            return 0;
        });
    }

    // Set up event listeners
    function setupEventListeners() {
      // Window resize event
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
        // Search input events
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        searchInput.addEventListener('input', handleSearch);
        
        // Reset selection index when focusing back on the search input
        searchInput.addEventListener('focus', () => {
            // Reset the selectedSearchIndex when focus returns to input
            selectedSearchIndex = -1;
            
            if (searchResults.children.length > 0) {
            searchResults.style.display = 'block';
            }
        });

        document.body.addEventListener('keydown', (e) => {
    const searchResults = document.getElementById('searchResults');
    
    // Only handle arrow keys when search results are visible
    if (searchResults.style.display === 'block' && 
        (e.key === 'ArrowDown' || e.key === 'ArrowUp' || 
         e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
        
        e.preventDefault();
        
        // Get all focusable elements
        const focusableElements = getKeyboardFocusableElements();
        
        // Get current element's position in the tab order
        const currentElement = document.activeElement;
        const currentIndex = focusableElements.indexOf(currentElement);
        
        if (currentIndex !== -1) {
            // Determine next position based on arrow key
            let nextIndex;
            if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                nextIndex = Math.min(currentIndex + 1, focusableElements.length - 1);
            } else {
                nextIndex = Math.max(currentIndex - 1, 0);
            }
            
            // Focus the next element
            if (nextIndex !== currentIndex) {
                focusableElements[nextIndex].focus();
                
                // If it's a search result item, ensure it's visible
                if (focusableElements[nextIndex].classList.contains('search-result-item')) {
                    focusableElements[nextIndex].scrollIntoView({ block: 'nearest' });
                }
            }
        }
    }
});

        // Simplified searchInput event listener - just for Enter and Escape
        searchInput.addEventListener('keydown', (e) => {
            // Handle Enter key regardless of search results visibility
            if (e.key === 'Enter') {
                e.preventDefault();
                selectSearchResult();
                return;
            }
            
            if (searchResults.style.display === 'block' && e.key === 'Escape') {
                e.preventDefault();
                searchResults.style.display = 'none';
            }
        });
            
        // Close button event - reset highlights when panel closes
        document.getElementById('closeBtn').addEventListener('click', () => {
            document.getElementById('infoPanel').style.display = 'none';
            resetAllMarkers();
        });

        // Click event for globe interactions
        renderer.domElement.addEventListener('click', onDocumentMouseClick);
        

      // Close search results when clicking outside
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
          searchResults.style.display = 'none';
        }
      });
      
      // Theme change detection
      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          if (!CONFIG.theme) {
            currentTheme = getTheme();
            updateTheme();
          }
        });
      }
      
      // Update camera change events
      controls.addEventListener('change', onCameraChange);
    }
    
    // Handle camera change for day/night shader
    function onCameraChange() {
      // Adjust rotation speed based on zoom level
      adjustRotationSpeed();
    }
    
    // Update theme visuals
    function updateTheme() {
      // Update background
      const backgroundColor = currentTheme === 'dark' ? 0x121212 : 0xf5f5f5;
      scene.background = new THREE.Color(backgroundColor);
      
      // Update fog
      const fogColor = currentTheme === 'dark' ? 0x333333 : 0xcccccc;
      scene.fog = new THREE.Fog(fogColor, 400, 2000);
      
      // Update atmosphere
      globe.atmosphereColor(currentTheme === 'dark' ? "#3a228a" : "#ccc");
      
      // Update day texture (would require reloading textures)
      // This would be better handled by recreating the globe
    }
    

    function resetAllMarkers() {
      scene.children
        .filter(obj => obj.name === 'priest-marker')
        .forEach(marker => marker.material.color.set(CONFIG.markerColor));
      
      scene.children
        .filter(obj => obj.name === 'priest-pulse')
        .forEach(pulse => {
          pulse.children
            .filter(child => child.isMesh)
            .forEach(mesh => mesh.material.color.set(CONFIG.markerPulseColor));
        });
    }

    function highlightSelectedPriest(priest) {
      // First reset all markers to their default color
      resetAllMarkers();
      
      // Then highlight the selected priest's markers
      scene.children
        .filter(obj => obj.name === 'priest-marker' && obj.priestData && obj.priestData.Name === priest.Name)
        .forEach(marker => {
          console.log(`Highlighting marker for ${priest.Name}`);
          marker.material.color.set('yellow');
        });
      
      // Find all pulse groups with this priest's data
      scene.children
        .filter(obj => obj.name === 'priest-pulse' && obj.priestData && obj.priestData.Name === priest.Name)
        .forEach(pulse => {
          // For each child of the pulse group that's a mesh
          pulse.children
            .filter(child => child.isMesh)
            .forEach(mesh => {
              mesh.material.color.set('rgba(255, 255, 0, 0.4)');
            });
        });
    }

    // Select the current search result
    function selectSearchResult(priest) {
        const searchResultsContainer = document.getElementById('searchResults');
        const items = searchResultsContainer.querySelectorAll('.search-result-item');
        
        // If no selection but we have results, select the first one
        if (selectedSearchIndex < 0 && items.length > 0) {
            selectedSearchIndex = 0;
        }
        
        if (selectedSearchIndex >= 0 && selectedSearchIndex < items.length) {
            const priest = searchResults[selectedSearchIndex];
            if (!priest) return;
            
            showPriestInfo(priest);
            focusOnPoint(priest.Latitude, priest.Longitude);
            highlightSelectedPriest(priest);
            
            // Hide search results and clear input
            searchResultsContainer.style.display = 'none';
            document.getElementById('searchInput').value = '';
        }
    }
          
    // Mouse click event handler
    function onDocumentMouseClick(event) {
      // Calculate mouse position in normalized device coordinates
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      // Update the raycaster with the camera and mouse position
      raycaster.setFromCamera(mouse, camera);
      
      // Get all interactive objects (markers and their related elements)
      const interactiveObjects = scene.children.filter(obj => 
        obj.name === 'priest-marker' || 
        obj.name === 'priest-pulse' || 
        obj.name === 'priest-marker-invisible'
      );
      
      // Find all intersections with interactive objects
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      
      // If we have intersections
      if (intersects.length > 0) {
        console.log("got intersect!")
        /*
        // Filter out back-side hits
        const frontSideHits = intersects.filter(hit => {
          // For each hit, check if it's on the front side
          const hitPoint = hit.point.clone();
          const cameraToHit = new THREE.Vector3().subVectors(hitPoint, camera.position);
          const cameraToCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), camera.position);
          return cameraToHit.dot(cameraToCenter) <= 0;
        });
        
        if (frontSideHits.length === 0) return;
        */
        frontSideHits = intersects;
        console.log("got frontSideHits!")

        // Map to collect unique priest data
        const hitPriests = new Map();
        
        // Process each hit
        for (const hit of frontSideHits) {
          const obj = hit.object;
          let priestData;
          
          // Get priest data based on object type
          if (obj.name === 'priest-marker' || obj.name === 'priest-marker-invisible') {
            priestData = obj.priestData;
          } else if (obj.parent && obj.parent.name === 'priest-pulse') {
            priestData = obj.parent.priestData;
          } else if (obj.name === 'priest-pulse') {
            priestData = obj.priestData;
          }
          
          // Add to our map if we found priest data
          if (priestData && !hitPriests.has(priestData.Name)) {
            hitPriests.set(priestData.Name, {
              priestData: priestData,
              distance: hit.distance
            });
            
            // Debug information
            console.log(`Hit detected for priest: ${priestData.Name}`);
          }
        }
        
        // Convert map to array and sort by distance
        const hitResults = Array.from(hitPriests.values())
          .sort((a, b) => a.distance - b.distance);
        
        console.log(`Found ${hitResults.length} hit results`);
        
        if (hitResults.length === 1) {
          // Single priest hit
          const priestData = hitResults[0].priestData;
          showPriestInfo(priestData);
          highlightSelectedPriest(priestData);
          focusOnPoint(priestData.Latitude, priestData.Longitude);
        } else if (hitResults.length > 1) {
          // Multiple priests hit
          event.stopPropagation();
          showProximitySearchResults(hitResults);
        }
      } else {
        console.log('No intersections found');
      }
    }
    // Function to display search results when multiple priests are selected
    function showProximitySearchResults(results) {
      let searchResultsContainer = document.getElementById('searchResults');

      // Clear previous results
      searchResultsContainer.innerHTML = '';
      searchResults = [];
      selectedSearchIndex = -1;
      
      // Add results to global searchResults array
      searchResults = results.map(result => result.priestData);
      
      // Create result items
      results.forEach((result, i) => {
        const priest = result.priestData;
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result-item';
        resultItem.tabIndex = i + 200;
        resultItem.textContent = `${priest.Name} (${priest['Location/Area'] || 'Unknown'})`;
        
        resultItem.addEventListener('click', () => {
          showPriestInfo(priest);
          focusOnPoint(priest.Latitude, priest.Longitude);
          highlightSelectedPriest(priest);
          searchResultsContainer.style.display = 'none';
        });
        
        resultItem.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            resultItem.click();
          }
        });
        
        searchResultsContainer.appendChild(resultItem);
      });
      
      // Display results
      searchResultsContainer.style.display = 'block';
    }

    // Animation loop
    function enhancedAnimate() {
      requestAnimationFrame(enhancedAnimate);
      
      // Update Earth's cloud rotation if available
      if (enhancedEarth) {
        enhancedEarth.update();
      }
      
      // Animate pulse rings for markers
      animatePulseRings();
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    // Animate pulse rings
    function animatePulseRings() {
      const time = Date.now() * 0.001; // time in seconds
      
      pulseMeshes.forEach(mesh => {
        // Pulse scale with sine wave (0.8 to 1.2)
        const scale = 1 + 0.2 * Math.sin(time * 2 + mesh.pulseOffset);
        mesh.scale.set(scale, scale, scale);
        
        // Pulse opacity (0.4 to 0.8)
        mesh.material.opacity = 0.4 + 0.2 * Math.abs(Math.sin(time + mesh.pulseOffset));
      });
    }
    
    // Load priests data
    function loadPriestsData() {
      // Default data as fallback
      const defaultCsvData = `Type,Name,Born Year,Associates With,Beliefs,Location/Area,Contact/Website,Ordained in Rite,Ordained By,Consecrated in Rite,Consecrated By,Bishop Line,Notes
Bishop,Richard Williamson,,SSPX (originally),Resistance,England,,Old Rite,Archbishop Lefebvre,Old Rite,Archbishop Lefebvre,Lefebvre,Consecrated in 1988 by Archbishop Lefebvre; leads "SSPX Resistance"
Bishop,Gerardo Zendejas,,Resistance,Non-sede,USA,https://thebluepaper.org/,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated bishop on May 11 2017 by Bp. Williamson
Bishop,Jean-Michel Faure,1941,Resistance,Non-sede,France,,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2015 by Bp. Williamson in Brazil
Bishop,Paul Morgan,,Independent? (formerly SSPX),Mixed,Unknown,,Old Rite,Archbishop Lefebvre,,,,Former SSPX District Superior of GB; uncertain present status
Bishop,Thomas Aquinas (OSB),,Resistance,Non-sede,Brazil,,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2016 by Bp. Williamson (Nova Friburgo)
Bishop,Giacomo Ballini,,Resistance,Non-sede,Italy/Ireland,,Old Rite,,Old Rite,Bp. R. Williamson,Lefebvre,Works with Fr. Chazal/Hewko
Bishop,Czeslaw Stobnicki,,Resistance,Non-sede,Poland,,Old Rite,,Old Rite,Bp. R. Williamson,Lefebvre,Little info available; mention as "Bp. Stobnicki (PL)"
Bishop,Carlo Maria ViganÃ²,1941,Independent? (ex-Nuncio),Unclear (traditional-leaning),Europe,,New Rite (likely),Pope Paul VI or John Paul II,New Rite (likely),,,"Conciliar, sometimes labeled "sede?" by rumor, but no official claim"
Father,Martin Fuchs,,Resistance,Non-sede,Austria,https://corjesu.info/wordpress/?p=2240,Old Rite,,,,,Mentioned with "SSPX Resistance" in Austria
Father,Peter Lang,,Resistance,Non-sede,Germany,pater.lang@gmx.de,Old Rite,,,,,German SSPX Resistance priest`;
      
      if (CONFIG.dataUrl) {
        // Fetch data from configured URL
        fetch(CONFIG.dataUrl)
          .then(response => response.text())
          .then(csvData => {
            parseAndProcessData(csvData);
          })
          .catch(error => {
            console.error('Error loading data:', error);
            console.log('Falling back to default data');
            parseAndProcessData(defaultCsvData);
          });
      } else {
        // Use default hardcoded data
        parseAndProcessData(defaultCsvData);
      }
    }
    
    // Parse and process CSV data
    function parseAndProcessData(csvData) {
      Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          // Process data and add missing columns (lat, long, GoogleMaps)
          priests = addGeoData(results.data);
          
          // Once data is loaded, populate the globe
          window.setTimeout(function() {
            populateGlobeWithMarkers(priests);
          }, 400);
        },
        error: (error) => {
          console.error('Error parsing CSV:', error);
        }
      });
    }
    
    // Add geographic data to priests
    function addGeoData(priests) {
      return priests.map(priest => {
        // Assign locations to actual coordinates
        let lat, lng;
        
        switch(priest['Location/Area']) {
          case 'England':
            lat = 52.3555; lng = -1.1743;
            break;
          case 'USA':
            lat = 37.0902; lng = -95.7129;
            break;
          case 'France':
            lat = 46.2276; lng = 2.2137;
            break;
          case 'Brazil':
            lat = -14.2350; lng = -51.9253;
            break;
          case 'Italy/Ireland':
            lat = 41.8719; lng = 12.5674; // Using Italy
            break;
          case 'Poland':
            lat = 51.9194; lng = 19.1451;
            break;
          case 'Europe':
            lat = 48.8566; lng = 2.3522; // Using Paris as a European center
            break;
          case 'Austria':
            lat = 47.5162; lng = 14.5501;
            break;
          case 'Germany':
            lat = 51.1657; lng = 10.4515;
            break;
          default:
            // Random coordinates for unknown locations
            lat = parseFloat((Math.random() * 180 - 90).toFixed(4));
            lng = parseFloat((Math.random() * 360 - 180).toFixed(4));
        }
        
        return {
          ...priest,
          Latitude: lat,
          Longitude: lng,
          GoogleMaps: `https://maps.google.com/?q=${lat},${lng}`
        };
      });
    }
    
    function getPointOnGlobe(lat, lng, altitude = 0) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      // Use the earth radius directly from the EnhancedEarth instance
      // This ensures consistency between all objects
      const radius = enhancedEarth.earthRadius + altitude;
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }

    // Populate the globe with markers and pulse rings
    function populateGlobeWithMarkers(data) {
  if (!globe) return;
  
  // Clear any existing markers
  const existingMarkers = scene.children.filter(obj => 
    obj.name === 'priest-marker' || obj.name === 'priest-pulse' || obj.name === 'priest-marker-invisible'
  );
  existingMarkers.forEach(marker => scene.remove(marker));
  
  // Clear pulse meshes array
  pulseMeshes = [];
  
  // Create markers for each priest
  data.forEach(priest => {
    // Get coordinates
    const lat = priest.Latitude;
    const lng = priest.Longitude;
    
    // Calculate position on globe surface
    const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
    
    // Add dot marker with smooth shading
    const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
    markerGeometry.computeVertexNormals(); // Ensure smooth normals
    
    const markerMaterial = new THREE.MeshPhongMaterial({ 
      color: CONFIG.markerColor,
      shininess: 0,
      flatShading: false
    });
    
    const marker = new THREE.Mesh(markerGeometry, markerMaterial);
    
    // Set marker position
    marker.position.set(position.x, position.y, position.z);
    marker.name = 'priest-marker';
    marker.priestData = priest;
    
    // Add marker to scene
    scene.add(marker);
    
    // === REPLACED RING WITH SQUISHED SPHERE ===
    // Add pulsating squished sphere around marker
    const pulseGeometry = new THREE.SphereGeometry(CONFIG.markerRingSize, 32, 32);
    const pulseMaterial = new THREE.MeshBasicMaterial({
      color: CONFIG.markerPulseColor,
      transparent: true,
      opacity: 0.9,
      side: THREE.DoubleSide
    });
    
    const pulseMesh = new THREE.Mesh(pulseGeometry, pulseMaterial);
    // Make it a squished sphere by scaling down the y-axis
    pulseMesh.scale.y = 0.25; // Adjust this value to control how squished it is
    
    // Create a group to contain the pulse mesh
    const pulse = new THREE.Group();
    pulse.add(pulseMesh);
    
    // Position pulse at the same coordinates as marker
    pulse.position.set(position.x, position.y, position.z);
    pulse.lookAt(0, 0, 0); // Orient properly toward center
    pulse.name = 'priest-pulse';
    pulse.priestData = priest;
    
    // Add random offset for animation
    pulseMesh.pulseOffset = 0.0;
    
    // Add to pulse meshes array for animation
    pulseMeshes.push(pulseMesh);
    
    // Add pulse to scene
    scene.add(pulse);
    
    // Add invisible larger detection sphere for better interaction
    const invisibleSphereGeometry = new THREE.SphereGeometry(CONFIG.markerRingSize * 1.5, 16, 16);
    const invisibleSphereMaterial = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
    });
    
    const invisibleSphere = new THREE.Mesh(invisibleSphereGeometry, invisibleSphereMaterial);
    
    // Position at same coordinates as marker
    invisibleSphere.position.set(position.x, position.y, position.z);
    invisibleSphere.name = 'priest-marker-invisible';
    invisibleSphere.priestData = priest;
    
    // Add to scene
    scene.add(invisibleSphere);
  });
}
    // Show priest info in the panel
    function showPriestInfo(priest) {
      const infoPanel = document.getElementById('infoPanel');
      const priestName = document.getElementById('priestName');
      const priestInfo = document.getElementById('priestInfo');
      
      // Set priest name
      priestName.textContent = priest.Name;
      
      // Clear previous info
      priestInfo.innerHTML = '';
      
      // Add fields in configured order
      CONFIG.fieldOrder.forEach(field => {
        if (priest[field]) {
          const row = document.createElement('div');
          row.className = 'info-row';
          
          if (field === 'Contact/Website' && priest[field].startsWith('http')) {
            let niceurl = priest[field].replace("https://", "").replace("http://");
            row.innerHTML = `<strong>${field}:</strong> <a href="${priest[field]}" target="_blank" class="info-link">${niceurl}</a>`;
          } else {
            row.innerHTML = `<strong>${field}:</strong> <p>${priest[field]}</p>`;
          }
          
          priestInfo.appendChild(row);
        }
      });
      
      // Add Google Maps link
      const mapsRow = document.createElement('div');
      mapsRow.className = 'info-row';
      mapsRow.innerHTML = `<a href="${priest.GoogleMaps}" target="_blank" class="info-link maps">View on Google Maps</a>`;
      priestInfo.appendChild(mapsRow);
      
      // Show the info panel
      infoPanel.style.display = 'block';
    }
    
    // Handle search input
    function handleSearch(event) {
        const searchTerm = event.target.value.toLowerCase();
        const searchResultsContainer = document.getElementById('searchResults');
        
        // Reset search results
        searchResultsContainer.innerHTML = '';
        searchResults = [];
        selectedSearchIndex = -1;
        
        if (searchTerm.length < 1) {
            searchResultsContainer.style.display = 'none';
            resetAllMarkers();
            return;
        }
        
        // Filter priests based on search term
        searchResults = priests.filter(priest => 
            priest.Name.toLowerCase().includes(searchTerm) || 
            (priest['Location/Area'] && priest['Location/Area'].toLowerCase().includes(searchTerm))
        );
        
        // Highlight matching markers
        const markers = globe.children.filter(obj => obj.name === 'priest-marker');
        markers.forEach(marker => {
            const priest = marker.priestData;
            const isMatch = searchResults.some(p => p.Name === priest.Name);
            
            marker.material.color.set(isMatch ? 'yellow' : CONFIG.markerColor);
        });
        
        // Populate search results dropdown
        if (searchResults.length > 0) {
            searchResults.forEach((priest, i) => {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            // Use consecutive tabindex values starting from 1 higher than the search input
            resultItem.tabIndex = i + 200; 
            resultItem.textContent = `${priest.Name} (${priest['Location/Area'] || 'Unknown'})`;
            
            // Add click and keydown handlers
            resultItem.addEventListener('click', () => {
                showPriestInfo(priest);
                focusOnPoint(priest.Latitude, priest.Longitude);
                highlightSelectedPriest(priest);
                searchResultsContainer.style.display = 'none';
                document.getElementById('searchInput').value = '';
            });
            
            resultItem.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                resultItem.click();
                }
            });
            
            searchResultsContainer.appendChild(resultItem);
            });
            
            searchResultsContainer.style.display = 'block';
        } else {
            searchResultsContainer.style.display = 'none';
        }
    }

    function clearSearchResults(searchResultsContainer) {
        searchResultsContainer.style.display = 'none';
        // Clear search input
        document.getElementById('searchInput').value = '';
    }

    function clickSearchResult(priest, searchResultsContainer) {
        // Show info panel
        showPriestInfo(priest);
        
        // Focus on the point
        focusOnPoint(priest.Latitude, priest.Longitude);
        
        // Reset markers color
        markers.forEach(marker => {
            marker.material.color.set(CONFIG.markerColor);
        });
    }

    // Focus camera on a specific point
    function focusOnPoint(lat, lng, zoomLevel = 200.0) {
      // Calculate target position with Earth radius and adjusted coordinates
      const targetPosition = getPointOnGlobe(lat - 5, lng, 2);
      
      // Normalized direction vector
      const direction = new THREE.Vector3();
      direction.subVectors(targetPosition, new THREE.Vector3(0, 0, 0)).normalize();
      
      // Get current distance from camera to center
      const currentDistance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
      
      // Calculate target distance
      const targetDistance = Math.max(
        controls.minDistance,
        Math.min(controls.maxDistance, currentDistance * (zoomLevel / CONFIG.currentZoomLevel))
      );
      CONFIG.currentZoomLevel = zoomLevel;

      // Calculate new camera position
      const newPosition = direction.multiplyScalar(targetDistance);
      
      // Animate camera move
      const startPosition = camera.position.clone();
      const startTime = Date.now();
      
      function animateCamera() {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / CONFIG.focusAnimationDuration, 1);
        
        // Easing function (ease-out)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPosition, newPosition, easeProgress);
        
        // Look at center
        camera.lookAt(0, 0, 0);
        
        // Update controls
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        } else {
          // Animation complete - update controls target
          controls.target.set(0, 0, 0);
          controls.update();
        }
      }
      
      // Start animation
      animateCamera();
    }

    // Initialize the application
    init();
    </script>
</body>
</html>
