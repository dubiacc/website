<!DOCTYPE html>
<html lang="en">

<head>
  <title>Entdecke den wahren katholischen Glauben - dubia.cc</title>
  <meta name="description" content="<p class='first-graf'>dubia ist eine Sammlung von Artikeln über den traditionellen katholischen Glauben. Hat die Kirche wirklich...? Antworten auf Irrtümer, Gebete, uvm.</p>">
  <link rel="alternate" hreflang="en" href="https://dubia.cc/en">
  <link rel="alternate" hreflang="de" href="https://dubia.cc/de">
  <link rel="alternate" hreflang="x-default" href="https://dubia.cc">
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#161616" media="(prefers-color-scheme: dark)">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-RegularItalic.woff2" as="font" type="font/woff2">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-Regular.woff2" as="font" type="font/woff2">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-Semibold.woff2" as="font" type="font/woff2">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title data-i18n="CATHOLIC_RESISTANCE_GLOBE">Catholic Resistance Globe</title>
  <link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
  <script src="/static/js/three.min.js"></script>
  <script src="/static/js/three-globe.min.js"></script>
  <script src="/static/js/OrbitControls.js"></script>
  <script src="/static/js/papaparse.min.js"></script>
  <style>
    :root {
      --background-color: #f5f5f5;
      --text-color: #333;
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-text: #333;
      --atmospheric-color: #ccc;
      --search-bg: white;
      --search-text: #333;
      --search-placeholder: #999;
      --search-results-bg: white;
      --search-results-hover: #f0f0f0;
      --link-color: #8b0000;
      --focus-col: rgb(61, 99, 170);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #121212;
        --text-color: #f5f5f5;
        --panel-bg: rgba(33, 33, 33, 0.95);
        --panel-text: #f5f5f5;
        --atmospheric-color: #3a228a;
        --search-bg: #333;
        --search-text: #f5f5f5;
        --search-placeholder: #777;
        --search-results-bg: #333;
        --search-results-hover: #444;
        --link-color: #ff6b6b;
      }
    }
    
    * {
        margin: 0px;
        padding: 0px;
    }

    html {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background-color);
      font-family: Arial, sans-serif;
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      height: 100%;
    }
    
    #globeContainer {
        position: absolute;
        height: 100%;
        width: 100%;
    }
    
    .search-container {
        display: flex;
        justify-content: space-between;
        flex-direction: column;
        pointer-events: none;
        z-index: 10;
        flex-grow: 1;
        padding: 10px;
        padding-top: 0px;
    }

    #priestInfo {
        display: flex;
        flex-direction: column;
        margin-top: 10px;
    }

    .search-input {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        padding: 10px;
        font-style: italic;
        border: none;
        background: var(--search-bg);
        color: var(--search-text);
        font-size: 1.5rem;
        outline: none;
        border: 3px solid var(--search-bg);
        pointer-events: all;
    }
    
    .search-input:focus {
        border: 3px solid var(--focus-col);
    }

    .search-input::placeholder {
      color: var(--search-placeholder);
    }
    
    .search-results {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        font-style: italic;
        overflow-y: scroll;
        background: var(--search-results-bg);
        border-radius: 0 0 5px 5px;
        z-index: 11;
        pointer-events: all;
        max-height: 200px;
        overflow-y: scroll;
    }
    
    .search-result-item {
      padding: 10px;
      cursor: pointer;
      transition: background-color 0.2s;
      border: 3px solid transparent;
      font-size: 1.5rem;
    }
    
    .search-result-item:focus {
        border: 3px solid var(--focus-col);
        background-color: var(--search-results-hover);
    }

    .info-panel {
        margin-bottom: 10px;
        box-shadow: 2.5px 2.5px 5px black;
        pointer-events: all;
        position: relative;
        background: white;
        padding: 20px;
        max-height: 70vh;
        overflow-y: auto;
        z-index: 10;
        display: none;
        background: var(--panel-bg);
        color: var(--panel-text);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        font-family: 'Times';
        font-style: italic;
        font-size: 1.2rem;
    }
    
    .info-panel h2 {
        margin-top: 0;
        font-size: 2rem;
        font-weight: bold;
    }
    
    .info-row {
        margin-bottom: 4px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
    }
    
    /* Add these styles to your existing CSS */
    .notes-section, .mass-times-section {
      padding-top: 8px;
    }

    .notes-section strong, .mass-times-section strong {
      display: inline;
      padding-right: 5px;
    }

    .notes-section p, .mass-times-section p {
      display: inline;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .mass-times-section {
      color: #8b0000;
      font-weight: 500;
    }

    @media (prefers-color-scheme: dark) {
      .notes-section, .mass-times-section {
        border-top: 1px solid rgba(255,255,255,0.1);
      }
      
      .mass-times-section {
        color: #ff6b6b;
      }
    }

    /* Make title more prominent */
    #priestName {
      font-family: 'UnifrakturMaguntia', serif;
      font-size: 2.5rem;
    }

    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        background: #cc0000;
        font-size: 2rem;
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    .info-link {
      background: #004970;
      color: white;
      font-weight: bold;
      text-decoration: underline;
    }
    .info-link.maps {
        background: #700000;
        color: white;
        padding: 10px;
        font-weight: bold;
        font-style: normal;
        font-family: sans-serif;
        margin-top: 1rem;
        text-decoration: none;
    }
    
    .info-link.maps:hover {
      text-decoration: underline;
    }

  .parishes-section h3 {
    margin-top: 0;
    font-size: 1.3rem;
  }

  .parishes-list {
    list-style-type: none;
    padding-left: 0;
    margin-top: 5px;
  }

  .parish-item {
    margin-bottom: 8px;
    line-height: 1.4;
  }

  @media (prefers-color-scheme: dark) {
    .parishes-section {
      border-top: 1px solid rgba(255,255,255,0.1);
    }
  }

  .priest-link {
      color: var(--link-color);
      text-decoration: underline;
      cursor: pointer;
      margin-top: 5px;
      display: inline-block;
    }
    
    .priest-link:hover {
      text-decoration: none;
    }
    
    .parish-item {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .parish-item strong {
      text-decoration: underline;
    }
    .parish-item:hover {
      background-color: rgba(128, 128, 128, 0.1);
      border-radius: 3px;
      padding-left: 5px;
    }

    .links {
      position: absolute;
    }
    
    .links > div {
      display: flex;
      flex-direction: row;
    }

    .outbound-link, .outbound-link:visited, .outbound-link:focus, .outbound-link:hover {
      color: white;
      font-size: 1.5rem;
      background-color: black;
      margin-right: 10px;
      padding: 5px;
      text-decoration: none;
    }


    @media (max-width: 800px) {
      .title {
        display: none;
      }
      
      .links {
        width: 100%;
        display: flex;
        flex-grow: 1;
      }
      .links > div {
        flex-direction: row;
        display: flex;
        flex-grow: 0;
      }
      .links > div > a {
        margin-top: 5px;
        flex-grow: 1;
        display: flex;
      }

      .info-panel {
        max-height: 60vh;
        font-size: 0.9rem;
      }
      #priestName {
        font-size: 1.4rem;
      }
      .search-input {
        font-size: 1.2rem;
      }
      .search-results, .search-result-item {
        font-size: 1.2rem;
      }
      .outbound-link, .outbound-link:visited, .outbound-link:focus, .outbound-link:hover {
        font-size: 1rem;
      }
      #priestInfo {
        font-size: 1rem;
      }
    }

    /* Import the same fonts as dubia.cc */
    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 400;
      font-style: normal;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-Regular.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 400;
      font-style: italic;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-RegularItalic.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 600;
      font-style: normal;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-Semibold.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Kanzlei Initialen';
      src: url('/static/font/kanzlei/Kanzlei-Initialen-D.ttf') format('truetype');
      font-display: swap;
      unicode-range: U+0044;
    }

    :root {
      --GW-serif-font-stack: "Source Serif Pro", "Apple Garamond", "Baskerville", "Libre Baskerville", "Droid Serif", "Times New Roman", "Times", serif;
      --GW-sans-serif-font-stack: "Lucida Sans Unicode", "Helvetica", "Trebuchet MS", sans-serif;
      --GW-monospaced-font-stack: "IBM Plex Mono", "Liberation Mono", "Consolas", "Courier", monospace;
      --background-color: #fff;
      --text-color: #000;
    }

    /* Dark mode */
    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #161616;
        --text-color: #f1f1f1;
      }
    }

    /* Compact header styles */
    #header {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      padding: 10px 0;
      max-width: 500px;
      min-width: 500px;
      z-index: 5;
      height: 100%;
      position: absolute;
      pointer-events: none;
    }

    .title {
      font-family: 'UnifrakturMaguntia', serif;
      font-size: 2.5rem;
      color: var(--background-color);
      text-align: center;
      background: var(--text-color);
      mix-blend-mode: difference;
      width: 100%;
      text-align: center;
      font-family: 'UnifrakturMaguntia', serif;
      z-index: 10;
      pointer-events: none;
      padding: 10px 0px;
      margin-bottom: 10px;
    }

    #sidebar {
      display: flex;
      justify-content: center;
      flex-direction: column;
      padding: 10px;
    }

    #sidebar a {
      display: block;
      border: 1px dotted currentColor;
      text-align: center;
      margin: 0 2px;
      color: var(--text-color);
      text-decoration: none;
      font-family: var(--GW-serif-font-stack);
    }

    #sidebar a.logo {
      display: flex;
      align-items: center;
      margin: 1px 0;
      background-color: var(--background-color);
    }

    #sidebar .sidebar-links {
      flex: 1 1 100%;
      display: flex;
      flex-flow: row wrap;
      pointer-events: initial;
    }

    #sidebar .sidebar-links > * {
      font-variant-caps: small-caps;
      background: var(--background-color);
      align-content: center;
      justify-content: center;
      flex: 1;
      padding: 5px;
      pointer-events: initial;
      cursor: pointer;
    }

    /* Language selector */
    .language-selector {
      display: flex;
      margin-left: 2px;
    }

    #language-select {
      border: none;
      border-radius: 0px;
      background-color: var(--background-color);
      color: var(--text-color);
      font-size: 14px;
      cursor: pointer;
      font-family: var(--GW-serif-font-stack);
      font-variant-caps: small-caps;
    }

    /* Make the header more compact on mobile */
    @media all and (max-width: 649px) {
      .title {
        font-size: 1.8rem;
      }
      
      #sidebar .sidebar-links a {
        padding: 3px 5px;
        font-size: 0.9rem;
      }
    }

    /* Tutorial labels */
    .tutorial-label {
      position: absolute;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-size: 14px;
      font-weight: bold;
      pointer-events: none;
      z-index: 9999;
      transform: translate(-50%, -100%);
      transition: opacity 0.3s ease;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    }

    .tutorial-label::after {
      content: '';
      position: absolute;
      bottom: -6px;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 6px solid rgba(0, 0, 0, 0.7);
    }

    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      bottom: 40px;
      right: 20px;
      display: flex;
      flex-direction: column;
      z-index: 5;
    }

    .zoom-button {
      width: 40px;
      height: 40px;
      background-color: white;
      font-size: 24px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: bold;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.2s;
    }

    .zoom-button:hover {
      background-color: #f0f0f0;
    }

    .zoom-button:focus {
      outline: none;
      box-shadow: 0 0 0 2px rgba(0, 120, 255, 0.5);
    }

    /* Attribution footer */
    .attribution-footer {
      font-size: 10px;
      text-align: right;
      z-index: 5;
      position: absolute;
      right: 20px;
      bottom: 10px;
      width: 100%;
      color: grey !important;
    }

    .attribution-content a {
      color: grey !important;
      text-decoration: underline;
    }

    .attribution-content a:hover {
      text-decoration: underline;
    }

    /* For RTL languages like Arabic */
    [lang="ar"] {
      direction: rtl;
    }
    
    /* Adjust globe container to not overlap with header */
    #globeContainer {
      position: absolute;
    }
  </style>
</head>
<body>

  <header id="header">
    <nav id="sidebar">
      <h1 class="title" data-i18n="CATHOLIC_RESISTANCE">Catholic Resistance</h1>
      <div class="sidebar-links">
        <a href="/" data-i18n="GLOBE">Home</a>
        <a href="/en/topics" data-i18n="ARTICLES">Articles</a>
        <a href="/en/tools" data-i18n="RESOURCES">Tools</a>
        <a href="/en/contact" data-i18n="CONTACT">Contact</a>
          <!-- Language selector -->
          <div class="language-selector">
            <select id="language-select">
              <option value="en">English</option>
              <option value="de">Deutsch</option>
              <option value="fr">Français</option>
              <option value="it">Italiano</option>
              <option value="es">Español</option>
              <option value="pl">Polski</option>
              <option value="ro">Romana</option>
              <option value="ru">Русский</option>
              <option value="tr">Türkçe</option>
              <option value="el">Ελληνικά</option>
              <option value="ar">العربية</option>
              <option value="tl">Filipino</option>
              <option value="zh">中文</option>
              <option value="ko">한국어</option>
              <option value="ja">日本語</option>
              <option value="pt">Português</option>
            </select>
          </div>
      </div>
    </nav>

    <div class="search-container">
      <div style="display: flex; flex-direction: column;">
        <input autofocus="true" type="text" class="search-input" placeholder="Search Resistance priests..." data-i18n-placeholder="SEARCH_RESISTANCE_PRIESTS" id="searchInput">
        <div class="search-results" id="searchResults"></div>
      </div>

      <div class="info-panel" id="infoPanel">
          <button class="close-btn" id="closeBtn">×</button>
          <h2 id="priestName"></h2>
          <div id="priestInfo"></div>
        </div>
    </div>
  </header>
  
  <div id="globeContainer"></div>

  <!-- Zoom controls -->
  <div class="zoom-controls">
    <button class="zoom-button zoom-in" aria-label="Zoom in">+</button>
    <button class="zoom-button zoom-out" aria-label="Zoom out">-</button>
  </div>

  <!-- Attribution footer -->
  <div class="attribution-footer">
    <div class="attribution-content">
      <span data-i18n="DATA_SOURCES">Data Sources</span>: 
      <a href="https://github.com/johan/world.geo.json" target="_blank">World GeoJSON</a> | 
      <a href="https://simplemaps.com/data/world-cities" target="_blank">World Cities Database</a>
    </div>
  </div>

  <script>
        // Configuration - Change these values to configure the application
        const CONFIG = {
      minDistance: 160.0,
      maxDistance: 500.0,
      currentZoomLevel: 800.0,
      dataUrl: null, // Set to CSV URL or null to use the default data
      fieldOrder: [
        'Type', 'Born Year', 'Associates With', 'Beliefs', 'Location/Area',
        'Contact/Website', 'Ordained in Rite', 'Ordained By', 'Consecrated in Rite',
        'Consecrated By', 'Bishop Line', 'Notes'
      ],
      cameraYOffset: -50.0,
      markerColor: '#ff0000',
      markerPulseColor: '#ff0000',
      markerSize: 0.4,
      markerRingSize: 1.5,
      labelAltitude: 0.05, // Adjusted to work better with large Earth radius
      autoRotate: false,
      autoRotateSpeed: 0.1,
      theme: 'dark', // 'light', 'dark', or null for system preference
      focusAnimationDuration: 1000, // ms to animate to a point
      focusDistanceFactor: 0.8, // distance factor when focusing on a point (lower = closer)
      cloudOpacity: 0.8, // Add this line for cloud opacity
      cloudBrightness: 1.2, // Add this line for cloud brightness
      parishesUrl: null, // Set to CSV URL or null to use the default data
      parishMarkerColor: '#cc0000',
      parishMarkerSize: 0.3,
      parishLineColor: '#cc0000',
      parishLineWidth: 30,
    };

    // Default priest data as fallback
    const defaultPriestCsvData = `PriestID,Type,Name,Born Year,Associates With,Beliefs,Location/Area,Contact/Website,Ordained in Rite,Ordained By,Consecrated in Rite,Consecrated By,Bishop Line,Notes
    pr001,Bishop,Richard Williamson,,SSPX (originally),Resistance,England,,Old Rite,Archbishop Lefebvre,Old Rite,Archbishop Lefebvre,Lefebvre,Consecrated in 1988 by Archbishop Lefebvre; leads "SSPX Resistance"
    pr002,Bishop,Gerardo Zendejas,,Resistance,Non-sede,USA,https://thebluepaper.org/,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated bishop on May 11 2017 by Bp. Williamson
    pr003,Bishop,Jean-Michel Faure,1941,Resistance,Non-sede,France,,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2015 by Bp. Williamson in Brazil`;
      
    // Default parish data as fallback
    const defaultParishCsvData = `ParishID,PriestID,ParishName,Latitude,Longitude,IsHomePriest,MassTimes,Notes
    p001,pr001,St. Mary's Traditional Chapel,51.5074,-0.1278,true,"Sun 8:00AM, 10:30AM; Wed 7:00PM",
    p002,pr001,Sacred Heart Mission,52.4862,-1.8904,false,"1st Sun 4:00PM",Monthly Mass
    p003,pr002,St. Athanasius Church,40.7128,-74.0060,false,"Sun 9:00AM; 11:00AM; Daily 7:30AM",Home base for Fr. Zendejas
    p005,pr002,Heart of Jesus Church,47.7128,-74.0060,false,"Sun 6:00PM; Daily 7:30AM",Fr. Zendejas secondary church
    p004,pr003,Notre Dame de La Salette,48.8566,2.3522,true,"Sun 9:30AM; Thu 6:30PM",Fr. Faure's primary church`;

    // Internationalization system
    const LANGUAGES = {
      'en': { code: 'en', name: 'English', isDefault: true },
      'de': { code: 'de', name: 'Deutsch' },
      'fr': { code: 'fr', name: 'Français' },
      'it': { code: 'it', name: 'Italiano' },
      'es': { code: 'es', name: 'Español' },
      'pl': { code: 'pl', name: 'Polski' },
      'ro': { code: 'ro', name: 'Română' },
      'ru': { code: 'ru', name: 'Русский' },
      'tr': { code: 'tr', name: 'Türkçe' },
      'el': { code: 'el', name: 'Ελληνικά' },
      'ar': { code: 'ar', name: 'العربية' },
      'tl': { code: 'tl', name: 'Filipino' },
      'zh': { code: 'zh', name: '中文' },
      'ko': { code: 'ko', name: '한국어' },
      'ja': { code: 'ja', name: '日本語' }
    };

    // Complete navigation configuration for all supported languages
    const NAV_CONFIG = {
      // English navigation
      'en': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/en/topics' },
        { key: 'RESOURCES', url: '/en/tools' },
        { key: 'CONTACT', url: '/en/contact' }
      ],
      
      // German navigation
      'de': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/de/themen' },
        { key: 'RESOURCES', url: '/de/werkzeuge' },
        { key: 'CONTACT', url: '/de/kontakt' }
      ],
      
      // French navigation
      'fr': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/fr/sujets' },
        { key: 'RESOURCES', url: '/fr/outils' },
        { key: 'CONTACT', url: '/fr/contact' }
      ],
      
      // Spanish navigation
      'es': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/es/temas' },
        { key: 'RESOURCES', url: '/es/herramientas' },
        { key: 'CONTACT', url: '/es/contacto' }
      ],
      
      // Portuguese navigation
      'pt': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/pt/topicos' },
        { key: 'RESOURCES', url: '/pt/ferramentas' },
        { key: 'CONTACT', url: '/pt/contato' }
      ],
      
      // Italian navigation
      'it': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/it/argomenti' },
        { key: 'RESOURCES', url: '/it/strumenti' },
        { key: 'CONTACT', url: '/it/contatto' }
      ],
      
      // Polish navigation
      'pl': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/pl/artykuly' },
        { key: 'RESOURCES', url: '/pl/narzedzia' },
        { key: 'CONTACT', url: '/pl/kontakt' }
      ],
      
      // Romanian navigation
      'ro': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/ro/articole' },
        { key: 'RESOURCES', url: '/ro/instrumente' },
        { key: 'CONTACT', url: '/ro/contact' }
      ],
      
      // Russian navigation
      'ru': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/ru/stati' },
        { key: 'RESOURCES', url: '/ru/instrumenty' },
        { key: 'CONTACT', url: '/ru/kontakt' }
      ],
      
      // Turkish navigation
      'tr': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/tr/makaleler' },
        { key: 'RESOURCES', url: '/tr/araclar' },
        { key: 'CONTACT', url: '/tr/iletisim' }
      ],
      
      // Greek navigation
      'el': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/el/arthra' },
        { key: 'RESOURCES', url: '/el/ergaleia' },
        { key: 'CONTACT', url: '/el/epikoinonia' }
      ],
      
      // Arabic navigation
      'ar': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/ar/maqalat' },
        { key: 'RESOURCES', url: '/ar/adawat' },
        { key: 'CONTACT', url: '/ar/ittisal' }
      ],
      
      // Filipino/Tagalog navigation
      'tl': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/tl/mga-artikulo' },
        { key: 'RESOURCES', url: '/tl/mga-kasangkapan' },
        { key: 'CONTACT', url: '/tl/kontak' }
      ],
      
      // Chinese navigation
      'zh': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/zh/wenzhang' },
        { key: 'RESOURCES', url: '/zh/gongju' },
        { key: 'CONTACT', url: '/zh/lianxi' }
      ],
      
      // Korean navigation
      'ko': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/ko/geulmoeum' },
        { key: 'RESOURCES', url: '/ko/dogu' },
        { key: 'CONTACT', url: '/ko/yeonlakcheo' }
      ],
      
      // Japanese navigation
      'ja': [
        { key: 'GLOBE', url: '/' },
        { key: 'ARTICLES', url: '/ja/kiji' },
        { key: 'RESOURCES', url: '/ja/tsuuru' },
        { key: 'CONTACT', url: '/ja/renrakusaki' }
      ]
    };

    // Translation dictionary
    const TRANSLATIONS = {
      'CATHOLIC_RESISTANCE': {
        'en': 'Catholic Resistance',
        'de': 'Katholischer Widerstand',
        'fr': 'Résistance Catholique',
        'it': 'Resistenza Cattolica',
        'es': 'Resistencia Católica',
        'pl': 'Opór Katolicki',
        'ro': 'Rezistența Catolică',
        'ru': 'Католическое Сопротивление',
        'tr': 'Katolik Direniş',
        'el': 'Καθολική Αντίσταση',
        'ar': 'المقاومة الكاثوليكية',
        'tl': 'Katolikong Paglaban',
        'zh': '天主教抵抗',
        'ko': '가톨릭 저항',
        'ja': 'カトリックレジスタンス',
        'pt': 'Resistência Católica'
      },
      'GLOBE': {
        'en': 'Home',
        'de': 'Startseite',
        'fr': 'Accueil',
        'it': 'Home',
        'es': 'Inicio',
        'pl': 'Strona główna',
        'ro': 'Acasă',
        'ru': 'Главная',
        'tr': 'Ana Sayfa',
        'el': 'Αρχική',
        'ar': 'الرئيسية',
        'tl': 'Tahanan',
        'zh': '首页',
        'ko': '홈',
        'ja': 'ホーム',
        'pt': 'Início'
      },
      'ARTICLES': {
        'en': 'Articles',
        'de': 'Artikel',
        'fr': 'Articles',
        'it': 'Articoli',
        'es': 'Artículos',
        'pl': 'Artykuły',
        'ro': 'Articole',
        'ru': 'Статьи',
        'tr': 'Makaleler',
        'el': 'Άρθρα',
        'ar': 'المقالات',
        'tl': 'Mga Artikulo',
        'zh': '文章',
        'ko': '기사',
        'ja': '記事',
        'pt': 'Artigos'
      },
      'RESOURCES': {
        'en': 'Tools',
        'de': 'Werkzeuge',
        'fr': 'Outils',
        'it': 'Strumenti',
        'es': 'Herramientas',
        'pl': 'Narzędzia',
        'ro': 'Instrumente',
        'ru': 'Инструменты',
        'tr': 'Araçlar',
        'el': 'Εργαλεία',
        'ar': 'أدوات',
        'tl': 'Mga Kasangkapan',
        'zh': '工具',
        'ko': '도구',
        'ja': 'ツール',
        'pt': 'Ferramentas'
      },
      'CONTACT': {
        'en': 'Contact',
        'de': 'Kontakt',
        'fr': 'Contact',
        'it': 'Contatto',
        'es': 'Contacto',
        'pl': 'Kontakt',
        'ro': 'Contact',
        'ru': 'Контакт',
        'tr': 'İletişim',
        'el': 'Επικοινωνία',
        'ar': 'اتصال',
        'tl': 'Kontak',
        'zh': '联系',
        'ko': '연락처',
        'ja': '連絡先',
        'pt': 'Contato'
      },
      'CATHOLIC_RESISTANCE_GLOBE': {
        'en': 'Catholic Resistance Globe',
        'de': 'Katholischer Widerstand Globus',
        'fr': 'Globe de la Résistance Catholique',
        'it': 'Globo della Resistenza Cattolica',
        'es': 'Globo de la Resistencia Católica',
        'pl': 'Globus Katolickiego Oporu',
        'ro': 'Globul Rezistenței Catolice',
        'ru': 'Глобус Католического Сопротивления',
        'tr': 'Katolik Direniş Küre',
        'el': 'Υδρόγειος Καθολικής Αντίστασης',
        'ar': 'كرة المقاومة الكاثوليكية',
        'tl': 'Globo ng Katolikong Paglaban',
        'zh': '天主教抵抗地球仪',
        'ko': '가톨릭 저항 지구본',
        'ja': 'カトリックレジスタンス地球儀',
        'pt': 'Globo da Resistência Católica'
      },
      'SEARCH_RESISTANCE_PRIESTS': {
        'en': 'Search Resistance priests...',
        'de': 'Priester suchen...',
        'fr': 'Rechercher des prêtres de la Résistance...',
        'it': 'Cerca sacerdoti della Resistenza...',
        'es': 'Buscar sacerdotes de la Resistencia...',
        'pl': 'Szukaj księży oporu...',
        'ro': 'Caută preoți ai rezistenței...',
        'ru': 'Поиск священников сопротивления...',
        'tr': 'Direniş rahiplerini ara...',
        'el': 'Αναζήτηση ιερέων αντίστασης...',
        'ar': 'البحث عن كهنة المقاومة...',
        'tl': 'Maghanap ng mga pari ng paglaban...',
        'zh': '搜索抵抗神父...',
        'ko': '저항 사제 검색...',
        'ja': 'レジスタンス司祭を検索...',
        'pt': 'Pesquisar padres da Resistência...'
      },
      'VIEW_ON_MAPS': {
        'en': 'View on Google Maps',
        'de': 'Auf Google Maps ansehen',
        'fr': 'Voir sur Google Maps',
        'it': 'Visualizza su Google Maps',
        'es': 'Ver en Google Maps',
        'pl': 'Zobacz w Google Maps',
        'ro': 'Vizualizați pe Google Maps',
        'ru': 'Посмотреть на Google Картах',
        'tr': 'Google Haritalar\'da görüntüle',
        'el': 'Προβολή στους Χάρτες Google',
        'ar': 'عرض على خرائط Google',
        'tl': 'Tingnan sa Google Maps',
        'zh': '在谷歌地图上查看',
        'ko': 'Google 지도에서 보기',
        'ja': 'Google マップで見る',
        'pt': 'Ver no Google Maps'
      },
      'NOTES': {
        'en': 'Notes:',
        'de': 'Hinweise:',
        'fr': 'Notes:',
        'it': 'Note:',
        'es': 'Notas:',
        'pl': 'Uwagi:',
        'ro': 'Note:',
        'ru': 'Примечания:',
        'tr': 'Notlar:',
        'el': 'Σημειώσεις:',
        'ar': 'ملاحظات:',
        'tl': 'Mga Tala:',
        'zh': '备注:',
        'ko': '참고:',
        'ja': 'メモ:',
        'pt': 'Notas:'
      },
      'MASS_TIMES': {
        'en': 'Mass Times:',
        'de': 'Messzeiten:',
        'fr': 'Horaires des messes:',
        'it': 'Orari delle messe:',
        'es': 'Horarios de misa:',
        'pl': 'Godziny mszy:',
        'ro': 'Orele de slujbă:',
        'ru': 'Время месс:',
        'tr': 'Ayin Saatleri:',
        'el': 'Ώρες Λειτουργίας:',
        'ar': 'أوقات القداس:',
        'tl': 'Oras ng Misa:',
        'zh': '弥撒时间:',
        'ko': '미사 시간:',
        'ja': 'ミサの時間:',
        'pt': 'Horários das Missas:'
      },
      'REPORT_ERROR': {
        'en': 'report error',
        'de': 'Fehler melden',
        'fr': 'signaler une erreur',
        'it': 'segnala errore',
        'es': 'reportar error',
        'pl': 'zgłoś błąd',
        'ro': 'raportează eroare',
        'ru': 'сообщить об ошибке',
        'tr': 'hata bildir',
        'el': 'αναφορά σφάλματος',
        'ar': 'الإبلاغ عن خطأ',
        'tl': 'iulat ang error',
        'zh': '报告错误',
        'ko': '오류 신고',
        'ja': 'エラーを報告',
        'pt': 'reportar erro'
      },
      'REQUEST_MASS': {
        'en': 'request mass',
        'de': 'Messe anfragen',
        'fr': 'demander une messe',
        'it': 'richiedi messa',
        'es': 'solicitar misa',
        'pl': 'prośba o mszę',
        'ro': 'solicită slujbă',
        'ru': 'запросить мессу',
        'tr': 'ayin talep et',
        'el': 'αιτηθείτε λειτουργία',
        'ar': 'طلب قداس',
        'tl': 'humiling ng misa',
        'zh': '请求弥撒',
        'ko': '미사 요청',
        'ja': 'ミサのリクエスト',
        'pt': 'solicitar missa'
      },
      'BACK_TO_SITE': {
        'en': 'back to dubia.cc',
        'de': 'zurück zu dubia.cc',
        'fr': 'retour à dubia.cc',
        'it': 'torna a dubia.cc',
        'es': 'volver a dubia.cc',
        'pl': 'powrót do dubia.cc',
        'ro': 'înapoi la dubia.cc',
        'ru': 'назад на dubia.cc',
        'tr': 'dubia.cc\'e geri dön',
        'el': 'επιστροφή στο dubia.cc',
        'ar': 'العودة إلى dubia.cc',
        'tl': 'bumalik sa dubia.cc',
        'zh': '返回 dubia.cc',
        'ko': 'dubia.cc로 돌아가기',
        'ja': 'dubia.ccに戻る',
        'pt': 'voltar para dubia.cc'
      },
      'HOME_PARISH': {
        'en': ' (Home)',
        'de': ' (Heimat)',
        'fr': ' (Résidence)',
        'it': ' (Casa)',
        'es': ' (Sede)',
        'pl': ' (Domowa)',
        'ro': ' (Acasă)',
        'ru': ' (Основной)',
        'tr': ' (Ana)',
        'el': ' (Έδρα)',
        'ar': ' (الرئيسية)',
        'tl': ' (Tahanan)',
        'zh': ' (主教区)',
        'ko': ' (본당)',
        'ja': ' (本部)',
        'pt': ' (Principal)'
      },
      'NO_SCHEDULED_MASSES': {
        'en': 'No scheduled Masses',
        'de': 'Keine geplanten Messen',
        'fr': 'Pas de messes programmées',
        'it': 'Nessuna messa programmata',
        'es': 'No hay misas programadas',
        'pl': 'Brak zaplanowanych mszy',
        'ro': 'Fără slujbe programate',
        'ru': 'Нет запланированных месс',
        'tr': 'Planlanmış ayin yok',
        'el': 'Δεν υπάρχουν προγραμματισμένες λειτουργίες',
        'ar': 'لا توجد قداسات مجدولة',
        'tl': 'Walang nakatakdang Misa',
        'zh': '没有已安排的弥撒',
        'ko': '예정된 미사 없음',
        'ja': '予定されたミサはありません',
        'pt': 'Sem Missas programadas'
      },
      'HOME_PARISH_OF': {
        'en': 'This parish is the home parish of',
        'de': 'Diese Gemeinde ist die Heimatgemeinde von',
        'fr': 'Cette paroisse est la paroisse principale de',
        'it': 'Questa parrocchia è la parrocchia principale di',
        'es': 'Esta parroquia es la sede principal de',
        'pl': 'Ta parafia jest parafią domową',
        'ro': 'Această parohie este parohia de bază a',
        'ru': 'Этот приход является основным приходом',
        'tr': 'Bu cemaat, şu kişinin ana cemaatidir:',
        'el': 'Αυτή η ενορία είναι η έδρα του',
        'ar': 'هذه الرعية هي الرعية الرئيسية لـ',
        'tl': 'Ang parokyang ito ay ang tahanan ng',
        'zh': '这个堂区是以下神父的主教区',
        'ko': '이 본당은 다음 사제의 주 본당입니다',
        'ja': 'この小教区は次の司祭の本拠地です',
        'pt': 'Esta paróquia é a paróquia principal de'
      },
      'SERVED_BY': {
        'en': 'This parish is served by',
        'de': 'Diese Gemeinde wird betreut von',
        'fr': 'Cette paroisse est desservie par',
        'it': 'Questa parrocchia è servita da',
        'es': 'Esta parroquia es atendida por',
        'pl': 'Ta parafia jest obsługiwana przez',
        'ro': 'Această parohie este deservită de',
        'ru': 'Этот приход обслуживается',
        'tr': 'Bu cemaat şu kişi tarafından hizmet verilmektedir:',
        'el': 'Αυτή η ενορία εξυπηρετείται από',
        'ar': 'تخدم هذه الرعية من قبل',
        'tl': 'Ang parokyang ito ay pinaglilingkuran ng',
        'zh': '这个堂区由以下神父服务',
        'ko': '이 본당은 다음 사제가 봉사합니다',
        'ja': 'この小教区は次の司祭によって奉仕されています',
        'pt': 'Esta paróquia é atendida por'
      },
      'YOUR_LOCATION': {
        'en': 'Your Location',
        'de': 'Ihr Standort',
        'fr': 'Votre Emplacement',
        'it': 'La tua posizione',
        'es': 'Tu ubicación',
        'pl': 'Twoja lokalizacja',
        'ro': 'Locația ta',
        'ru': 'Ваше местоположение',
        'tr': 'Konumunuz',
        'el': 'Η τοποθεσία σας',
        'ar': 'موقعك',
        'tl': 'Iyong Lokasyon',
        'zh': '您的位置',
        'ko': '당신의 위치',
        'ja': 'あなたの位置',
        'pt': 'Sua Localização'
      },
      'NEAREST_PRIEST': {
        'en': 'Nearest Priest',
        'de': 'Nächster Priester',
        'fr': 'Prêtre le plus proche',
        'it': 'Sacerdote più vicino',
        'es': 'Sacerdote más cercano',
        'pl': 'Najbliższy ksiądz',
        'ro': 'Cel mai apropiat preot',
        'ru': 'Ближайший священник',
        'tr': 'En yakın rahip',
        'el': 'Πλησιέστερος ιερέας',
        'ar': 'أقرب كاهن',
        'tl': 'Pinakamalapit na Pari',
        'zh': '最近的神父',
        'ko': '가장 가까운 사제',
        'ja': '最寄りの司祭',
        'pt': 'Padre Mais Próximo'
      },
      'NEAREST_PARISH': {
        'en': 'Nearest Parish',
        'de': 'Nächste Gemeinde',
        'fr': 'Paroisse la plus proche',
        'it': 'Parrocchia più vicina',
        'es': 'Parroquia más cercana',
        'pl': 'Najbliższa parafia',
        'ro': 'Cea mai apropiată parohie',
        'ru': 'Ближайший приход',
        'tr': 'En yakın cemaat',
        'el': 'Πλησιέστερη ενορία',
        'ar': 'أقرب رعية',
        'tl': 'Pinakamalapit na Parokya',
        'zh': '最近的堂区',
        'ko': '가장 가까운 본당',
        'ja': '最寄りの小教区',
        'pt': 'Paróquia Mais Próxima'
      },
      'GLOBE': {
        'en': 'Globe',
        'de': 'Globus',
        'fr': 'Globe',
        'it': 'Globo',
        'es': 'Globo',
        'pl': 'Globus',
        'ro': 'Glob',
        'ru': 'Глобус',
        'tr': 'Küre',
        'el': 'Υδρόγειος',
        'ar': 'كرة أرضية',
        'tl': 'Globo',
        'zh': '地球仪',
        'ko': '지구본',
        'ja': '地球儀',
        'pt': 'Globo'
      },
      'PRIESTS': {
        'en': 'Priests',
        'de': 'Priester',
        'fr': 'Prêtres',
        'it': 'Sacerdoti',
        'es': 'Sacerdotes',
        'pl': 'Księża',
        'ro': 'Preoți',
        'ru': 'Священники',
        'tr': 'Rahipler',
        'el': 'Ιερείς',
        'ar': 'كهنة',
        'tl': 'Mga Pari',
        'zh': '神父',
        'ko': '사제',
        'ja': '司祭',
        'pt': 'Padres'
      },
      'PARISHES': {
        'en': 'Parishes',
        'de': 'Gemeinden',
        'fr': 'Paroisses',
        'it': 'Parrocchie',
        'es': 'Parroquias',
        'pl': 'Parafie',
        'ro': 'Parohii',
        'ru': 'Приходы',
        'tr': 'Cemaatler',
        'el': 'Ενορίες',
        'ar': 'الرعايا',
        'tl': 'Mga Parokya',
        'zh': '堂区',
        'ko': '본당',
        'ja': '小教区',
        'pt': 'Paróquias'
      },
      'RESOURCES': {
        'en': 'Resources',
        'de': 'Ressourcen',
        'fr': 'Ressources',
        'it': 'Risorse',
        'es': 'Recursos',
        'pl': 'Zasoby',
        'ro': 'Resurse',
        'ru': 'Ресурсы',
        'tr': 'Kaynaklar',
        'el': 'Πόροι',
        'ar': 'موارد',
        'tl': 'Mga Mapagkukunan',
        'zh': '资源',
        'ko': '자원',
        'ja': 'リソース',
        'pt': 'Recursos'
      },
      'CONTACT': {
        'en': 'Contact',
        'de': 'Kontakt',
        'fr': 'Contact',
        'it': 'Contatto',
        'es': 'Contacto',
        'pl': 'Kontakt',
        'ro': 'Contact',
        'ru': 'Контакт',
        'tr': 'İletişim',
        'el': 'Επικοινωνία',
        'ar': 'اتصال',
        'tl': 'Kontak',
        'zh': '联系',
        'ko': '연락처',
        'ja': '連絡先',
        'pt': 'Contato'
      },
      'DATA_SOURCES': {
        'en': 'Data Sources',
        'de': 'Datenquellen',
        'fr': 'Sources de données',
        'it': 'Fonti dei dati',
        'es': 'Fuentes de datos',
        'pl': 'Źródła danych',
        'ro': 'Surse de date',
        'ru': 'Источники данных',
        'tr': 'Veri Kaynakları',
        'el': 'Πηγές δεδομένων',
        'ar': 'مصادر البيانات',
        'tl': 'Mga Pinagmulan ng Data',
        'zh': '数据来源',
        'ko': '데이터 출처',
        'ja': 'データソース',
        'pt': 'Fontes de Dados'
      },
      'NO_PRIESTS_FOUND': {
        'en': 'No priests found in your area',
        'de': 'Keine Priester in Ihrer Nähe gefunden',
        'fr': 'Aucun prêtre trouvé dans votre région',
        'it': 'Nessun sacerdote trovato nella tua zona',
        'es': 'No se encontraron sacerdotes en tu área',
        'pl': 'Nie znaleziono księży w twojej okolicy',
        'ro': 'Nu s-au găsit preoți în zona ta',
        'ru': 'Священники в вашем районе не найдены',
        'tr': 'Bölgenizde rahip bulunamadı',
        'el': 'Δεν βρέθηκαν ιερείς στην περιοχή σας',
        'ar': 'لم يتم العثور على كهنة في منطقتك',
        'tl': 'Walang nakitang mga pari sa iyong lugar',
        'zh': '您所在地区没有找到神父',
        'ko': '해당 지역에서 사제를 찾을 수 없습니다',
        'ja': 'お近くの司祭が見つかりません',
        'pt': 'Nenhum padre encontrado na sua área'
      },
      'NO_PARISHES_FOUND': {
        'en': 'No parishes found in your area',
        'de': 'Keine Gemeinden in Ihrer Nähe gefunden',
        'fr': 'Aucune paroisse trouvée dans votre région',
        'it': 'Nessuna parrocchia trovata nella tua zona',
        'es': 'No se encontraron parroquias en tu área',
        'pl': 'Nie znaleziono parafii w twojej okolicy',
        'ro': 'Nu s-au găsit parohii în zona ta',
        'ru': 'Приходы в вашем районе не найдены',
        'tr': 'Bölgenizde cemaat bulunamadı',
        'el': 'Δεν βρέθηκαν ενορίες στην περιοχή σας',
        'ar': 'لم يتم العثور على رعايا في منطقتك',
        'tl': 'Walang nakitang mga parokya sa iyong lugar',
        'zh': '您所在地区没有找到堂区',
        'ko': '해당 지역에서 본당을 찾을 수 없습니다',
        'ja': 'お近くの小教区が見つかりません',
        'pt': 'Nenhuma paróquia encontrada na sua área'
      },
      'TITLE_BISHOP': {
        'en': 'Bp.',
        'de': 'Bf.',
        'fr': 'Mgr.',
        'it': 'Mons.',
        'es': 'Mons.',
        'pl': 'Bp.',
        'ro': 'PS.',
        'ru': 'Еп.',
        'tr': 'Psks.',
        'el': 'Επ.',
        'ar': 'أسقف.',
        'tl': 'Ob.',
        'zh': '主教.',
        'ko': '주교.',
        'ja': '司教.',
        'pt': 'Dom.'
      },
      'TITLE_FATHER': {
        'en': 'Fr.',
        'de': 'P.',
        'fr': 'P.',
        'it': 'P.',
        'es': 'P.',
        'pl': 'Ks.',
        'ro': 'Pr.',
        'ru': 'о.',
        'tr': 'Pdr.',
        'el': 'π.',
        'ar': 'أب.',
        'tl': 'P.',
        'zh': '神父.',
        'ko': '신부.',
        'ja': '神父.',
        'pt': 'Pe.'
      },
      'TITLE_SISTER': {
        'en': 'Sr.',
        'de': 'Schw.',
        'fr': 'Sr.',
        'it': 'Suor.',
        'es': 'Hna.',
        'pl': 'S.',
        'ro': 'S.',
        'ru': 'с.',
        'tr': 'Rah.',
        'el': 'Αδ.',
        'ar': 'أخت.',
        'tl': 'Sor.',
        'zh': '修女.',
        'ko': '수녀.',
        'ja': 'シスター.',
        'pt': 'Ir.'
      },
      'TITLE_MOTHER': {
        'en': 'M.',
        'de': 'M.',
        'fr': 'M.',
        'it': 'M.',
        'es': 'M.',
        'pl': 'M.',
        'ro': 'M.',
        'ru': 'м.',
        'tr': 'Anne.',
        'el': 'Μ.',
        'ar': 'أم.',
        'tl': 'Ina.',
        'zh': '院长.',
        'ko': '원장.',
        'ja': 'マザー.',
        'pt': 'Me.'
      },
      'TITLE_BROTHER': {
        'en': 'Br.',
        'de': 'Br.',
        'fr': 'Fr.',
        'it': 'Fr.',
        'es': 'Hno.',
        'pl': 'Br.',
        'ro': 'Fr.',
        'ru': 'бр.',
        'tr': 'Bir.',
        'el': 'Αδ.',
        'ar': 'أخ.',
        'tl': 'Bro.',
        'zh': '修士.',
        'ko': '수사.',
        'ja': 'ブラザー.',
        'pt': 'Ir.'
      },
      'WEBSITE': {
        'en': 'Website',
        'de': 'Webseite',
        'fr': 'Site web',
        'it': 'Sito web',
        'es': 'Sitio web',
        'pl': 'Strona internetowa',
        'ro': 'Site web',
        'ru': 'Веб-сайт',
        'tr': 'Web sitesi',
        'el': 'Ιστοσελίδα',
        'ar': 'موقع الكتروني',
        'tl': 'Website',
        'zh': '网站',
        'ko': '웹사이트',
        'ja': 'ウェブサイト',
        'pt': 'Site'
      },
      'CONTACT': {
        'en': 'Contact',
        'de': 'Kontakt',
        'fr': 'Contact',
        'it': 'Contatto',
        'es': 'Contacto',
        'pl': 'Kontakt',
        'ro': 'Contact',
        'ru': 'Контакт',
        'tr': 'İletişim',
        'el': 'Επικοινωνία',
        'ar': 'اتصال',
        'tl': 'Kontak',
        'zh': '联系方式',
        'ko': '연락처',
        'ja': '連絡先',
        'pt': 'Contato'
      },
      'BORN': {
        'en': 'Born',
        'de': 'Geboren',
        'fr': 'Né en',
        'it': 'Nato nel',
        'es': 'Nacido en',
        'pl': 'Urodzony',
        'ro': 'Născut în',
        'ru': 'Родился в',
        'tr': 'Doğum',
        'el': 'Γεννήθηκε',
        'ar': 'ولد في',
        'tl': 'Ipinanganak',
        'zh': '出生于',
        'ko': '출생',
        'ja': '生まれ',
        'pt': 'Nascido em'
      },
      'ORDAINED_PRIEST_IN': {
        'en': 'Ordained priest in',
        'de': 'Zum Priester geweiht in',
        'fr': 'Ordonné prêtre en',
        'it': 'Ordinato sacerdote in',
        'es': 'Ordenado sacerdote en',
        'pl': 'Wyświęcony na kapłana w',
        'ro': 'Hirotonit preot în',
        'ru': 'Рукоположен в священники в',
        'tr': 'Rahip olarak atandı',
        'el': 'Χειροτονήθηκε ιερέας σε',
        'ar': 'رُسم كاهناً في',
        'tl': 'Inordenan bilang pari sa',
        'zh': '司铎任职于',
        'ko': '사제서품',
        'ja': '司祭叙階',
        'pt': 'Ordenado padre em'
      },
      'BY': {
        'en': 'by',
        'de': 'durch',
        'fr': 'par',
        'it': 'da',
        'es': 'por',
        'pl': 'przez',
        'ro': 'de',
        'ru': 'от',
        'tr': 'tarafından',
        'el': 'από',
        'ar': 'على يد',
        'tl': 'ni',
        'zh': '由',
        'ko': '에 의해',
        'ja': 'によって',
        'pt': 'por'
      },
      'CONSECRATED_BISHOP_IN': {
        'en': 'Consecrated Bishop in',
        'de': 'Zum Bischof geweiht in',
        'fr': 'Consacré Évêque en',
        'it': 'Consacrato Vescovo in',
        'es': 'Consagrado Obispo en',
        'pl': 'Konsekrowany na Biskupa w',
        'ro': 'Consacrat Episcop în',
        'ru': 'Посвящен в епископы в',
        'tr': 'Piskopos olarak kutsandı',
        'el': 'Χειροτονήθηκε Επίσκοπος σε',
        'ar': 'كُرّس أسقفاً في',
        'tl': 'Itinalaga bilang Obispo sa',
        'zh': '主教祝圣于',
        'ko': '주교 서임',
        'ja': '司教叙階',
        'pt': 'Consagrado Bispo em'
      },
      'BISHOP_LINE': {
        'en': 'Bishop line',
        'de': 'Bischofslinie',
        'fr': 'Lignée épiscopale',
        'it': 'Linea episcopale',
        'es': 'Línea episcopal',
        'pl': 'Linia biskupia',
        'ro': 'Linia episcopală',
        'ru': 'Епископская линия',
        'tr': 'Piskopos hattı',
        'el': 'Επισκοπική γραμμή',
        'ar': 'سلسلة الأساقفة',
        'tl': 'Linya ng Obispo',
        'zh': '主教传承',
        'ko': '주교 계보',
        'ja': '司教系譜',
        'pt': 'Linhagem episcopal'
      },
      'OPERATES_IN': {
        'en': 'Operates in',
        'de': 'Tätig in',
        'fr': 'Opère en',
        'it': 'Opera in',
        'es': 'Opera en',
        'pl': 'Działa w',
        'ro': 'Operează în',
        'ru': 'Служит в',
        'tr': 'Hizmet bölgesi',
        'el': 'Λειτουργεί σε',
        'ar': 'يعمل في',
        'tl': 'Naglilingkod sa',
        'zh': '服务于',
        'ko': '활동 지역',
        'ja': '活動地域',
        'pt': 'Atua em'
      },
      'ASSOCIATES_WITH': {
        'en': 'associates with',
        'de': 'verbunden mit',
        'fr': 'associé à',
        'it': 'associato a',
        'es': 'asociado con',
        'pl': 'stowarzyszony z',
        'ro': 'asociat cu',
        'ru': 'связан с',
        'tr': 'ile ilişkili',
        'el': 'συνδέεται με',
        'ar': 'متحالف مع',
        'tl': 'kaakibat ng',
        'zh': '隶属于',
        'ko': '관련 단체',
        'ja': '所属',
        'pt': 'associado com'
      },
      'HOLDS_BELIEFS': {
        'en': 'holds',
        'de': 'vertritt',
        'fr': 'défend des croyances',
        'it': 'sostiene credenze',
        'es': 'mantiene creencias',
        'pl': 'wyznaje',
        'ro': 'susține credințe',
        'ru': 'придерживается взглядов',
        'tr': 'inançları',
        'el': 'υποστηρίζει',
        'ar': 'يتبنى معتقدات',
        'tl': 'may paniniwala',
        'zh': '持有信仰',
        'ko': '신념',
        'ja': '信条',
        'pt': 'mantém crenças'
      },
      'BELIEFS': {
        'en': 'beliefs',
        'de': 'Überzeugungen',
        'fr': 'de',
        'it': 'di',
        'es': 'de',
        'pl': 'poglądy',
        'ro': 'de',
        'ru': 'типа',
        'tr': 'var',
        'el': 'πεποιθήσεις',
        'ar': 'من نوع',
        'tl': 'na',
        'zh': '为',
        'ko': '을 가짐',
        'ja': 'の',
        'pt': 'de'
      },
      'PARISHES_SERVED': {
        'en': 'Parishes Served',
        'de': 'Betreute Gemeinden',
        'fr': 'Paroisses Desservies',
        'it': 'Parrocchie Servite',
        'es': 'Parroquias Atendidas',
        'pl': 'Obsługiwane Parafie',
        'ro': 'Parohii Deservite',
        'ru': 'Обслуживаемые Приходы',
        'tr': 'Hizmet Verilen Cemaatler',
        'el': 'Ενορίες Εξυπηρέτησης',
        'ar': 'الرعايا المخدومة',
        'tl': 'Mga Parokyang Pinaglilingkuran',
        'zh': '服务堂区',
        'ko': '담당 본당',
        'ja': '奉仕小教区',
        'pt': 'Paróquias Atendidas'
      }
    };

    // Track the current language
    let currentLanguage = 'en';

    // Detect user's preferred language
    function detectUserLanguage() {
      const browserLangs = getBrowserLanguages();
      
      if (browserLangs.some(lang => lang.toLowerCase() === 'pt-br')) {
        console.log("Detected Brazilian Portuguese (pt-BR)");
        return 'pt';
      }

      // Check if any of the browser's languages match our supported languages
      for (const lang of browserLangs) {
        const langCode = getLanguageCode(lang);
        if (LANGUAGES[langCode]) {
          return langCode;
        }
      }
      
      // Default to English if no match
      return 'en';
    }

    // Get translated text
    function getTranslatedText(key, fallbackLanguage = 'en') {
      if (TRANSLATIONS[key] && TRANSLATIONS[key][currentLanguage]) {
        return TRANSLATIONS[key][currentLanguage];
      }
      
      // Fallback to English if translation not available
      if (TRANSLATIONS[key] && TRANSLATIONS[key][fallbackLanguage]) {
        return TRANSLATIONS[key][fallbackLanguage];
      }
      
      // Return the key as a last resort
      return key;
    }

    function updateNavigationURLs() {
      // Get navigation configuration for current language
      const navConfig = NAV_CONFIG[currentLanguage] || NAV_CONFIG['en']; // Fallback to English
      
      if (!navConfig) return; // Safety check
      
      // Get all navigation links
      const navLinks = document.querySelectorAll('#sidebar .sidebar-links a');
      
      // Match links with configuration and update URLs
      navLinks.forEach(link => {
        const key = link.getAttribute('data-i18n');
        if (!key) return; // Skip if no key
        
        // Find matching nav config
        const navItem = navConfig.find(item => item.key === key);
        if (navItem) {
          link.href = navItem.url;
        }
      });
    }

    // Apply translations to the UI
    function applyTranslations() {
      // Set the document language for proper RTL display
      document.documentElement.lang = currentLanguage;
      
      // Update title
      document.title = getTranslatedText('CATHOLIC_RESISTANCE_GLOBE');
      
      // Update text elements with data-i18n attributes
      document.querySelectorAll('[data-i18n]').forEach(element => {
        const key = element.getAttribute('data-i18n');
        element.textContent = getTranslatedText(key);
      });
      
      // Update placeholder attributes
      document.querySelectorAll('[data-i18n-placeholder]').forEach(element => {
        const key = element.getAttribute('data-i18n-placeholder');
        element.placeholder = getTranslatedText(key);
      });
      
      // Special handling for RTL languages
      if (currentLanguage === 'ar' || currentLanguage === 'he') {
        document.body.classList.add('rtl');
      } else {
        document.body.classList.remove('rtl');
      }
      
      updateNavigationURLs();

      resetSearchResultsContainer();

      // Update language selector
      const languageSelect = document.getElementById('language-select');
      if (languageSelect) {
        const options = languageSelect.querySelectorAll('option');
        options.forEach(option => {
          if (option.value === currentLanguage) {
            option.selected = true;
          }
        });
      }
    }

    // Initialize language settings
    function initLanguage() {
      // Check if user has a saved preference
      const savedLanguage = localStorage.getItem('preferredLanguage');
      
      if (savedLanguage && LANGUAGES[savedLanguage]) {
        currentLanguage = savedLanguage;
      } else {
        // Detect language from browser
        currentLanguage = detectUserLanguage();
        localStorage.setItem('preferredLanguage', currentLanguage);
      }
      
      // Apply translations
      applyTranslations();
      
      // Set up language selector change event
      const languageSelect = document.getElementById('language-select');
      if (languageSelect) {
        languageSelect.addEventListener('change', function() {
          currentLanguage = this.value;
          localStorage.setItem('preferredLanguage', currentLanguage);
          applyTranslations();
        });
      }
    }

    // Call this function when DOM is loaded
    document.addEventListener('DOMContentLoaded', initLanguage);

// First-time user tutorial system

// Check if this is the first visit
function checkFirstTimeUser() {
  // Check if this is the first visit
  const hasVisited = localStorage.getItem('hasVisitedClergyMap');
  
  if (!hasVisited) {
    // Set the flag to prevent showing the tutorial again
    localStorage.setItem('hasVisitedClergyMap', 'true');
    
    // Wait for the map to be fully loaded before showing tutorial
    window.addEventListener('cities-loaded', () => {
      // Start the tutorial
      showTutorial();
    });
  }
}

// Show tutorial
function showTutorial() {
  console.log('Starting first-time user tutorial');
  
  // Show the first step after a delay
  setTimeout(() => {
    showTutorialStep(1);
  }, 2000);
}

// Show tutorial steps
function showTutorialStep(step) {
  // Clear any existing tutorial labels
  const existingLabels = document.querySelectorAll('.tutorial-label');
  existingLabels.forEach(label => label.remove());
  
  // Create label element
  const label = document.createElement('div');
  label.className = 'tutorial-label';
  document.body.appendChild(label);
  
  let target, text;
  
  switch (step) {
    case 1:
      // Show user location label
      target = scene.getObjectByName('user-location');
      text = getTranslatedText('YOUR_LOCATION');
      break;
      
    case 2:
      // Find nearest priest and show label
      const nearestPriest = findNearestPriest();
      target = nearestPriest ? scene.getObjectByName(nearestPriest.markerName) : null;
      text = nearestPriest ? 
          `${getTranslatedText('NEAREST_PRIEST')}: ${nearestPriest.name}` : 
          getTranslatedText('NO_PRIESTS_FOUND');
      break;
      
    case 3:
      // Find nearest parish and show label
      const nearestParish = findNearestParish();
      target = nearestParish ? scene.getObjectByName(nearestParish.markerName) : null;
      text = nearestParish ? 
          `${getTranslatedText('NEAREST_PARISH')}: ${nearestParish.name}` : 
          getTranslatedText('NO_PARISHES_FOUND');
      break;
      
    default:
      // End tutorial
      return;
  }
  
  if (target) {
    // Position label near the target
    positionLabelAtObject(label, target, text);
    
    // Move to next step after delay
    setTimeout(() => {
      showTutorialStep(step + 1);
    }, 4000);
  } else {
    // Skip to next step if target not found
    setTimeout(() => {
      showTutorialStep(step + 1);
    }, 1000);
  }
}

// Position label at 3D object
function positionLabelAtObject(label, object, text) {
  // Set label text
  label.textContent = text;
  
  // Function to update label position each frame
  function updatePosition() {
    // Convert 3D position to screen coordinates
    const vector = object.position.clone();
    vector.project(camera);
    
    const x = (vector.x * 0.5 + 0.5) * window.innerWidth;
    const y = (-(vector.y * 0.5) + 0.5) * window.innerHeight;
    
    // Only show label if object is in front of the camera (z < 1)
    if (vector.z < 1) {
      label.style.display = 'block';
      label.style.transform = `translate(-50%, -100%) translate(${x}px, ${y - 20}px)`;
    } else {
      label.style.display = 'none';
    }
    
    // Continue updating until label is removed
    if (document.body.contains(label)) {
      requestAnimationFrame(updatePosition);
    }
  }
  
  // Start updating
  updatePosition();
}

// Find nearest priest to user location
function findNearestPriest() {
  const userLocation = scene.getObjectByName('user-location');
  if (!userLocation) return null;
  
  let nearestPriest = null;
  let minDistance = Infinity;
  
  // Search all priest markers
  scene.children
    .filter(obj => obj.name === 'priest-marker')
    .forEach(marker => {
      const distance = userLocation.position.distanceTo(marker.position);
      if (distance < minDistance) {
        minDistance = distance;
        nearestPriest = {
          markerName: marker.name,
          name: marker.priestData.Name,
          position: marker.position,
          data: marker.priestData
        };
      }
    });
  
  return nearestPriest;
}

// Find nearest parish (excluding home parishes)
function findNearestParish() {
  const userLocation = scene.getObjectByName('user-location');
  if (!userLocation) return null;
  
  let nearestParish = null;
  let minDistance = Infinity;
  
  // Search all parish markers (excluding home parishes)
  scene.children
    .filter(obj => obj.name === 'parish-marker' && obj.parishData && !obj.parishData.IsHomePriest)
    .forEach(marker => {
      const distance = userLocation.position.distanceTo(marker.position);
      if (distance < minDistance) {
        minDistance = distance;
        nearestParish = {
          markerName: marker.name,
          name: marker.parishData.ParishName,
          position: marker.position,
          data: marker.parishData
        };
      }
    });
  
  return nearestParish;
}

// Enhanced priest marker creation with better shading
function createEnhancedPriestMarker(lat, lng, priest) {
  // Create marker geometry with higher detail for better shading
  const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 32, 32);
  
  // Create shiny material for the marker
  const markerMaterial = new THREE.MeshPhongMaterial({ 
    color: CONFIG.markerColor,
    shininess: 80,
    specular: 0x881111, // Adding a reddish specular highlight
    emissive: 0x330000,
    emissiveIntensity: 0.2
  });
  
  const marker = new THREE.Mesh(markerGeometry, markerMaterial);
  
  // Set marker position
  const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
  marker.position.set(position.x, position.y, position.z);
  marker.name = 'priest-marker';
  marker.priestData = priest;
  
  return marker;
}

// Enhanced parish marker creation with better shading
function createEnhancedParishMarker(lat, lng, parish) {
  // Create marker geometry with higher detail for better shading
  const markerGeometry = new THREE.SphereGeometry(CONFIG.parishMarkerSize, 32, 32);
  
  // Create shiny material for the marker
  const markerMaterial = new THREE.MeshPhongMaterial({ 
    color: CONFIG.parishMarkerColor,
    shininess: 80,
    specular: 0x881111, // Adding a reddish specular highlight
    emissive: 0x330000,
    emissiveIntensity: 0.1
  });
  
  const marker = new THREE.Mesh(markerGeometry, markerMaterial);
  
  // Set marker position
  const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
  marker.position.set(position.x, position.y, position.z);
  marker.name = 'parish-marker';
  marker.parishData = parish;
  
  return marker;
}

// Replace the original marker creation with enhanced versions
// This function should be called during initialization
function enhanceExistingMarkers() {
  // Replace existing priest markers
  scene.children
    .filter(obj => obj.name === 'priest-marker')
    .forEach(marker => {
      const priestData = marker.priestData;
      const position = marker.position.clone();
      
      // Calculate lat/lng from position
      const lat = priestData.Latitude;
      const lng = priestData.Longitude;
      
      // Remove old marker
      scene.remove(marker);
      
      // Create enhanced marker
      const enhancedMarker = createEnhancedPriestMarker(lat, lng, priestData);
      scene.add(enhancedMarker);
    });
  
  // Replace existing parish markers
  scene.children
    .filter(obj => obj.name === 'parish-marker')
    .forEach(marker => {
      const parishData = marker.parishData;
      const position = marker.position.clone();
      
      // Calculate lat/lng from position
      const lat = parishData.Latitude;
      const lng = parishData.Longitude;
      
      // Remove old marker
      scene.remove(marker);
      
      // Create enhanced marker
      const enhancedMarker = createEnhancedParishMarker(lat, lng, parishData);
      scene.add(enhancedMarker);
    });
}

// Override the populateGlobeWithMarkers function to use enhanced markers
function populateGlobeWithMarkers(data) {
  if (!globe) return;
  
  // Clear any existing markers
  const existingMarkers = scene.children.filter(obj => 
    obj.name === 'priest-marker' || obj.name === 'priest-pulse' || obj.name === 'priest-marker-invisible'
  );
  existingMarkers.forEach(marker => scene.remove(marker));
  
  // Clear pulse meshes array
  pulseMeshes = [];
  
  // Create markers for each priest
  data.forEach(priest => {
    // Get coordinates
    const lat = priest.Latitude;
    const lng = priest.Longitude;
    
    // Create enhanced marker
    const marker = createEnhancedPriestMarker(lat, lng, priest);
    
    // Add to scene
    scene.add(marker);
    
    // Create pulsing ring effect
    const pulse = createPulseEffect(lat, lng, priest);
    scene.add(pulse);
    
    // Add invisible larger detection sphere for better interaction
    const invisibleSphere = createInvisibleSphere(lat, lng, priest);
    scene.add(invisibleSphere);
  });
}

// Create pulsing effect for markers
function createPulseEffect(lat, lng, priest) {
  // Create a group for the pulse effect
  const pulse = new THREE.Group();
  pulse.name = 'priest-pulse';
  pulse.priestData = priest;
  
  // Set position
  const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
  pulse.position.set(position.x, position.y, position.z);
  
  // Create squished sphere for the pulse effect
  const pulseGeometry = new THREE.SphereGeometry(CONFIG.markerRingSize, 32, 32);
  const pulseMaterial = new THREE.MeshBasicMaterial({
    color: CONFIG.markerPulseColor,
    transparent: true,
    opacity: 0.9,
    side: THREE.DoubleSide
  });
  
  const pulseMesh = new THREE.Mesh(pulseGeometry, pulseMaterial);
  // Make it a squished sphere by scaling down the y-axis
  pulseMesh.scale.y = 0.25; // Adjust this value to control how squished it is
  
  // Add random offset for animation
  pulseMesh.pulseOffset = Math.random() * Math.PI * 2;
  
  // Add to pulse group
  pulse.add(pulseMesh);
  
  // Add to pulse meshes array for animation
  pulseMeshes.push(pulseMesh);
  
  // Orient pulse toward center
  pulse.lookAt(0, 0, 0);
  
  return pulse;
}

// Create invisible sphere for better interaction
function createInvisibleSphere(lat, lng, priest) {
  // Create geometry for invisible detection sphere
  const invisibleSphereGeometry = new THREE.SphereGeometry(CONFIG.markerRingSize * 1.5, 16, 16);
  const invisibleSphereMaterial = new THREE.MeshBasicMaterial({
    transparent: true,
    opacity: 0.0,
  });
  
  const invisibleSphere = new THREE.Mesh(invisibleSphereGeometry, invisibleSphereMaterial);
  
  // Set position
  const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
  invisibleSphere.position.set(position.x, position.y, position.z);
  invisibleSphere.name = 'priest-marker-invisible';
  invisibleSphere.priestData = priest;
  
  return invisibleSphere;
}

    // Global variables
    let renderer, scene, camera, controls, globe;
    let priestMap = new Map(); // Map priestID to priest object
    let selectedPoint = null;
    let isGlobeReady = false;
    let raycaster, mouse;
    let dayNightMaterial;
    let currentTheme = getTheme();
    let pulseMeshes = [];
    let searchResults = [];
    let selectedSearchIndex = -1;
    let enhancedEarth = null;
    let parishes = [];

    function isMobile() {
      // Check for touch capability
      if ('ontouchstart' in window || navigator.maxTouchPoints > 0)
        return true;
      
      // Check screen width
      if (window.innerWidth <= 768)
        return true;
      
      // Check user agent as fallback
      const ua = navigator.userAgent.toLowerCase();
      return /android|webos|iphone|ipad|ipod|blackberry|windows phone/i.test(ua);
    };

    // Language mapping and geography functions
    const languageLatitudeMap = {
      // Top languages by number of speakers + European languages + CJK + Filipino
      "zh": 35.0, // Chinese (Mandarin)
      "es": 40.0, // Spanish - Spain (will adjust based on longitude)
      "en": 51.0, // English - UK (will adjust based on longitude)
      "hi": 20.0, // Hindi - Northern India
      "ar": 25.0, // Arabic - Arabian Peninsula
      "pt": -10.0, // Portuguese - Brazil (will adjust based on longitude)
      "bn": 23.0, // Bengali - Bangladesh/East India
      "ru": 55.0, // Russian
      "ja": 36.0, // Japanese
      "pa": 30.0, // Punjabi
      "de": 51.0, // German
      "jv": -7.5, // Javanese
      "ko": 37.5, // Korean
      "fr": 46.0, // French (will adjust based on longitude)
      "te": 16.0, // Telugu
      "mr": 18.0, // Marathi
      "tr": 39.0, // Turkish
      "ta": 11.0, // Tamil
      "vi": 16.0, // Vietnamese
      "ur": 30.0, // Urdu
      "it": 42.0, // Italian
      "th": 15.0, // Thai
      "gu": 22.0, // Gujarati
      "pl": 52.0, // Polish
      "uk": 49.0, // Ukrainian
      "fa": 32.0, // Persian
      "ro": 46.0, // Romanian
      "nl": 52.0, // Dutch
      "fil": 14.0, // Filipino
      "sv": 60.0, // Swedish
      "cs": 50.0, // Czech
      "hu": 47.0, // Hungarian
      "el": 38.0, // Greek
      "da": 56.0, // Danish
      "fi": 62.0, // Finnish
      "no": 60.0, // Norwegian
      "bg": 42.0, // Bulgarian
      "hr": 45.0, // Croatian
      "sk": 48.0, // Slovak
      "sr": 44.0, // Serbian
      "lt": 55.0, // Lithuanian
      "lv": 57.0, // Latvian
      "et": 59.0, // Estonian
      "sl": 46.0, // Slovenian
      "is": 65.0, // Icelandic
      "ca": 41.0, // Catalan
      "eu": 43.0, // Basque
      "ga": 53.0, // Irish
      "gl": 42.0, // Galician
      "cy": 52.0, // Welsh
      "gd": 57.0, // Scottish Gaelic
      "be": 53.0, // Belarusian
      "mk": 41.5, // Macedonian
      "sq": 41.0, // Albanian
      "mt": 35.9, // Maltese
      "id": -0.8, // Indonesian
      "ms": 2.5,  // Malay
      "sw": -6.0, // Swahili
      "am": 9.0,  // Amharic
      "yo": 7.5,  // Yoruba
      "zu": -29.0, // Zulu
      "xh": -33.0, // Xhosa
      "he": 31.0, // Hebrew
      "tl": 14.6,  // Tagalog
      "pt": -15.0, // Updated specifically for Brazil (more central)
      "pt-BR": -15.0 // Explicitly add pt-BR code
    };

    function languageLongitudeRanges() {
      return {
        "en": [
          { min: -170, max: -30, lat: 40.0 },    // North America
          { min: -10, max: 2, lat: 51.0 },       // UK (narrower range)
          { min: 65, max: 90, lat: 20.0 },       // South Asia (India)
          { min: 110, max: 155, lat: -25.0 }     // Australia/NZ
        ],
        "de": [
          { min: 5, max: 15, lat: 51.0 }         // Germany
        ],
        "ru": [
          { min: 20, max: 180, lat: 55.0 }       // Russia
        ],
        "es": [
          { min: -120, max: -30, lat: 15.0 },    // Latin America
          { min: -10, max: 5, lat: 40.0 }        // Spain
        ],
        "pt": [
          { min: -70, max: -35, lat: -10.0 },    // Brazil
          { min: -10, max: 0, lat: 39.0 }        // Portugal
        ],
        "fr": [
          { min: -80, max: -60, lat: 45.0 },     // Quebec/Canada
          { min: -5, max: 8, lat: 46.0 },        // France
          { min: 0, max: 20, lat: 14.0 }         // Francophone Africa
        ],
        "ar": [
          { min: -10, max: 0, lat: 30.0 },       // North Africa
          { min: 25, max: 60, lat: 25.0 }        // Middle East
        ],
        "zh": [
          { min: 70, max: 135, lat: 35.0 }       // China
        ],
        "hi": [
          { min: 70, max: 90, lat: 20.0 }        // India
        ],
        "ja": [
          { min: 125, max: 150, lat: 36.0 }      // Japan
        ],
        "ko": [
          { min: 125, max: 130, lat: 37.5 }      // Korea
        ],
        "it": [
          { min: 7, max: 18, lat: 42.0 }         // Italy
        ],
        "pl": [
          { min: 14, max: 24, lat: 52.0 }        // Poland
        ],
        "pt": [
          { min: -75, max: -30, lat: -15.0 },    // Brazil (wider range)
          { min: -10, max: 0, lat: 39.0 }        // Portugal
        ],
        "pt-BR": [
          { min: -75, max: -30, lat: -15.0 }     // Brazil specific entry
        ],
      };
    }

    // Language-based latitude estimation with geographical consistency check
    function estimateLatitude(longitude) {
      const languages = getBrowserLanguages();
      const llr = languageLongitudeRanges();
        
        // 1. First try non-English languages for geographical consistency
        const nonEnglishLangs = languages.filter(lang => !getLanguageCode(lang).startsWith('en'));
        
        // Try non-English languages first
        for (const language of nonEnglishLangs) {
          const langCode = getLanguageCode(language);
          
          // Check if this language has specific longitude ranges defined
          if (llr[langCode]) {
            for (const range of llr[langCode]) {
              // Check if the detected longitude falls within this language's expected range
              if (longitude >= range.min && longitude <= range.max) {
                console.log(`Found matching non-English language ${langCode} for longitude ${longitude}, using latitude ${range.lat}`);
                return range.lat;
              }
            }
          }
        }
        
        // 2. If no non-English match, try all languages
        for (const language of languages) {
          const langCode = getLanguageCode(language);
          
          if (llr[langCode]) {
            for (const range of llr[langCode]) {
              if (longitude >= range.min && longitude <= range.max) {
                console.log(`Found matching language ${langCode} for longitude ${longitude}, using latitude ${range.lat}`);
                return range.lat;
              }
            }
          }
        }
        
        // 3. If no geographically consistent language found, try the general language map
        // Prioritize non-English languages first
        for (const language of nonEnglishLangs) {
          const langCode = getLanguageCode(language);
          if (languageLatitudeMap[langCode]) {
            return languageLatitudeMap[langCode];
          }
        }
      
      // Then try any language
      for (const language of languages) {
        const langCode = getLanguageCode(language);
        if (languageLatitudeMap[langCode]) {
          return languageLatitudeMap[langCode];
        }
      }
      
      // 4. Regional longitude-based fallback
      if (longitude > 10 && longitude < 40) {
        // Eastern Europe
        return 50.0;
      } else if (longitude >= 40 && longitude < 60) {
        // Western Russia
        return 55.0;
      } else if (longitude >= 60 && longitude < 90) {
        // Central Asia
        return 45.0;
      } else if (longitude >= 90 && longitude < 120) {
        // East Asia
        return 35.0;
      } else if (longitude >= 120 && longitude < 150) {
        // Far East Asia
        return 35.0;
      } else if (longitude > -10 && longitude <= 10) {
        // Western Europe
        return 48.0;
      } else if (longitude > -30 && longitude <= -10) {
        // Atlantic/Western Europe
        return 45.0;
      } else if (longitude > -60 && longitude <= -30) {
        // Eastern Americas
        return 40.0;
      } else if (longitude > -120 && longitude <= -60) {
        // Americas
        return 35.0;
      } else if (longitude > -180 && longitude <= -120) {
        // Western Americas/Pacific
        return 45.0;
      } else if (longitude > 150 || longitude <= -150) {
        // Pacific region
        return 0.0;
      }
      
      // Final fallback - estimate hemisphere based on longitude
      return (longitude > -120 && longitude < -30) || (longitude > 100 && longitude < 180) ? -20.0 : 20.0;
    }

    // Get all browser languages
    function getBrowserLanguages() {
      const languages = [];
      
      if (navigator.languages && navigator.languages.length) {
        // Copy all languages
        for (let i = 0; i < navigator.languages.length; i++) {
          languages.push(navigator.languages[i]);
        }
        
        // Check specifically for pt-BR
        if (navigator.languages.some(lang => lang.toLowerCase() === 'pt-br')) {
          languages.unshift('pt-BR'); // Add at beginning for priority
        }
      } else {
        // Fallback to navigator.language
        const lang = navigator.language || navigator.userLanguage || 'en';
        languages.push(lang);
        
        // Special case for pt-BR
        if (lang.toLowerCase() === 'pt-br') {
          languages.unshift('pt-BR');
        }
      }
      
      return languages;
    }

    // Extract language code from full locale string
    function getLanguageCode(locale) { 
      const code = locale.split('-')[0].toLowerCase();
      
      // Special case for Brazilian Portuguese
      if (locale.toLowerCase() === 'pt-br') {
        return 'pt-BR';
      }
      
      return code;
    }

    function calculateLookAtTarget(distance) {
      // Calculate normalized zoom factor (0 = fully zoomed in, 1 = fully zoomed out)
      const zoomRange = CONFIG.maxDistance - CONFIG.minDistance;
      const zoomFactor = Math.min(1, Math.max(0, (distance - CONFIG.minDistance) / zoomRange));
      
      // Apply quadratic easing for smoother transition (use zoomFactor^2 for quadratic)
      const easedFactor = zoomFactor * zoomFactor;
      
      // Calculate y-offset based on zoom
      const yOffset = easedFactor * CONFIG.cameraYOffset;
      
      // Return lookAt target vector
      return new THREE.Vector3(0, -yOffset, 0); // Negative because we want to look down
    }

    function zoomIn() {
      console.log('Zoom in');
      
      // Get current camera distance
      const currentDistance = camera.position.distanceTo(controls.target);
      
      // Calculate new distance (closer)
      const newDistance = Math.max(CONFIG.minDistance, currentDistance * 0.8);
      
      // Create normalized direction vector from camera to target
      const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      
      // Set new camera position
      camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
      
      // Update controls and camera
      controls.update();
      
      // Update CONFIG.currentZoomLevel for future operations
      CONFIG.currentZoomLevel = newDistance;
      
      // Update the lookAt target
      const newTarget = calculateLookAtTarget(newDistance);
      controls.target.copy(newTarget);
      
      // Adjust rotation speed based on new zoom level
      adjustRotationSpeed();
    }

    function zoomOut() {
      console.log('Zoom out');
      
      // Get current camera distance
      const currentDistance = camera.position.distanceTo(controls.target);
      
      // Calculate new distance (farther)
      const newDistance = Math.min(CONFIG.maxDistance, currentDistance * 1.2);
      
      // Create normalized direction vector from camera to target
      const direction = new THREE.Vector3().subVectors(camera.position, controls.target).normalize();
      
      // Set new camera position
      camera.position.copy(controls.target).add(direction.multiplyScalar(newDistance));
      
      // Update controls and camera
      controls.update();
      
      // Update CONFIG.currentZoomLevel for future operations
      CONFIG.currentZoomLevel = newDistance;
      
      // Update the lookAt target
      const newTarget = calculateLookAtTarget(newDistance);
      controls.target.copy(newTarget);
      
      // Adjust rotation speed based on new zoom level
      adjustRotationSpeed();
    }

    // Load parishes data
    function loadParishesData() {
      if (CONFIG.parishesUrl) {
        fetch(CONFIG.parishesUrl)
          .then(response => response.text())
          .then(csvData => {
            parseParishesData(csvData);
            // Synchronize priest locations with home parishes
            synchronizePriestLocations();
            // Then populate the globe
            populateGlobeWithPriests();
          })
          .catch(error => {
            console.error('Error loading parishes data:', error);
            console.log('Falling back to default parishes data');
            parseParishesData(defaultParishCsvData);
            // Synchronize priest locations with home parishes
            synchronizePriestLocations();
            // Then populate the globe
            populateGlobeWithPriests();
          });
      } else {
        // Use default hardcoded data
        parseParishesData(defaultParishCsvData);
        // Synchronize priest locations with home parishes
        synchronizePriestLocations();
        // Then populate the globe
        populateGlobeWithPriests();
      }
    }

    // 7. Improved click detection to prevent clicking through the globe
    function isPointOnFrontSide(hitPoint, camera) {
      // Vector from camera to hit point
      const cameraToHit = new THREE.Vector3().subVectors(hitPoint, camera.position);
      
      // Vector from camera to globe center
      const cameraToCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), camera.position);
      
      // If dot product is positive, the hit is on back side
      return cameraToHit.dot(cameraToCenter) <= 0;
    }

    // Calculate solar position with accurate Earth tilt
    function calculateSolarPosition(dt) {
      // Day of year (0-365)
      const start = new Date(dt.getUTCFullYear(), 0, 0);
      const diff = dt - start;
      const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));
      
      // Convert to radians for the calculations
      const dayAngle = 2 * Math.PI * dayOfYear / 365.25;
      
      // Axial tilt calculation (more accurate declination angle)
      // Uses astronomical formula with the obliquity of the ecliptic
      const declination = 0.4093 * Math.sin(dayAngle - 1.405);
      
      // Equation of time (difference between solar time and mean time)
      const eqTime = 229.18 * (0.000075 + 0.001868 * Math.cos(dayAngle) 
                - 0.032077 * Math.sin(dayAngle) 
                - 0.014615 * Math.cos(2 * dayAngle) 
                - 0.040849 * Math.sin(2 * dayAngle));
      
      // Calculate solar hour angle
      const hour = dt.getUTCHours();
      const minutes = dt.getUTCMinutes();
      const seconds = dt.getUTCSeconds();
      const totalSeconds = hour * 3600 + minutes * 60 + seconds;
      
      // Convert to longitude (-180 to 180)
      const longitude = (totalSeconds / 86400) * 360 - 180;
      
      // Adjust for equation of time
      const adjustedLongitude = longitude + eqTime / 60 * 15;
      
      // Convert declination from radians to degrees
      const declinationDegrees = declination * (180 / Math.PI);
      
      return [adjustedLongitude, declinationDegrees];
    }

    // Add a blue marker for user location
    function addUserLocationMarker(lat, lng) {
      // Remove any existing user location marker
      const existingMarker = scene.getObjectByName('user-location');
      if (existingMarker) {
        scene.remove(existingMarker);
      }
      
      // Create blue marker geometry
      const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({ color: '#0066ff' });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      
      // Set marker position
      const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
      marker.position.set(position.x, position.y, position.z);
      marker.name = 'user-location';
      
      // Add to scene
      scene.add(marker);
    }

    function centerOnTimezone() {
  try {
    // Get the IANA timezone identifier
    const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
    console.log(`Detected timezone: ${timezone}`);
    
    // Get coordinates from timezone
    const coords = getTimezoneCoordinates(timezone);
    
    if (coords) {
      console.log(`Using timezone coordinates: ${coords.lat}, ${coords.lng} (${timezone})`);
      // Center globe on these coordinates
      focusOnPoint(coords.lat, coords.lng, CONFIG.currentZoomLevel);
      
      // Add a blue marker for user's timezone location
      addUserLocationMarker(coords.lat, coords.lng);
      return;
    }
  } catch (err) {
    console.warn("Error detecting timezone:", err);
  }
  
  // Fallback to original method if timezone detection fails
  fallbackTimezoneDetection();
}

function getTimezoneCoordinates(timezone) {
  const timezoneMap = {
    // Europe
    "Europe/Berlin": { lat: 52.5200, lng: 13.4050 },
    "Europe/London": { lat: 51.5074, lng: -0.1278 },
    "Europe/Paris": { lat: 48.8566, lng: 2.3522 },
    "Europe/Rome": { lat: 41.9028, lng: 12.4964 },
    "Europe/Madrid": { lat: 40.4168, lng: -3.7038 },
    "Europe/Moscow": { lat: 55.7558, lng: 37.6173 },
    "Europe/Kiev": { lat: 50.4501, lng: 30.5234 },
    "Europe/Warsaw": { lat: 52.2297, lng: 21.0122 },
    "Europe/Vienna": { lat: 48.2082, lng: 16.3738 },
    "Europe/Stockholm": { lat: 59.3293, lng: 18.0686 },
    "Europe/Athens": { lat: 37.9838, lng: 23.7275 },
    "Europe/Istanbul": { lat: 41.0082, lng: 28.9784 },
    "Europe/Amsterdam": { lat: 52.3676, lng: 4.9041 },
    "Europe/Brussels": { lat: 50.8503, lng: 4.3517 },
    "Europe/Prague": { lat: 50.0755, lng: 14.4378 },
    "Europe/Lisbon": { lat: 38.7223, lng: -9.1393 },
    "Europe/Dublin": { lat: 53.3498, lng: -6.2603 },
    "Europe/Budapest": { lat: 47.4979, lng: 19.0402 },
    "Europe/Copenhagen": { lat: 55.6761, lng: 12.5683 },
    "Europe/Oslo": { lat: 59.9139, lng: 10.7522 },
    "Europe/Helsinki": { lat: 60.1699, lng: 24.9384 },
    "Europe/Zurich": { lat: 47.3769, lng: 8.5417 },
    
    // North America
    "America/New_York": { lat: 40.7128, lng: -74.0060 },
    "America/Chicago": { lat: 41.8781, lng: -87.6298 },
    "America/Denver": { lat: 39.7392, lng: -104.9903 },
    "America/Los_Angeles": { lat: 34.0522, lng: -118.2437 },
    "America/Toronto": { lat: 43.6532, lng: -79.3832 },
    "America/Vancouver": { lat: 49.2827, lng: -123.1207 },
    "America/Mexico_City": { lat: 19.4326, lng: -99.1332 },
    
    // Asia
    "Asia/Tokyo": { lat: 35.6762, lng: 139.6503 },
    "Asia/Shanghai": { lat: 31.2304, lng: 121.4737 },
    "Asia/Hong_Kong": { lat: 22.3193, lng: 114.1694 },
    "Asia/Singapore": { lat: 1.3521, lng: 103.8198 },
    "Asia/Seoul": { lat: 37.5665, lng: 126.9780 },
    "Asia/Dubai": { lat: 25.2048, lng: 55.2708 },
    "Asia/Kolkata": { lat: 28.6139, lng: 77.2090 },
    "Asia/Bangkok": { lat: 13.7563, lng: 100.5018 },
    "Asia/Jakarta": { lat: -6.2088, lng: 106.8456 },
    "Asia/Manila": { lat: 14.5995, lng: 120.9842 },
    "Asia/Taipei": { lat: 25.0330, lng: 121.5654 },
    "Asia/Jerusalem": { lat: 31.7683, lng: 35.2137 },
    
    // Australia and Oceania
    "Australia/Sydney": { lat: -33.8688, lng: 151.2093 },
    "Australia/Melbourne": { lat: -37.8136, lng: 144.9631 },
    "Australia/Brisbane": { lat: -27.4698, lng: 153.0251 },
    "Australia/Perth": { lat: -31.9505, lng: 115.8605 },
    "Pacific/Auckland": { lat: -36.8485, lng: 174.7633 },
    
    // South America
    "America/Sao_Paulo": { lat: -23.5505, lng: -46.6333 },
    "America/Buenos_Aires": { lat: -34.6037, lng: -58.3816 },
    "America/Santiago": { lat: -33.4489, lng: -70.6693 },
    "America/Lima": { lat: -12.0464, lng: -77.0428 },
    "America/Bogota": { lat: 4.7110, lng: -74.0721 },
    
    // Africa
    "Africa/Cairo": { lat: 30.0444, lng: 31.2357 },
    "Africa/Johannesburg": { lat: -26.2041, lng: 28.0473 },
    "Africa/Lagos": { lat: 6.5244, lng: 3.3792 },
    "Africa/Nairobi": { lat: -1.2921, lng: 36.8219 },
    "Africa/Casablanca": { lat: 33.5731, lng: -7.5898 }
  };
  
  // Try exact match
  if (timezoneMap[timezone]) {
    return timezoneMap[timezone];
  }
  
  // If exact match not found, try to find a city in the same region
  // Extract the region part (e.g., "Europe" from "Europe/Berlin")
  const region = timezone.split('/')[0];
  
  // Find any timezone in the same region
  for (const [tz, coords] of Object.entries(timezoneMap)) {
    if (tz.startsWith(region + '/')) {
      console.log(`No exact match for ${timezone}, using ${tz} as approximate match`);
      return coords;
    }
  }
  
  // No match found
  return null;
}

    function fallbackTimezoneDetection() {
      // Get local timezone offset in minutes
      const timezoneOffsetMinutes = new Date().getTimezoneOffset();
      
      console.log("timezoneOffsetMinutes " + timezoneOffsetMinutes);

      // Convert to hours (negative because getTimezoneOffset returns difference from UTC)
      const timezoneOffsetHours = -timezoneOffsetMinutes / 60;
      
      // Calculate approximate longitude (15 degrees per hour)
      const approximateLongitude = timezoneOffsetHours * 15;
      
      // Get browser languages and estimate latitude based on geographical consistency
      const estimatedLatitude = estimateLatitude(approximateLongitude);
      
      console.log(`Browser languages: ${getBrowserLanguages().join(', ')}, approximate longitude: ${approximateLongitude}, estimated latitude: ${estimatedLatitude}`);
      
      // Center globe on this position
      focusOnPoint(estimatedLatitude, approximateLongitude, CONFIG.currentZoomLevel);
    }

    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          // Success callback
          (position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;
            
            // Add a blue marker for user location
            addUserLocationMarker(userLat, userLng);
            
            // Center globe on user location
            focusOnPoint(userLat, userLng, config.currentZoomLevel);
          },
          // Error callback
          (error) => {
            console.log('Geolocation error:', error);
            // Center on timezone if location isn't available
            centerOnTimezone();
          }
        );
      } else {
        // Geolocation not supported
        console.log('Geolocation not supported by this browser');
        centerOnTimezone();
      }
    }

    // Adjust rotation speed based on zoom level - slower when zoomed in
    function adjustRotationSpeed() {
      const distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
      const zoomRange = CONFIG.maxDistance - CONFIG.minDistance;
      const zoomFactor = (distance - CONFIG.minDistance) / zoomRange;
      
      const minSpeed = 0.2; // Min rotation speed when fully zoomed in
      const maxSpeed = 1.0; // Max rotation speed when zoomed out
      
      controls.rotateSpeed = minSpeed + zoomFactor * (maxSpeed - minSpeed);
    }

    async function initEnhancedGlobe() {
      // Create new Earth object
      enhancedEarth = new EnhancedEarth(scene, camera);
      
      // Set cloud options from CONFIG
      enhancedEarth.options.cloudOpacity = CONFIG.cloudOpacity;
      enhancedEarth.options.cloudBrightness = CONFIG.cloudBrightness;
      
      await enhancedEarth.init();
      
      // Set the globe reference to the earth mesh for compatibility
      globe = enhancedEarth.getEarthMesh();
      isGlobeReady = true;
      
      // Load priests data
      loadPriestsData();
      
      // Initial solar position
      const dt = new Date();
      const [longitude, declination] = calculateSolarPosition(dt);
      enhancedEarth.updateSunDirection(longitude, declination);
      
      // Center globe based on user location/timezone
      centerOnTimezone();
      
      // Update solar position periodically
      setInterval(() => {
        const dt = new Date();
        const [longitude, declination] = calculateSolarPosition(dt);
        enhancedEarth.updateSunDirection(longitude, declination);
      }, 60000); // Update every minute
    }

    // Main initialization function
    function init() {

      initLanguage();

      resetSearchResultsContainer();

      // Initialize Three.js scene
      initScene();
      
      // Initialize raycaster for interactions
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // Initialize enhanced globe
      initEnhancedGlobe();
      
      // Set up event listeners
      setupEventListeners();
      
      // Request user location
      getUserLocation();
      
      // Start animation loop
      enhancedAnimate();
    }
    
    // Get current theme (light/dark)
    function getTheme() {
      if (CONFIG.theme) {
        return CONFIG.theme;
      }
      
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark';
      }
      
      return 'light';
    }
    
    // Initialize Three.js scene
    function initScene() {
      // Initialize renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('globeContainer').appendChild(renderer.domElement);

      // Initialize scene
      scene = new THREE.Scene();
      
      // Set background color based on theme
      const backgroundColor = currentTheme === 'dark' ? 0x121212 : 0xf5f5f5;
      scene.background = new THREE.Color(backgroundColor);
      
      scene.add(new THREE.AmbientLight(0xeeeeee, 0.3));
      
      // Initialize camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      
      const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dLight.position.set(-800, 2000, 400);
      camera.add(dLight);
      
      const dLight1 = new THREE.DirectionalLight(0x7982f6, 1);
      dLight1.position.set(-200, 500, 200);
      camera.add(dLight1);
      
      const dLight2 = new THREE.PointLight(0x8566cc, 0.5);
      dLight2.position.set(-200, 500, 200);
      camera.add(dLight2);
      
      camera.position.z = CONFIG.currentZoomLevel;
      camera.position.x = 0.0;
      camera.position.y = 0.0;
      
      const initialTarget = calculateLookAtTarget(CONFIG.currentZoomLevel);
      camera.lookAt(initialTarget);

      scene.add(camera);
      
      // Add fog for atmospheric effect
      const fogColor = currentTheme === 'dark' ? 0x333333 : 0xcccccc;
      scene.fog = new THREE.Fog(fogColor, 400, 2000);
      
      // Initialize orbit controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      // controls.target.copy(initialTarget); // Set initial control target
      controls.enableDamping = true;
      controls.dynamicDampingFactor = 0.01;
      controls.enablePan = false;
      controls.minDistance = CONFIG.minDistance;
      controls.maxDistance = CONFIG.maxDistance;
      controls.rotateSpeed = 0.8;
      controls.zoomSpeed = 1;
      controls.autoRotate = CONFIG.autoRotate;
      controls.autoRotateSpeed = CONFIG.autoRotateSpeed;
         
      controls.minPolarAngle = 5 * (Math.PI / 180);  // 5 degrees from north pole
      controls.maxPolarAngle = 175 * (Math.PI / 180); // 5 degrees from south pole  
    }
    
    // Texture cache using IndexedDB
    const TextureCache = {
      dbName: 'earth-texture-cache',
      dbVersion: 1,
      db: null,

      init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('textures')) {
              db.createObjectStore('textures', { keyPath: 'url' });
            }
          };
          
          request.onsuccess = (event) => {
            this.db = event.target.result;
            resolve();
          };
          
          request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
          };
        });
      },

      storeTexture(url, blob) {
        return new Promise((resolve, reject) => {
          if (!this.db) return reject(new Error('Database not initialized'));
          
          const transaction = this.db.transaction(['textures'], 'readwrite');
          const store = transaction.objectStore('textures');
          
          const item = { url, blob, timestamp: Date.now() };
          const request = store.put(item);
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      },

      getTexture(url) {
        return new Promise((resolve, reject) => {
          if (!this.db) return reject(new Error('Database not initialized'));
          
          const transaction = this.db.transaction(['textures'], 'readonly');
          const store = transaction.objectStore('textures');
          
          const request = store.get(url);
          
          request.onsuccess = (event) => {
            resolve(event.target.result ? event.target.result.blob : null);
          };
          
          request.onerror = (event) => reject(event.target.error);
        });
      },
    
      async hasTexture(url) {
        if (!this.db) return false;
        
        return new Promise((resolve) => {
          try {
            const transaction = this.db.transaction(['textures'], 'readonly');
            const store = transaction.objectStore('textures');
            
            // Use the faster .count() method instead of .get() to just check existence
            const request = store.count(url);
            
            request.onsuccess = (event) => {
              resolve(event.target.result > 0);
            };
            
            request.onerror = () => {
              resolve(false);
            };
            
            // Safety in case transaction takes too long
            transaction.oncomplete = () => {
              // This might never be reached if the request completes first
            };
            
            transaction.onerror = () => {
              resolve(false);
            };
            
            transaction.onabort = () => {
              resolve(false);
            };
          } catch (err) {
            console.warn('Error checking texture cache:', err);
            resolve(false);
          }
        });
      }
    };

    // Progressive texture loader
    const TextureManager = {
      baseUrl: window.location.origin + '/static/img/',
      resolutions: {
        low: '2k_',
        high: '8k_'
      },
      textureTypes: [
        'earth_daymap',
        'earth_nightmap',
        'earth_normal_map',
        'earth_specular_map',
        'earth_clouds'
      ],
      loadedTextures: {
        low: {},
        high: {}
      },
      
      async init() {
        await TextureCache.init();
        return this;
      },
      
      getTextureUrl(type, resolution) {
        const prefix = this.resolutions[resolution];
        return `${this.baseUrl}${prefix}${type}.avif`;
      },
      
      async loadTexture(type, resolution, retryCount = 0, maxRetries = 3) {
  
        const url = this.getTextureUrl(type, resolution);
  
        // Return cached texture if already loaded
        if (this.loadedTextures[resolution][type]) {
          return this.loadedTextures[resolution][type];
        }
        
        // Try to get from cache
        try {
          const cachedBlob = await TextureCache.getTexture(url);
          if (cachedBlob) {
            console.log(`Using cached texture: ${type} (${resolution})`);
            const texture = await this._createTextureFromBlob(cachedBlob);
            this.loadedTextures[resolution][type] = texture;
            return texture;
          }
        } catch (err) {
          console.warn('Error loading texture from cache:', err);
        }
        
        // Fetch from network with retry logic
        try {
          console.log(`Fetching texture: ${type} (${resolution})`);
          const response = await fetch(url, {
            // Add cache control headers
            headers: {
              'Cache-Control': 'max-age=86400', // Cache for 24 hours
            },
            // Use cache-first strategy
            cache: 'force-cache'
          });
          
          if (!response.ok) throw new Error(`Failed to load texture: ${url} (${response.status})`);
          
          const blob = await response.blob();
          
          // Store in cache
          try {
            await TextureCache.storeTexture(url, blob);
            console.log(`Texture cached: ${type} (${resolution})`);
          } catch (err) {
            console.warn('Error storing texture in cache:', err);
          }
          
          // Create texture
          const texture = await this._createTextureFromBlob(blob);
          this.loadedTextures[resolution][type] = texture;
          return texture;
        } catch (err) {
          // Retry logic
          if (retryCount < maxRetries) {
            console.warn(`Retry ${retryCount + 1}/${maxRetries} for texture: ${url}`);
            // Exponential backoff - wait longer between each retry
            await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retryCount)));
            return this.loadTexture(type, resolution, retryCount + 1, maxRetries);
          }
          
          console.error('Error loading texture after retries:', err);
          // Return a default fallback texture
          return this._createFallbackTexture(type);
        }
      },

      // 2. Add a new method to TextureManager to create fallback textures
      _createFallbackTexture(type) {
        console.log(`Creating fallback texture for: ${type}`);
        
        // Create a canvas with a solid color
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Different colors for different texture types
        let color;
        switch (type) {
          case 'earth_daymap':
            color = '#1a4d7e'; // Dark blue for day
            break;
          case 'earth_nightmap':
            color = '#000020'; // Near black for night
            break;
          case 'earth_normal_map':
            color = '#8080ff'; // Normal map blue
            break;
          case 'earth_specular_map':
            color = '#000000'; // Black for no specular
            break;
          case 'earth_clouds':
            color = '#ffffff'; // White with transparancy
            ctx.globalAlpha = 0.2;
            break;
          default:
            color = '#000000'; // Default black
        }
        
        // Fill with base color
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Create texture from canvas
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      },

      _createTextureFromBlob(blob) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(blob);
          const loader = new THREE.TextureLoader();
          
          loader.load(
            url,
            (texture) => {
              URL.revokeObjectURL(url);
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.encoding = THREE.sRGBEncoding;
              resolve(texture);
            },
            undefined,
            (err) => {
              URL.revokeObjectURL(url);
              reject(err);
            }
          );
        });
      },
      
      async loadAllTextures(resolution) {
        const promises = this.textureTypes.map(type => 
          this.loadTexture(type, resolution)
        );
        
        try {
          const textures = await Promise.all(promises);
          const result = {};
          
          this.textureTypes.forEach((type, index) => {
            result[type] = textures[index];
          });
          
          return result;
        } catch (err) {
          console.error('Error loading all textures:', err);
          throw err;
        }
      }
    };

    // Earth PBR shader
    const EarthPBRShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        
        void main() {
          vUv = uv;
          
          // Properly compute and output the normal
          vNormal = normalize(normalMatrix * normal);
          
          // Calculate world position
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          vec4 mvPosition = viewMatrix * worldPosition;
          vViewPosition = -mvPosition.xyz;
          
          // Output position
          gl_Position = projectionMatrix * mvPosition;
          
          // Calculate tangent space for normal mapping
          // This improves normal calculations for smooth shading
          vec3 objectTangent = vec3(1.0, 0.0, 0.0);
          vec3 objectBitangent = vec3(0.0, 1.0, 0.0);
          
          // Ensure tangent is perpendicular to normal
          objectTangent = normalize(objectTangent - normal * dot(objectTangent, normal));
          objectBitangent = normalize(cross(normal, objectTangent));
          
          // Transform to view space
          vTangent = normalize(normalMatrix * objectTangent);
          vBitangent = normalize(normalMatrix * objectBitangent);
        }
      `,
      
      fragmentShader: `
        uniform sampler2D dayMap;
        uniform sampler2D nightMap;
        uniform sampler2D normalMap;
        uniform sampler2D specularMap;
        uniform vec3 sunDirection;
        
        // Earth properties
        uniform float normalScale;
        uniform float specularIntensity;
        uniform float roughness;
        uniform float fresnelPower;
        uniform float atmosphereIntensity;
        
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        varying vec3 vTangent;
        varying vec3 vBitangent;
        
        // Improved normal mapping function for smooth shading
        vec3 perturbNormal() {
          // Ensure normalized vectors for smooth shading
          vec3 normal = normalize(vNormal);
          vec3 tangent = normalize(vTangent);
          vec3 bitangent = normalize(vBitangent);
          
          // Get normal map value and convert to world space
          vec3 mapN = texture2D(normalMap, vUv).xyz * 2.0 - 1.0;
          mapN.xy *= normalScale;
          
          // Create TBN matrix for normal map transformation
          mat3 tbn = mat3(tangent, bitangent, normal);
          
          // Return perturbed normal in view space, correctly normalized
          return normalize(tbn * mapN);
        }
        
        // Improved Fresnel function
        float fresnel(float cosTheta, float F0, float power) {
          return F0 + (1.0 - F0) * pow(max(0.0, 1.0 - cosTheta), power);
        }
        
        void main() {
          // Ensure normalized vectors for smooth shading
          vec3 viewDir = normalize(vViewPosition);
          vec3 normal = normalize(vNormal);
          
          // Apply normal mapping with reduced intensity for smoother look
          if (normalScale > 0.0) {
            normal = mix(normal, perturbNormal(), 0.7);
          }
          
          // Calculate day/night based on dot product of position and sun direction
          vec3 positionOnGlobe = normalize(vWorldPosition);
          float dayNightMix = dot(positionOnGlobe, sunDirection);
          
          // Smoother transition between day and night
          float lightIntensity = smoothstep(-0.15, 0.15, dayNightMix);
          
          // Sample the day and night textures
          vec3 dayColor = texture2D(dayMap, vUv).rgb;
          vec3 nightColor = texture2D(nightMap, vUv).rgb * 0.5;
          
          // Sample the specular map
          float specular = texture2D(specularMap, vUv).r;
          
          // Base color with day/night transition
          vec3 color = mix(nightColor, dayColor, lightIntensity);
          
          // Add specular highlights when lit by the sun
          if (dayNightMix > 0.0) {
            // Blinn-Phong specular with softer falloff for smoother look
            vec3 halfVector = normalize(sunDirection + viewDir);
            float NdotH = max(0.0, dot(normal, halfVector));
            float specularFactor = pow(NdotH, (1.0 - roughness) * 80.0) * specular * specularIntensity;
            
            color += specularFactor * vec3(1.0);
          }
          
          // Calculate fresnel effect (rim lighting)
          float NdotV = max(0.001, dot(normal, viewDir));
          float fresnelFactor = fresnel(NdotV, 0.0, fresnelPower);
          
          // Add atmosphere rim without darkening center
          vec3 atmosphereColor = vec3(0.3, 0.6, 1.0) * atmosphereIntensity;
          color = mix(color, atmosphereColor, fresnelFactor * 0.3);
          
          // Brighten the overall result
          color *= 1.3;
          
          // Output final color
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      
      uniforms: {
        dayMap: { value: null },
        nightMap: { value: null },
        normalMap: { value: null },
        specularMap: { value: null },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
        normalScale: { value: 1.0 },
        specularIntensity: { value: 0.2 },
        roughness: { value: 1.2 },
        fresnelPower: { value: 1.0 },
        atmosphereIntensity: { value: 1.0 }
      }
    };
  
    // Cloud shader
    const CloudShader = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
        
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      
      fragmentShader: `
        uniform sampler2D cloudMap;
        uniform vec3 sunDirection;
        uniform float cloudOpacity;
        uniform float cloudBrightness;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        varying vec3 vWorldPosition;
    
        void main() {
          // Get the cloud texture
          vec4 cloudTexel = texture2D(cloudMap, vUv);
          
          // Calculate day/night based on dot product of position and sun direction
          vec3 positionOnGlobe = normalize(vWorldPosition);
          float dayNightMix = dot(positionOnGlobe, sunDirection);
          
          // Smoother transition for cloud lighting
          float lightIntensity = smoothstep(-0.2, 0.3, dayNightMix);
          
          // Cloud brightness based on sunlight (brighter in day, darker at night)
          // But never completely black - minimum 0.3 intensity
          float adjustedBrightness = mix(0.3, 1.0, lightIntensity) * cloudBrightness;
          
          // Cloud color - pure white but affected by light intensity
          vec3 cloudColor = vec3(1.0) * adjustedBrightness;
          
          // Extract alpha from the luminance/brightness of the cloud texture
          // This properly makes dark areas transparent and white areas visible
          float alpha = (cloudTexel.r + cloudTexel.g + cloudTexel.b) / 3.0;
          
          // Apply overall cloud opacity
          alpha *= cloudOpacity;
          
          // Output with correct transparency
          gl_FragColor = vec4(cloudColor, alpha);
        }
      `,
      
      uniforms: {
        cloudMap: { value: null },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
        cloudOpacity: { value: 0.9 },  // Increased from 0.8
        cloudBrightness: { value: 1.2 }
      }
    };

    // Atmospheric glow shader
    const AtmosphereShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float power;
        uniform float atmosphereIntensity;
        uniform vec3 sunDirection;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        varying vec3 vWorldPosition;
    
        void main() {
          // Fresnel-like glow effect based on viewing angle
          float intensity = pow(0.75 - dot(vNormal, vec3(0, 0, 1.0)), power);
          
          // Calculate day/night based on dot product of position and sun direction
          vec3 positionOnGlobe = normalize(vWorldPosition);
          float dayNightMix = dot(positionOnGlobe, sunDirection);
          
          // Adjust glow based on day/night (stronger on day side)
          // Check if this point on the atmosphere is in day or night
          float sunEffect = smoothstep(-0.2, 0.3, dayNightMix);
          
          // Blend atmosphere colors - bluer in day, more purple at night
          vec3 dayGlow = glowColor;
          vec3 nightGlow = vec3(0.2, 0.1, 0.4); // More purple for night
          vec3 finalGlowColor = mix(nightGlow, dayGlow, sunEffect);
          
          // Apply atmosphere intensity
          vec3 glow = finalGlowColor * intensity * atmosphereIntensity;
          
          // Output with proper transparency
          gl_FragColor = vec4(glow, intensity * 0.8);
        }
      `,
      
      uniforms: {
        glowColor: { value: new THREE.Color(0x3a88ff) },
        power: { value: 2.0 },
        atmosphereIntensity: { value: 1.0 },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) }
      }
    };

    // Earth object with PBR rendering
    class EnhancedEarth {
      constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.textureManager = null;
        this.earthMesh = null;
        this.cloudMesh = null;
        this.atmosphereMesh = null;
        this.currentResolution = 'low';
        this.earthRadius = 100.0;      // Changed from 1.0
        this.cloudRadius = 100.1;      // Changed from 1.02
        this.atmosphereRadius = 102.0; // Changed from 1.1
        this.zoomThreshold = 250;
        
        // Shader materials
        this.earthMaterial = null;
        this.cloudMaterial = null;
        this.atmosphereMaterial = null;
        
        // Options
        this.options = {
          normalScale: 1.0,
          specularIntensity: 0.5,
          roughness: 0.7,
          fresnelPower: 1.0,
          atmosphereIntensity: 0.6,
          cloudOpacity: 0.5,
          cloudBrightness: 2.0,
          cloudRotationSpeed: 0.0,
        };
      }
      
      async init() {
        
        // Initialize texture manager
        this.textureManager = await TextureManager.init();
        
        // Create geometries
        const earthGeometry = new THREE.SphereGeometry(this.earthRadius, 64, 64);
        const cloudGeometry = new THREE.SphereGeometry(this.cloudRadius, 64, 64);
        const atmosphereGeometry = new THREE.SphereGeometry(this.atmosphereRadius, 64, 64);
        
        // Create materials (shader creation is unchanged)
        this.earthMaterial = new THREE.ShaderMaterial({
          vertexShader: EarthPBRShader.vertexShader,
          fragmentShader: EarthPBRShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(EarthPBRShader.uniforms),
          extensions: {
            derivatives: true
          }
        });
        
        this.cloudMaterial = new THREE.ShaderMaterial({
          vertexShader: CloudShader.vertexShader,
          fragmentShader: CloudShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(CloudShader.uniforms),
          transparent: true,
          blending: THREE.CustomBlending,
          blendSrc: THREE.SrcAlphaFactor,
          blendDst: THREE.OneMinusSrcAlphaFactor
        });
        
        this.atmosphereMaterial = new THREE.ShaderMaterial({
          vertexShader: AtmosphereShader.vertexShader,
          fragmentShader: AtmosphereShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(AtmosphereShader.uniforms),
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide
        });
        
        // Create meshes
        this.earthMesh = new THREE.Mesh(earthGeometry, this.earthMaterial);
        this.earthMesh.name = 'earth-mesh';
        
        this.cloudMesh = new THREE.Mesh(cloudGeometry, this.cloudMaterial);
        this.cloudMesh.name = 'cloud-mesh';
        
        this.atmosphereMesh = new THREE.Mesh(atmosphereGeometry, this.atmosphereMaterial);
        this.atmosphereMesh.name = 'atmosphere-mesh';
        
        // Add to scene
        this.scene.add(this.earthMesh);
        this.scene.add(this.cloudMesh);
        this.scene.add(this.atmosphereMesh);
        
        // STEP 1: Start with empty textures for immediate rendering
        this.loadEmptyTextures();
        
        // Update shader properties with initial settings
        this.updateShaderProperties();
        
        // STEP 2-5: Begin progressive texture loading (non-blocking)
        this.progressivelyLoadTextures();
        
        // Set up solar position and other initializations
        const dt = new Date();
        const [longitude, declination] = calculateSolarPosition(dt);
        this.updateSunDirection(longitude, declination);
        
        // Update solar position every minute
        setInterval(() => {
          const dt = new Date();
          const [longitude, declination] = calculateSolarPosition(dt);
          this.updateSunDirection(longitude, declination);
        }, 60000);
        
        return this;
      }
      
      areLowResTexturesCached = async function() {
        try {
          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Cache check timeout')), 50)
          );
          
          for (const type of this.textureManager.textureTypes) {
            const url = this.textureManager.getTextureUrl(type, 'low');
            
            const isCached = await Promise.race([
              TextureCache.hasTexture(url),
              timeout
            ]);
            
            if (!isCached) {
              return false; // Early return if any texture isn't cached
            }
          }
          
          return true;
        } catch (err) {
          console.warn('Fast low-res cache check failed:', err);
          return false;
        }
      }

      loadEmptyTextures() {
        console.log('Using empty textures for initial rendering');
        
        // Create empty textures for each type
        const textures = {};
        this.textureManager.textureTypes.forEach(type => {
          textures[type] = this.textureManager._createFallbackTexture(type);
        });
        
        // Update material uniforms with empty textures
        this.earthMaterial.uniforms.dayMap.value = textures.earth_daymap;
        this.earthMaterial.uniforms.nightMap.value = textures.earth_nightmap;
        this.earthMaterial.uniforms.normalMap.value = textures.earth_normal_map;
        this.earthMaterial.uniforms.specularMap.value = textures.earth_specular_map;
        this.cloudMaterial.uniforms.cloudMap.value = textures.earth_clouds;
      }

      async progressivelyLoadTextures() {
        try {
          // STEP 2: Check if low-resolution textures are cached
          const lowResCached = await this.areLowResTexturesCached();
          
          if (lowResCached) {
            // If low-res textures are cached, load them immediately (still faster than high-res)
            console.log('Found cached low-resolution textures, loading them first');
            this.loadTextures('low').catch(err => console.warn('Error loading low-res textures:', err));
          } else {
            // If not cached, need to load from network after a short delay
            // to allow the empty textures to render first
            setTimeout(() => {
              console.log('Loading low-resolution textures from network');
              this.loadTextures('low').catch(err => console.warn('Error loading low-res textures:', err));
            }, 100);
          }
          
          // STEP 4: Check if high-resolution textures are cached
          setTimeout(async () => {
            const highResCached = await this.areHighResTexturesCached();
            
            if (highResCached) {
              // Load high-res textures from cache after low-res textures have loaded
              console.log('Found cached high-resolution textures, upgrading');
              this.loadTextures('high').catch(err => console.warn('Error loading high-res textures:', err));
            } else {
              // STEP 5: Load high-res from network with longer delay
              setTimeout(() => {
                console.log('Loading high-resolution textures from network');
                this.loadTextures('high').catch(err => console.warn('Error loading high-res textures:', err));
              }, 5000); // 5 second delay to ensure low-res textures are loaded and displayed first
            }
          }, 850); // Small delay to ensure we don't block loading low-res textures
          
        } catch (err) {
          console.error('Error in progressive texture loading:', err);
        }
      }

      async loadTextures(resolution) {
        try {
          // Start loading textures
          const startTime = performance.now();
          console.log(`Loading ${resolution} resolution textures...`);
          
          const textures = await this.textureManager.loadAllTextures(resolution);
          
          // Update the materials with new textures
          this.earthMaterial.uniforms.dayMap.value = textures.earth_daymap;
          this.earthMaterial.uniforms.nightMap.value = textures.earth_nightmap;
          this.earthMaterial.uniforms.normalMap.value = textures.earth_normal_map;
          this.earthMaterial.uniforms.specularMap.value = textures.earth_specular_map;
          this.cloudMaterial.uniforms.cloudMap.value = textures.earth_clouds;
          
          // Update current resolution
          this.currentResolution = resolution;
          
          // Log performance
          const loadTime = (performance.now() - startTime).toFixed(0);
          console.log(`✓ Completed loading ${resolution} textures in ${loadTime}ms`);
          
          return true;
        } catch (err) {
          console.error(`Error loading ${resolution} textures:`, err);
          
          // Only create fallback if we failed to load low-res textures
          // (we already have empty textures loaded)
          if (resolution === 'low' && !this.textureLoadingFailed) {
            this.createFallbackEarth();
          }
          
          return false;
        }
      }

      createFallbackEarth() {
        console.warn('Creating fallback Earth due to texture loading failures');
        
        // Create a simple material for Earth
        const fallbackEarthMaterial = new THREE.MeshPhongMaterial({
          color: 0x2233aa,  // Blue color
          emissive: 0x112244,
          emissiveIntensity: 0.5, // Add emissive to ensure earth is never too dark
          specular: 0x333333,
          shininess: 25
        });
        
        // Apply the fallback material
        this.earthMesh.material = fallbackEarthMaterial;
        
        // Create a simple material for clouds
        const fallbackCloudMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.1
        });
        
        // Apply the fallback cloud material
        this.cloudMesh.material = fallbackCloudMaterial;
        
        // Create a simple material for atmosphere
        const fallbackAtmosphereMaterial = new THREE.MeshBasicMaterial({
          color: 0x3366ff,
          transparent: true,
          opacity: 0.2,
          side: THREE.BackSide
        });
        
        // Apply the fallback atmosphere material
        this.atmosphereMesh.material = fallbackAtmosphereMaterial;
        
        // Set flag to prevent further texture loading attempts
        this.textureLoadingFailed = true;
      }

      updateShaderProperties() {
        // Update Earth material uniforms
        this.earthMaterial.uniforms.normalScale.value = this.options.normalScale;
        this.earthMaterial.uniforms.specularIntensity.value = this.options.specularIntensity;
        this.earthMaterial.uniforms.roughness.value = this.options.roughness;
        this.earthMaterial.uniforms.fresnelPower.value = this.options.fresnelPower;
        this.earthMaterial.uniforms.atmosphereIntensity.value = this.options.atmosphereIntensity;
        
        // Update Cloud material uniforms
        this.cloudMaterial.uniforms.cloudOpacity.value = this.options.cloudOpacity;
        this.cloudMaterial.uniforms.cloudBrightness.value = this.options.cloudBrightness;
        
        // Update Atmosphere material uniforms
        this.atmosphereMaterial.uniforms.atmosphereIntensity.value = this.options.atmosphereIntensity;
      }
      
      updateSunDirection(longitude, declination) {
        // Convert longitude and declination to Cartesian coordinates
        const phi = (90 - declination) * Math.PI / 180;
        const theta = longitude * Math.PI / 180;
        
        const sunX = Math.sin(phi) * Math.cos(theta);
        const sunY = Math.cos(phi);
        const sunZ = Math.sin(phi) * Math.sin(theta);
        
        const sunDirection = new THREE.Vector3(sunX, sunY, sunZ);
        
        // Update shader uniforms
        this.earthMaterial.uniforms.sunDirection.value = sunDirection;
        this.cloudMaterial.uniforms.sunDirection.value = sunDirection;
        this.atmosphereMaterial.uniforms.sunDirection.value = sunDirection;
        
        // Debug info
        console.log(`Sun direction updated: longitude=${longitude}, declination=${declination}`);
        console.log(`Sun vector: x=${sunX.toFixed(2)}, y=${sunY.toFixed(2)}, z=${sunZ.toFixed(2)}`);
      }
      
      update() {
        if (this.cloudMesh) {
          this.cloudMesh.rotation.y += this.options.cloudRotationSpeed;
        }
      }
      
      // New method to check if all high-res textures are cached
      async areHighResTexturesCached() {
        try {
          // Set a timeout for cache checking to avoid long startup delays
          const timeout = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Cache check timeout')), 500)
          );
          
          // Check textures one by one and fail fast if any aren't cached
          for (const type of this.textureManager.textureTypes) {
            const url = this.textureManager.getTextureUrl(type, 'high');
            
            // Use Promise.race to implement timeout for each check
            const isCached = await Promise.race([
              TextureCache.hasTexture(url),
              timeout
            ]);
            
            if (!isCached) {
              console.log(`High-res texture not cached: ${type}`);
              return false; // Early return if any texture isn't cached
            }
          }
          
          console.log('All high-resolution textures are cached');
          return true;
        } catch (err) {
          console.warn('Fast cache check failed:', err);
          return false; // Safely default to low-res on any error
        }
      }

      // Modified zoom listener to avoid redundant loading attempts
      setupZoomListener() {
        // Just monitor for fallback to low-res if high-res fails
        setInterval(() => {
          if (this.textureLoadingFailed) return;
          
          // If for some reason we're still on empty textures after a while,
          // attempt to load low-res textures
          if (!this.earthMaterial.uniforms.dayMap.value || 
              this.earthMaterial.uniforms.dayMap.value.image.width <= 64) {
            console.log('Still using empty textures, attempting to load low-resolution textures');
            this.loadTextures('low');
          }
        }, 10000); // Check after 10 seconds
      }

      update() {
        if (this.cloudMesh) {
          this.cloudMesh.rotation.y += this.options.cloudRotationSpeed;
        }
      }
      
      setCloudOpacity(opacity) {
        this.options.cloudOpacity = opacity;
        if (this.cloudMaterial && this.cloudMaterial.uniforms.cloudOpacity) {
          this.cloudMaterial.uniforms.cloudOpacity.value = opacity;
        }
      }
      
      getEarthMesh() {
        return this.earthMesh;
      }
    }


    function getKeyboardFocusableElements(element = document) {
        return Array.from(element.querySelectorAll(
            'a, button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])'
        ))
        .filter(el => !el.hasAttribute('disabled'))
        .sort((a, b) => {
            // Get explicit tabindex values
            const aTabIndex = parseInt(a.getAttribute('tabindex') || '0', 10);
            const bTabIndex = parseInt(b.getAttribute('tabindex') || '0', 10);
            
            // Sort by tabindex (elements with tabindex > 0 come first, in numerical order)
            if (aTabIndex > 0 && bTabIndex > 0) {
                return aTabIndex - bTabIndex;
            }
            
            // Elements with tabindex > 0 come before elements with tabindex = 0
            if (aTabIndex > 0) return -1;
            if (bTabIndex > 0) return 1;
            
            // Elements with tabindex = 0 are sorted by their DOM position
            return 0;
        });
    }

    // Set up event listeners
    function setupEventListeners() {
      // Window resize event
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
        // Search input events
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        searchInput.addEventListener('input', handleSearch);
        
        // Reset selection index when focusing back on the search input
        searchInput.addEventListener('focus', () => {
            // Reset the selectedSearchIndex when focus returns to input
            selectedSearchIndex = -1;
            
            if (searchResults.children.length > 0) {
            searchResults.style.display = 'block';
            }
        });

        document.body.addEventListener('keydown', (e) => {

            // Check if we should ignore keyboard shortcuts
            const activeElement = document.activeElement;
            const tagName = activeElement.tagName.toLowerCase();
            
            // Ignore keyboard shortcuts if an input field is focused
            const isInputFocused = tagName === 'input' || 
                                  tagName === 'textarea' || 
                                  tagName === 'select' ||
                                  activeElement.isContentEditable ||
                                  activeElement.getAttribute('role') === 'textbox';
            
            if (!isInputFocused) {
              if (e.key === '+' || e.key === '=') {
                zoomIn();
              } else if (e.key === '-' || e.key === '_') {
                zoomOut();
              }
            }
          
            const searchResults = document.getElementById('searchResults');
    
            // Only handle arrow keys when search results are visible
            if (searchResults.style.display === 'block' && 
                (e.key === 'ArrowDown' || e.key === 'ArrowUp' || 
                e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
                
                e.preventDefault();
                
                // Get all focusable elements
                const focusableElements = getKeyboardFocusableElements();
                
                // Get current element's position in the tab order
                const currentElement = document.activeElement;
                const currentIndex = focusableElements.indexOf(currentElement);
                
                if (currentIndex !== -1) {
                    // Determine next position based on arrow key
                    let nextIndex;
                    if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                        nextIndex = Math.min(currentIndex + 1, focusableElements.length - 1);
                    } else {
                        nextIndex = Math.max(currentIndex - 1, 0);
                    }
                    
                    // Focus the next element
                    if (nextIndex !== currentIndex) {
                        focusableElements[nextIndex].focus();
                        
                        // If it's a search result item, ensure it's visible
                        if (focusableElements[nextIndex].classList.contains('search-result-item')) {
                            focusableElements[nextIndex].scrollIntoView({ block: 'nearest' });
                        }
                    }
                }
            }
        });

        const zoomInButton = document.querySelector('.zoom-button.zoom-in');
        const zoomOutButton = document.querySelector('.zoom-button.zoom-out');
        
        if (zoomInButton) {
          zoomInButton.addEventListener('click', () => {
            zoomIn();
          });
        } else {
          console.error('Zoom in button not found');
        }
        
        if (zoomOutButton) {
          zoomOutButton.addEventListener('click', () => {
            zoomOut();
          });
        } else {
          console.error('Zoom out button not found');
        }

        // Simplified searchInput event listener - just for Enter and Escape
        searchInput.addEventListener('keydown', (e) => {
            // Handle Enter key regardless of search results visibility
            if (e.key === 'Enter') {
                e.preventDefault();
                selectSearchResult();
                return;
            }
            
            if (searchResults.style.display === 'block' && e.key === 'Escape') {
                e.preventDefault();
                searchResults.style.display = 'none';
            }
        });
            
        // Close button event - reset highlights when panel closes
        document.getElementById('closeBtn').addEventListener('click', () => {
            document.getElementById('infoPanel').style.display = 'none';
            resetAllMarkers();
        });

        // Click event for globe interactions
        renderer.domElement.addEventListener('click', onDocumentMouseClick);
        

      // Close search results when clicking outside
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
          resetSearchResultsContainer();
        }
      });
      
      // Theme change detection
      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          if (!CONFIG.theme) {
            currentTheme = getTheme();
            updateTheme();
          }
        });
      }
      
      // Update camera change events
      controls.addEventListener('change', onCameraChange);
    }
    
    // Handle camera change for day/night shader
    function onCameraChange() {
      // Adjust rotation speed based on zoom level
      adjustRotationSpeed();
      // Update camera lookAt target based on current distance
      const distance = camera.position.length();
      const target = calculateLookAtTarget(distance);
      controls.target.copy(target);
    }
    
    // Update theme visuals
    function updateTheme() {
      // Update background
      const backgroundColor = currentTheme === 'dark' ? 0x121212 : 0xf5f5f5;
      scene.background = new THREE.Color(backgroundColor);
      
      // Update fog
      const fogColor = currentTheme === 'dark' ? 0x333333 : 0xcccccc;
      scene.fog = new THREE.Fog(fogColor, 400, 2000);
      
      // Update atmosphere
      globe.atmosphereColor(currentTheme === 'dark' ? "#3a228a" : "#ccc");
      
      // Update day texture (would require reloading textures)
      // This would be better handled by recreating the globe
    }
    

    // Update resetAllMarkers to also reset parish markers
    function resetAllMarkers() {
      // Reset priest markers
      scene.children
        .filter(obj => obj.name === 'priest-marker')
        .forEach(marker => marker.material.color.set(CONFIG.markerColor));
      
      scene.children
        .filter(obj => obj.name === 'priest-pulse')
        .forEach(pulse => {
          pulse.children
            .filter(child => child.isMesh)
            .forEach(mesh => mesh.material.color.set(CONFIG.markerPulseColor));
        });
        
      // Reset parish markers
      scene.children
        .filter(obj => obj.name === 'parish-marker')
        .forEach(marker => marker.material.color.set(CONFIG.parishMarkerColor));
        
      // Reset parish lines
      scene.children
        .filter(obj => obj.name === 'parish-line')
        .forEach(line => {
          line.material.color.set(CONFIG.parishLineColor);
          line.material.opacity = 0.7;
        });
    }

    function highlightSelectedPriest(priest) {
  // First reset all markers to their default color
  resetAllMarkers();
  
  // Clean priest ID
  const priestID = priest.PriestID.trim();
  
  console.log(`Highlighting priest: ${priest.Name} (ID: '${priestID}')`);
  
  // Then highlight the selected priest's markers
  scene.children
    .filter(obj => obj.name === 'priest-marker' && obj.priestData && obj.priestData.Name === priest.Name)
    .forEach(marker => {
      console.log(`Highlighting priest marker for ${priest.Name}`);
      marker.material.color.set('yellow');
    });
  
  // Find all pulse groups with this priest's data
  scene.children
    .filter(obj => obj.name === 'priest-pulse' && obj.priestData && obj.priestData.Name === priest.Name)
    .forEach(pulse => {
      // For each child of the pulse group that's a mesh
      pulse.children
        .filter(child => child.isMesh)
        .forEach(mesh => {
          mesh.material.color.set('rgba(255, 255, 0, 0.4)');
        });
    });
  
  // Find all parishes served by this priest
  console.log(`Looking for parishes with PriestID: '${priestID}'`);
  const servedParishes = parishes.filter(parish => parish.PriestID.trim() === priestID);
  console.log(`Found ${servedParishes.length} parishes for ${priest.Name}: ${servedParishes.map(p => p.ParishName).join(', ')}`);
  
  // Highlight parish markers in green (was orange)
  servedParishes.forEach(parish => {
    console.log(`Looking to highlight parish: ${parish.ParishName} (ID: '${parish.ParishID.trim()}')`);
    
    const parishMarkers = scene.children.filter(
      obj => obj.name === 'parish-marker' && 
      obj.parishData && 
      obj.parishData.ParishID.trim() === parish.ParishID.trim()
    );
    
    console.log(`Found ${parishMarkers.length} markers for parish ${parish.ParishName}`);
    
    parishMarkers.forEach(marker => {
      console.log(`Setting color for parish marker: ${parish.ParishName}`);
      marker.material.color.set('#00cc00'); // Changed from 'orange' to bright green
    });
  });
  
  // Highlight all parish lines connected to this priest
  console.log(`Looking for lines with priestID: '${priestID}'`);
  const priestLines = scene.children.filter(
    obj => obj.name === 'parish-line' && obj.priestID && obj.priestID.trim() === priestID
  );
  
  console.log(`Found ${priestLines.length} connecting lines for priest ${priest.Name}`);
  
  priestLines.forEach(line => {
    console.log(`Setting color for connecting line`);
    line.material.color.set('#00cc00'); // Changed from 'orange' to bright green
    line.material.opacity = 1.0;
    line.material.linewidth = 2; // Increased line width for better visibility (note: may not work in all browsers)
  });
}

    // Select the current search result
    function selectSearchResult(priest) {
        const searchResultsContainer = document.getElementById('searchResults');
        const items = searchResultsContainer.querySelectorAll('.search-result-item');
        
        // If no selection but we have results, select the first one
        if (selectedSearchIndex < 0 && items.length > 0) {
            selectedSearchIndex = 0;
        }
        
        if (selectedSearchIndex >= 0 && selectedSearchIndex < items.length) {
            const priest = searchResults[selectedSearchIndex];
            if (!priest) return;
            showPriestInfo(priest);
            focusOnPoint(priest.Latitude, priest.Longitude, CONFIG.minDistance);
            highlightSelectedPriest(priest);
            
            // Hide search results and clear input
            resetSearchResultsContainer();
            document.getElementById('searchInput').value = '';
        }
    }
          
    function onDocumentMouseClick(event) {
      // Calculate mouse position in normalized device coordinates
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      // Update the raycaster with the camera and mouse position
      raycaster.setFromCamera(mouse, camera);
      
      // Get all interactive objects
      const interactiveObjects = scene.children.filter(obj => 
        obj.name === 'priest-marker' || 
        obj.name === 'priest-pulse' || 
        obj.name === 'priest-marker-invisible' ||
        obj.name === 'parish-marker' ||
        obj.name === 'parish-marker-invisible'
      );
      
      // Find all intersections with interactive objects
      const intersects = raycaster.intersectObjects(interactiveObjects, true);
      
      // If we have intersections
      if (intersects.length > 0) {

        // Filter out back-side hits
        const frontSideHits = intersects.filter(hit => {
          // For each hit, check if it's on the front side
          const hitPoint = hit.point.clone();
          const cameraToHit = new THREE.Vector3().subVectors(hitPoint, camera.position);
          const cameraToCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), camera.position);
          return cameraToHit.dot(cameraToCenter) <= 0;
        });
        
        if (frontSideHits.length === 0) return;
        
        // Maps to collect unique data
        const hitPriests = new Map();
        const hitParishes = new Map();
        
        // Process each hit
        for (const hit of frontSideHits) {
          const obj = hit.object;
          
          // Check for priest data
          if ((obj.name === 'priest-marker' || obj.name === 'priest-marker-invisible') && obj.priestData) {
            if (!hitPriests.has(obj.priestData.Name)) {
              hitPriests.set(obj.priestData.Name, {
                data: obj.priestData,
                distance: hit.distance,
                type: 'priest'
              });
            }
          } else if (obj.parent && obj.parent.name === 'priest-pulse' && obj.parent.priestData) {
            if (!hitPriests.has(obj.parent.priestData.Name)) {
              hitPriests.set(obj.parent.priestData.Name, {
                data: obj.parent.priestData,
                distance: hit.distance,
                type: 'priest'
              });
            }
          } 
          // Check for parish data
          else if ((obj.name === 'parish-marker' || obj.name === 'parish-marker-invisible') && obj.parishData) {
            if (!hitParishes.has(obj.parishData.ParishID)) {
              hitParishes.set(obj.parishData.ParishID, {
                data: obj.parishData,
                distance: hit.distance,
                type: 'parish'
              });
            }
          }
        }
        
        // Combine and sort all hits
        const allHits = [
          ...Array.from(hitPriests.values()),
          ...Array.from(hitParishes.values())
        ].sort((a, b) => a.distance - b.distance);
        
        if (allHits.length === 1) {
          // Single hit
          const hit = allHits[0];
          if (hit.type === 'priest') {
            showPriestInfo(hit.data);
            highlightSelectedPriest(hit.data);
            focusOnPoint(hit.data.Latitude, hit.data.Longitude, 250.0);
          } else {
            // Show parish info
            showParishInfo(hit.data);
            highlightSelectedParish(hit.data);
            focusOnPoint(hit.data.Latitude, hit.data.Longitude, 250.0);
          }
        } else if (allHits.length > 1) {
          // Multiple hits
          event.stopPropagation();
          showProximitySearchResults(allHits);
        }
      }
    }

    // Add function to show parish info
    function showParishInfo(parish) {
      const infoPanel = document.getElementById('infoPanel');
      const priestName = document.getElementById('priestName');
      const priestInfo = document.getElementById('priestInfo');
      
      // Set parish name
      priestName.textContent = parish.ParishName;
      
      // Clear previous info
      priestInfo.innerHTML = '';
      
      // Clean IDs
      const priestID = parish.PriestID.trim();
      
      // Get the priest associated with this parish
      const priest = priestMap.get(priestID);
      
      // Priest information if available
      if (priest) {
        const priestParagraph = document.createElement('span');
        priestParagraph.className = 'info-paragraph';
        
        let title;
        switch(priest.Type) {
          case "Bishop":
            title = "Bp.";
            break;
          case "Father":
            title = "Fr.";
            break;
          case "Sister":
            title = "Sr.";
            break;
          case "Mother":
            title = "M.";
            break;
          case "Brother":
            title = "Br.";
            break;
          default:
            title = "";
        }
        
        let lastName = priest.Name.split(' ').pop();
        let firstInitial = priest.Name.charAt(0);
        
        const priestParagraph2 = document.createElement('p');
        priestParagraph2.textContent = `${parish.IsHomePriest ? getTranslatedText('HOME_PARISH_OF') : getTranslatedText('SERVED_BY')} `;
        priestParagraph2.style.display = 'inline';

        // Add a link to show priest info
        const priestLink = document.createElement('p');
        priestLink.className = 'info-paragraph';
        priestLink.innerHTML = `<a href="#" class="priest-link">${title} ${firstInitial}. ${lastName}</a>`;
        priestLink.querySelector('a').addEventListener('click', (e) => {
          e.preventDefault();
          showPriestInfo(priest);
          highlightSelectedPriest(priest);
          // Don't change camera focus since we're already looking at the parish
        });
        priestLink.style.display = 'inline';

        const priestParagraph3 = document.createElement('p');
        priestParagraph3.textContent = `.`;
        priestParagraph3.style.display = 'inline';

        priestParagraph.appendChild(priestParagraph2);
        priestParagraph.appendChild(priestLink);
        priestParagraph.appendChild(priestParagraph3);
        priestInfo.appendChild(priestParagraph);
      }
      
      // Notes section
      if (parish.Notes) {
        const notesSection = document.createElement('span');
        notesSection.className = 'notes-section';
        
        const notesTitle = document.createElement('strong');
        notesTitle.textContent = getTranslatedText('NOTES');
        notesSection.appendChild(notesTitle);
        
        const notesContent = document.createElement('p');
        notesContent.textContent = parish.Notes;
        notesSection.appendChild(notesContent);
        
        priestInfo.appendChild(notesSection);
      }

      // Mass times section
      if (parish.MassTimes) {
        const massTimesSection = document.createElement('span');
        massTimesSection.className = 'mass-times-section';
        
        const massTimesTitle = document.createElement('strong');
        massTimesTitle.textContent = getTranslatedText('MASS_TIMES');
        massTimesSection.appendChild(massTimesTitle);
        
        const massTimesList = document.createElement('p');
        massTimesList.textContent = parish.MassTimes;
        massTimesSection.appendChild(massTimesList);
        
        priestInfo.appendChild(massTimesSection);
      }
      
      // Add Google Maps link
      const mapsRow = document.createElement('div');
      mapsRow.className = 'info-row';
      mapsRow.innerHTML = `<a href="${parish.GoogleMaps}" target="_blank" class="info-link maps">${getTranslatedText('VIEW_ON_MAPS')}</a>`;
      priestInfo.appendChild(mapsRow);
      
      // Show the info panel
      infoPanel.style.display = 'block';
    }


  // Highlight selected parish
  function highlightSelectedParish(parish) {

    // First reset all markers
  resetAllMarkers();
  
  // Clean IDs
  const parishID = parish.ParishID.trim();
  const priestID = parish.PriestID.trim();
  
  console.log(`Highlighting parish: ${parish.ParishName} (ID: '${parishID}')`);
  
  // Then highlight the selected parish marker in yellow
  scene.children
    .filter(obj => obj.name === 'parish-marker' && 
             obj.parishData && 
             obj.parishData.ParishID.trim() === parishID)
    .forEach(marker => {
      console.log(`Setting parish marker to yellow: ${parish.ParishName}`);
      marker.material.color.set('yellow');
    });
  
  // Get the priest for this parish
  const priest = priestMap.get(priestID);
  
  if (priest) {
    console.log(`Found priest for parish: ${priest.Name} (ID: '${priestID}')`);
    
    // Find all parishes served by this priest
    const priestParishes = parishes.filter(p => p.PriestID.trim() === priestID);
    console.log(`Found ${priestParishes.length} parishes for priest ${priest.Name}`);
    
    // Find the home parish for this priest
    const homeParish = priestParishes.find(p => p.IsHomePriest);
    
    // Highlight priest marker
    scene.children
      .filter(obj => obj.name === 'priest-marker' && 
               obj.priestData && 
               obj.priestData.PriestID.trim() === priestID)
      .forEach(marker => {
        console.log(`Highlighting priest marker for ${priest.Name}`);
        marker.material.color.set(parish.IsHomePriest ? 'yellow' : '#00cc00'); // Changed from 'orange' to green
      });
    
    // Highlight priest pulse
    scene.children
      .filter(obj => obj.name === 'priest-pulse' && 
               obj.priestData && 
               obj.priestData.PriestID.trim() === priestID)
      .forEach(pulse => {
        pulse.children
          .filter(child => child.isMesh)
          .forEach(mesh => {
            mesh.material.color.set(parish.IsHomePriest ? 'rgba(255, 255, 0, 0.4)' : 'rgba(0, 204, 0, 0.4)'); // Changed from orange to green
          });
      });
    
    // If this is not the home parish, highlight all other parishes in green
    if (!parish.IsHomePriest) {
      priestParishes.forEach(p => {
        if (p.ParishID.trim() !== parishID) {
          console.log(`Highlighting related parish: ${p.ParishName}`);
          scene.children
            .filter(obj => obj.name === 'parish-marker' && 
                     obj.parishData && 
                     obj.parishData.ParishID.trim() === p.ParishID.trim())
            .forEach(marker => {
              marker.material.color.set('#00cc00'); // Changed from 'orange' to green
            });
        }
      });
    }
    
    // Highlight connecting lines involving this parish or priest
    console.log(`Looking for parish lines with priestID: '${priestID}'`);
    scene.children
      .filter(obj => obj.name === 'parish-line' && 
               obj.priestID && 
               obj.priestID.trim() === priestID)
      .forEach(line => {
        console.log(`Highlighting parish line`);
        line.material.color.set('#00cc00'); // Changed from 'orange' to green
        line.material.opacity = 1.0;
        line.material.linewidth = 2; // Increased linewidth
      });
  }
}

    function resetSearchResultsContainer() {
      let searchResultsContainer = document.getElementById('searchResults');
      searchResultsContainer.innerHTML = `
        <div class="links">
          <div style="padding-top:10px;z-index:5;">
            <a class="outbound-link" href="https://github.com/fschutt/dubiacc/issues">${getTranslatedText('REPORT_ERROR')}</a>
            <a class="outbound-link" href="https://github.com/fschutt/dubiacc/issues">${getTranslatedText('REQUEST_MASS')}</a>
            <a style="color:white;" class="outbound-link" href="https://dubia.cc">${getTranslatedText('BACK_TO_SITE')}</a>
          </div>
        </div>`;
    }

    // Function to display search results when multiple priests are selected
    function showProximitySearchResults(results) {
      let searchResultsContainer = document.getElementById('searchResults');

      // Clear previous results
      searchResultsContainer.innerHTML = '';
      searchResults = [];
      selectedSearchIndex = -1;
      
      // Add results to global searchResults array
      searchResults = results.map(result => result.data);
      
      // Create result items
      results.forEach((result, i) => {
        const data = result.data;
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result-item';
        resultItem.tabIndex = i + 200;
        
        if (result.type === 'priest') {
          resultItem.textContent = `${data.Name} (${data['Location/Area'] || 'Unknown'})`;
        } else {
          resultItem.textContent = `${data.ParishName} (Parish)`;
        }
        
        resultItem.addEventListener('click', () => {
          if (result.type === 'priest') {
            showPriestInfo(data);
            highlightSelectedPriest(data);
          } else {
            showParishInfo(data);
            highlightSelectedParish(data);
          }
          focusOnPoint(data.Latitude, data.Longitude, 250.0);
          resetSearchResultsContainer();
        });
        
        resultItem.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            resultItem.click();
          }
        });
        
        searchResultsContainer.appendChild(resultItem);
      });
      
      // Display results
      searchResultsContainer.style.display = 'block';
    }

    // Animation loop
    function enhancedAnimate() {
      requestAnimationFrame(enhancedAnimate);
      
      // Update Earth's cloud rotation if available
      if (enhancedEarth) {
        enhancedEarth.update();
      }
      
      // Animate pulse rings for markers
      animatePulseRings();
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    // Animate pulse rings
    function animatePulseRings() {
      const time = Date.now() * 0.001; // time in seconds
      
      pulseMeshes.forEach(mesh => {
        // Pulse scale with sine wave (0.8 to 1.2)
        const scale = 1 + 0.2 * Math.sin(time * 2 + mesh.pulseOffset);
        mesh.scale.set(scale, scale, scale);
        
        // Pulse opacity (0.4 to 0.8)
        mesh.material.opacity = 0.4 + 0.2 * Math.abs(Math.sin(time + mesh.pulseOffset));
      });
    }
    
    // Load priests data (from URL or fallback)
    function loadPriestsData() {
      // Load priests data
      if (CONFIG.dataUrl) {
        fetch(CONFIG.dataUrl)
          .then(response => response.text())
          .then(csvData => {
            parsePriestsData(csvData);
            // After priests are loaded, load parishes
            loadParishesData();
          })
          .catch(error => {
            console.error('Error loading priests data:', error);
            console.log('Falling back to default priests data');
            parsePriestsData(defaultPriestCsvData);
            loadParishesData();
          });
      } else {
        // Use default hardcoded data
        parsePriestsData(defaultPriestCsvData);
        loadParishesData();
      }
    }

    // Parse priests data
    function parsePriestsData(csvData) {
      Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          // Clean data by trimming all fields, especially IDs
          const cleanData = results.data.map(priest => {
            // Create a new object with trimmed keys and values
            const cleanedPriest = {};
            Object.keys(priest).forEach(key => {
              // Trim both the key and value if they're strings
              const cleanKey = typeof key === 'string' ? key.trim() : key;
              const value = priest[key];
              const cleanValue = typeof value === 'string' ? value.trim() : value;
              cleanedPriest[cleanKey] = cleanValue;
            });
            return cleanedPriest;
          });
          
          // Process data and add missing columns (lat, long, GoogleMaps)
          priests = addGeoData(cleanData);
          
          // Create a map of priest IDs to priest objects
          priestMap.clear();
          priests.forEach(priest => {
            // Make sure PriestID is trimmed
            const priestID = priest.PriestID.trim();
            priest.PriestID = priestID; // Ensure PriestID is stored trimmed
            priestMap.set(priestID, priest);
          });
          
          console.log(`Loaded ${priests.length} priests`);
          console.log("Priest IDs:", priests.map(p => `'${p.PriestID}'`).join(", "));
        },
        error: (error) => {
          console.error('Error parsing priests CSV:', error);
        }
      });
    }

    // Parse parishes data
    function parseParishesData(csvData) {
      Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          parishes = results.data.map(parish => {
            // Create a new object with trimmed fields
            const cleanedParish = {};
            Object.keys(parish).forEach(key => {
              // Trim both the key and value if they're strings
              const cleanKey = typeof key === 'string' ? key.trim() : key;
              const value = parish[key];
              const cleanValue = typeof value === 'string' ? value.trim() : value;
              cleanedParish[cleanKey] = cleanValue;
            });
            
            // Now use the cleaned parish object
            const processedParish = { ...cleanedParish };
            
            // Convert boolean string to actual boolean
            processedParish.IsHomePriest = processedParish.IsHomePriest === 'true';
            
            // Add GoogleMaps link
            processedParish.GoogleMaps = `https://maps.google.com/?q=${processedParish.Latitude},${processedParish.Longitude}`;
            
            // Convert string coordinates to numbers
            processedParish.Latitude = parseFloat(processedParish.Latitude);
            processedParish.Longitude = parseFloat(processedParish.Longitude);
            
            // Ensure MassTimes exists (might be empty in some cases)
            processedParish.MassTimes = processedParish.MassTimes || '';
            
            // Make sure PriestID is trimmed
            if (processedParish.PriestID) {
              processedParish.PriestID = processedParish.PriestID.trim();
            }
            
            // Make sure ParishID is trimmed
            if (processedParish.ParishID) {
              processedParish.ParishID = processedParish.ParishID.trim();
            }
            
            return processedParish;
          });
          
          console.log(`Loaded ${parishes.length} parishes`);
          console.log("Parish IDs:", parishes.map(p => `'${p.ParishID}'`).join(", "));
          console.log("Parish Priest IDs:", parishes.map(p => `'${p.PriestID}'`).join(", "));
          
          // Log parishes associated with each priest ID
          const priestParishes = {};
          parishes.forEach(parish => {
            if (!priestParishes[parish.PriestID]) {
              priestParishes[parish.PriestID] = [];
            }
            priestParishes[parish.PriestID].push(parish.ParishName);
          });
          
          console.log("Parishes by Priest ID:");
          Object.keys(priestParishes).forEach(priestID => {
            console.log(`Priest ID '${priestID}': ${priestParishes[priestID].join(", ")}`);
          });
        },
        error: (error) => {
          console.error('Error parsing parishes CSV:', error);
        }
      });
    }

    // Modify addGeoData to handle the priests with PriestID
    function addGeoData(priests) {
      return priests.map(priest => {
        // Use existing location data if available, otherwise assign new coordinates
        let lat, lng;
        
        switch(priest['Location/Area']) {
          case 'England':
            lat = 52.3555; lng = -1.1743;
            break;
          case 'USA':
            lat = 37.0902; lng = -95.7129;
            break;
          case 'France':
            lat = 46.2276; lng = 2.2137;
            break;
          case 'Brazil':
            lat = -14.2350; lng = -51.9253;
            break;
          case 'Italy/Ireland':
            lat = 41.8719; lng = 12.5674; // Using Italy
            break;
          case 'Poland':
            lat = 51.9194; lng = 19.1451;
            break;
          case 'Europe':
            lat = 48.8566; lng = 2.3522; // Using Paris as a European center
            break;
          case 'Austria':
            lat = 47.5162; lng = 14.5501;
            break;
          case 'Germany':
            lat = 51.1657; lng = 10.4515;
            break;
          default:
            // Random coordinates for unknown locations
            lat = parseFloat((Math.random() * 180 - 90).toFixed(4));
            lng = parseFloat((Math.random() * 360 - 180).toFixed(4));
        }
        
        return {
          ...priest,
          Latitude: lat,
          Longitude: lng,
          GoogleMaps: `https://maps.google.com/?q=${lat},${lng}`
        };
      });
    }

    function getPointOnGlobe(lat, lng, altitude = 0) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      // Use the earth radius directly from the EnhancedEarth instance
      // This ensures consistency between all objects
      const radius = enhancedEarth.earthRadius + altitude;
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }

    // Function to populate the globe with both priests and parishes
    function populateGlobeWithPriests() {
      if (!isGlobeReady) {
        console.log('Globe not ready yet, waiting...');
        setTimeout(populateGlobeWithPriests, 500);
        return;
      }
      
      // Clear existing markers
      const existingObjects = scene.children.filter(obj => 
        obj.name === 'priest-marker' || 
        obj.name === 'priest-pulse' || 
        obj.name === 'priest-marker-invisible' ||
        obj.name === 'parish-marker' ||
        obj.name === 'parish-line'
      );
      
      existingObjects.forEach(obj => scene.remove(obj));
      
      // Clear pulse meshes array
      pulseMeshes = [];
      
      // Add priest markers
      populateGlobeWithMarkers(priests);
      
      // Add parish markers
      addParishesToGlobe();
    }
    
    // Function to add parishes to the globe
    function addParishesToGlobe() {
  console.log(`Adding ${parishes.length} parishes to the globe`);
  
  parishes.forEach(parish => {
    // Get clean ID
    const parishID = parish.ParishID.trim();
    const priestID = parish.PriestID.trim();
    
    // Get coordinates
    const lat = parish.Latitude;
    const lng = parish.Longitude;
    
    // Calculate position on globe surface
    const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
    
    // Check if this parish is a home parish for its priest
    const isHomePriestParish = parish.IsHomePriest;
    console.log(`Parish: ${parish.ParishName} (ID: ${parishID}), PriestID: ${priestID}, IsHomePriest: ${isHomePriestParish}`);
    
    // Add parish marker (red dot) only if it's not a home parish
    // (home parishes will be represented by the priest's marker)
    if (!isHomePriestParish) {
      const markerGeometry = new THREE.SphereGeometry(CONFIG.parishMarkerSize, 16, 16);
      markerGeometry.computeVertexNormals(); // Ensure smooth normals
      
      const markerMaterial = new THREE.MeshPhongMaterial({ 
        color: CONFIG.parishMarkerColor,
        shininess: 0,
        flatShading: false
      });
      
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      
      // Set marker position
      marker.position.set(position.x, position.y, position.z);
      marker.name = 'parish-marker';
      marker.parishData = {
        ...parish,
        ParishID: parishID, // Ensure the data has the clean ID
        PriestID: priestID  // Ensure the data has the clean ID
      };
      
      // Add marker to scene
      scene.add(marker);
      console.log(`Added marker for parish: ${parish.ParishName} (${parishID})`);
    }
    
    // Find the priest for this parish
    const priest = priestMap.get(priestID);
    
    // If not home parish, add curved line to priest's home parish
    if (!isHomePriestParish && priest) {
      // Find this priest's home parish
      const homeParish = parishes.find(p => 
        p.PriestID.trim() === priestID && p.IsHomePriest
      );
      
      if (homeParish) {
        console.log(`Creating arc line from ${parish.ParishName} to ${homeParish.ParishName}`);
        
        // Calculate home parish position
        const homePosition = getPointOnGlobe(
          homeParish.Latitude, 
          homeParish.Longitude, 
          CONFIG.labelAltitude
        );
        
        // Create points for the arc - Use higher arc for better visibility
        const arcPoints = createArcPoints(
          position, 
          homePosition, 
          CONFIG.labelAltitude * 200.0 // Increased from 2 to 4 for higher arc
        );
        
        // Create a line geometry from the arc points
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
        
        const lineMaterial = new THREE.LineBasicMaterial({
          color: CONFIG.parishLineColor,
          lineWidth: CONFIG.parishLineWidth,
          transparent: true,
          opacity: 0.7
        });
        
        const line = new THREE.Line(lineGeometry, lineMaterial);
        line.name = 'parish-line';
        // Store references to connected parishes for easier highlighting
        line.parishStart = parishID;
        line.parishEnd = homeParish.ParishID.trim();
        line.priestID = priestID;
        
        // Add line to scene
        scene.add(line);
        console.log(`Added arc line for parishes of priest: ${priest.Name}`);
      } else {
        // If priest has no home parish, connect to priest's location
        console.log(`Creating arc line from ${parish.ParishName} to priest location for ${priest.Name} (no home parish)`);
        
        // Calculate priest position
        const priestPosition = getPointOnGlobe(
          priest.Latitude, 
          priest.Longitude, 
          CONFIG.labelAltitude
        );
        
        // Create points for the arc - Use higher arc for better visibility
        const arcPoints = createArcPoints(
          position, 
          priestPosition, 
          CONFIG.labelAltitude * 200.0 // Increased from 2 to 4 for higher arc
        );
        
        // Create a line geometry from the arc points
        const lineGeometry = new THREE.BufferGeometry().setFromPoints(arcPoints);
        
        const lineMaterial = new THREE.LineBasicMaterial({
          color: CONFIG.parishLineColor,
          linewidth: CONFIG.parishLineWidth,
          transparent: true,
          opacity: 0.7
        });
        
        const line = new THREE.Line(lineGeometry, lineMaterial);
        line.name = 'parish-line';
        // Store references to connected parishes for easier highlighting
        line.parishStart = parishID;
        line.priestID = priestID;
        
        // Add line to scene
        scene.add(line);
        console.log(`Added arc line from parish to priest location: ${priest.Name}`);
      }
    }
    
    // Add invisible larger detection sphere for better interaction
    const invisibleSphereGeometry = new THREE.SphereGeometry(CONFIG.parishMarkerSize * 2, 16, 16);
    const invisibleSphereMaterial = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
    });
    
    const invisibleSphere = new THREE.Mesh(invisibleSphereGeometry, invisibleSphereMaterial);
    
    // Position at same coordinates as marker
    invisibleSphere.position.set(position.x, position.y, position.z);
    invisibleSphere.name = 'parish-marker-invisible';
    invisibleSphere.parishData = {
      ...parish,
      ParishID: parishID, // Ensure the data has the clean ID
      PriestID: priestID  // Ensure the data has the clean ID
    };
    
    // Add to scene
    scene.add(invisibleSphere);
  });
}

    function synchronizePriestLocations() {
      console.log("Starting priest location synchronization");
      
      // For each priest
      priests.forEach(priest => {
        // Make sure we're working with a clean priest ID
        const priestID = priest.PriestID.trim();
        
        // Find the home parish for this priest
        const homeParish = parishes.find(parish => 
          parish.PriestID.trim() === priestID && parish.IsHomePriest === true
        );
        
        // If the priest has a home parish, update their location
        if (homeParish) {
          console.log(`Updating location for ${priest.Name} (ID: ${priestID}) to match home parish ${homeParish.ParishName} at ${homeParish.Latitude}, ${homeParish.Longitude}`);
          priest.Latitude = homeParish.Latitude;
          priest.Longitude = homeParish.Longitude;
          priest.GoogleMaps = `https://maps.google.com/?q=${homeParish.Latitude},${homeParish.Longitude}`;
        } else {
          console.log(`Priest ${priest.Name} (ID: ${priestID}) has no home parish, keeping original location`);
          // List parishes for this priest
          const priestParishes = parishes.filter(p => p.PriestID.trim() === priestID);
          if (priestParishes.length > 0) {
            console.log(`  Parishes for ${priest.Name}:`);
            priestParishes.forEach(p => console.log(`  - ${p.ParishName} (Home: ${p.IsHomePriest})`));
          } else {
            console.log(`  No parishes found for ${priest.Name}`);
          }
        }
      });
    }


    function createArcPoints(startPos, endPos, maxHeight) {
  const numPoints = 100; // Number of points for the arc line
  const points = [];
  
  // Calculate vector from start to end
  const direction = new THREE.Vector3().subVectors(endPos, startPos);
  const distance = direction.length();
  
  // Create midpoint for the arc
  const midpoint = new THREE.Vector3().addVectors(startPos, endPos).multiplyScalar(0.5);
  const midpointLength = midpoint.length();
  
  // Calculate the angle between points (in radians)
  const angle = startPos.angleTo(endPos);
  
  // Adjust maxHeight based on the angle between points to prevent clipping
  // For points that are further apart, we need higher arcs
  const dynamicHeight = maxHeight * (1 + Math.sin(angle * 0.5) * 5);
  
  // Make sure our arc always goes outward from the globe center
  midpoint.normalize().multiplyScalar(midpointLength + dynamicHeight);
  
  // Create arc using quadratic Bezier curve
  for (let i = 0; i <= numPoints; i++) {
    const t = i / numPoints;
    
    // Quadratic Bezier: (1-t)^2 * P0 + 2(1-t)t * P1 + t^2 * P2
    const point = new THREE.Vector3();
    
    // First term: (1-t)^2 * P0
    point.copy(startPos).multiplyScalar(Math.pow(1 - t, 2));
    
    // Second term: 2(1-t)t * P1
    const midPointTerm = new THREE.Vector3().copy(midpoint).multiplyScalar(2 * (1 - t) * t);
    point.add(midPointTerm);
    
    // Third term: t^2 * P2
    const endPointTerm = new THREE.Vector3().copy(endPos).multiplyScalar(t * t);
    point.add(endPointTerm);
    
    points.push(point);
  }
  
  return points;
}

    // Populate the globe with markers and pulse rings
    function populateGlobeWithMarkers(data) {
      if (!globe) return;
      
      // Clear any existing markers
      const existingMarkers = scene.children.filter(obj => 
        obj.name === 'priest-marker' || obj.name === 'priest-pulse' || obj.name === 'priest-marker-invisible'
      );
      existingMarkers.forEach(marker => scene.remove(marker));
      
      // Clear pulse meshes array
      pulseMeshes = [];
      
      // Create markers for each priest
      data.forEach(priest => {
        // Get coordinates
        const lat = priest.Latitude;
        const lng = priest.Longitude;
        
        // Calculate position on globe surface
        const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
        
        // Add dot marker with smooth shading
        const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
        markerGeometry.computeVertexNormals(); // Ensure smooth normals
        
        const markerMaterial = new THREE.MeshPhongMaterial({ 
          color: CONFIG.markerColor,
          shininess: 0,
          flatShading: false
        });
        
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        
        // Set marker position
        marker.position.set(position.x, position.y, position.z);
        marker.name = 'priest-marker';
        marker.priestData = priest;
        
        // Add marker to scene
        scene.add(marker);
        
        // === REPLACED RING WITH SQUISHED SPHERE ===
        // Add pulsating squished sphere around marker
        const pulseGeometry = new THREE.SphereGeometry(CONFIG.markerRingSize, 32, 32);
        const pulseMaterial = new THREE.MeshBasicMaterial({
          color: CONFIG.markerPulseColor,
          transparent: true,
          opacity: 0.9,
          side: THREE.DoubleSide
        });
        
        const pulseMesh = new THREE.Mesh(pulseGeometry, pulseMaterial);
        // Make it a squished sphere by scaling down the y-axis
        pulseMesh.scale.y = 0.25; // Adjust this value to control how squished it is
        
        // Create a group to contain the pulse mesh
        const pulse = new THREE.Group();
        pulse.add(pulseMesh);
        
        // Position pulse at the same coordinates as marker
        pulse.position.set(position.x, position.y, position.z);
        pulse.lookAt(0, 0, 0); // Orient properly toward center
        pulse.name = 'priest-pulse';
        pulse.priestData = priest;
        
        // Add random offset for animation
        pulseMesh.pulseOffset = 0.0;
        
        // Add to pulse meshes array for animation
        pulseMeshes.push(pulseMesh);
        
        // Add pulse to scene
        scene.add(pulse);
        
        // Add invisible larger detection sphere for better interaction
        const invisibleSphereGeometry = new THREE.SphereGeometry(CONFIG.markerRingSize * 1.5, 16, 16);
        const invisibleSphereMaterial = new THREE.MeshBasicMaterial({
          transparent: true,
          opacity: 0.0,
        });
        
        const invisibleSphere = new THREE.Mesh(invisibleSphereGeometry, invisibleSphereMaterial);
        
        // Position at same coordinates as marker
        invisibleSphere.position.set(position.x, position.y, position.z);
        invisibleSphere.name = 'priest-marker-invisible';
        invisibleSphere.priestData = priest;
        
        // Add to scene
        scene.add(invisibleSphere);
      });
    }

    // Show priest info in the panel
    function showPriestInfo(priest) {
      const infoPanel = document.getElementById('infoPanel');
      const priestName = document.getElementById('priestName');
      const priestInfo = document.getElementById('priestInfo');
      
      // Get translated title based on priest type
      let title;
      switch(priest.Type) {
        case "Bishop":
          title = getTranslatedText('TITLE_BISHOP');
          break;
        case "Father":
          title = getTranslatedText('TITLE_FATHER');
          break;
        case "Sister":
          title = getTranslatedText('TITLE_SISTER');
          break;
        case "Mother":
          title = getTranslatedText('TITLE_MOTHER');
          break;
        case "Brother":
          title = getTranslatedText('TITLE_BROTHER');
          break;
        default:
          title = "";
      }
      
      // Get name parts for formatted display
      let lastName = priest.Name.split(' ').pop();
      let firstInitial = priest.Name.charAt(0);
      
      // Set priest name with title
      priestName.textContent = `${title} ${firstInitial}. ${lastName}`;
      
      // Clear previous info
      priestInfo.innerHTML = '';
      
      // Create first paragraph: biographical info
      const bioParagraph = document.createElement('p');
      bioParagraph.className = 'info-paragraph';
      let bioText = '';
      
      // Born year
      if (priest['Born Year']) {
        bioText += `${getTranslatedText('BORN')} ${priest['Born Year']}, `;
      }
      
      // Ordination info
      if (priest['Ordained in Rite'] || priest['Ordained By']) {
        bioText += `${getTranslatedText('ORDAINED_PRIEST_IN')} `;
        if (priest['Ordained in Rite']) {
          bioText += priest['Ordained in Rite'] + ' ';
        }
        if (priest['Ordained By']) {
          bioText += `${getTranslatedText('BY')} ${priest['Ordained By']}, `;
        } else {
          bioText += ', ';
        }
      }
      
      // Consecration info (for bishops)
      if (priest.Type === "Bishop" && (priest['Consecrated in Rite'] || priest['Consecrated By'])) {
        bioText += `${getTranslatedText('CONSECRATED_BISHOP_IN')} `;
        if (priest['Consecrated in Rite']) {
          bioText += priest['Consecrated in Rite'] + ' ';
        }
        if (priest['Consecrated By']) {
          bioText += `${getTranslatedText('BY')} ${priest['Consecrated By']} `;
        }
        
        // Bishop line
        if (priest['Bishop Line']) {
          bioText += `(${getTranslatedText('BISHOP_LINE')}: ${priest['Bishop Line']})`;
        }
        bioText += '. ';
      } else if (bioText) {
        // End the sentence if it's not empty and not a bishop
        bioText = bioText.replace(/, $/, '. ');
      }
      
      // Location
      if (priest['Location/Area']) {
        bioText += `${getTranslatedText('OPERATES_IN')} ${priest['Location/Area']}`;
      }
      
      // Associates With
      if (priest['Associates With']) {
        if (bioText) bioText += ', ';
        bioText += `${getTranslatedText('ASSOCIATES_WITH')} ${priest['Associates With']}`;
      }
      
      // Beliefs
      if (priest['Beliefs']) {
        if (bioText) bioText += ', ';
        bioText += `${getTranslatedText('HOLDS_BELIEFS')} ${priest['Beliefs']} ${getTranslatedText('BELIEFS')}`;
      }

      // Notes section
      if (priest['Notes']) {
        if (bioText) {
          // End the sentence if it's not empty
          bioText += ".\n";
        }

        bioText += priest['Notes'];
      }

      // Only add the paragraph if we have bio info
      if (bioText) {
        bioText += '. ';
        bioParagraph.textContent = bioText;
        priestInfo.appendChild(bioParagraph);
      }

      // Contact/Website as a clickable link if present
      if (priest['Contact/Website']) {
        const contactRow = document.createElement('p');
        contactRow.className = 'info-paragraph';
        
        if (priest['Contact/Website'].startsWith('http')) {
          let niceurl = priest['Contact/Website'].replace(/^https?:\/\//, "");
          contactRow.innerHTML = `${getTranslatedText('WEBSITE')}: <a href="${priest['Contact/Website']}" target="_blank" class="info-link">${niceurl}</a>`;
        } else {
          contactRow.innerHTML = `${getTranslatedText('CONTACT')}: ${priest['Contact/Website']}`;
        }
        
        priestInfo.appendChild(contactRow);
      }

      // Add parishes served section with mass times
      // Use trimmed priest ID
      const priestID = priest.PriestID.trim();
      console.log(`Looking for parishes with PriestID: '${priestID}'`);
      
      const priestParishes = parishes.filter(parish => parish.PriestID.trim() === priestID);
      console.log(`Found ${priestParishes.length} parishes for ${priest.Name}: ${priestParishes.map(p => p.ParishName).join(', ')}`);
      
      if (priestParishes.length > 0) {
        const parishesSection = document.createElement('div');
        parishesSection.className = 'parishes-section';
        
        // Add section title
        const parishesTitle = document.createElement('h3');
        parishesTitle.textContent = getTranslatedText('PARISHES_SERVED');
        parishesSection.appendChild(parishesTitle);
        
        const parishesList = document.createElement('ul');
        parishesList.className = 'parishes-list';
        
        // Sort parishes with home parish first, then alphabetically
        priestParishes.sort((a, b) => {
          if (a.IsHomePriest && !b.IsHomePriest) return -1;
          if (!a.IsHomePriest && b.IsHomePriest) return 1;
          return a.ParishName.localeCompare(b.ParishName);
        });
        
        priestParishes.forEach(parish => {
          const parishitem = document.createElement('li');
          parishitem.className = 'parish-item';
          
          const homeIndicator = parish.IsHomePriest ? getTranslatedText('HOME_PARISH') : '';
          parishitem.innerHTML = `<strong>${parish.ParishName}${homeIndicator}:</strong> ${parish.MassTimes || getTranslatedText('NO_SCHEDULED_MASSES')}`;
          
          // Add click handler to highlight this parish
          parishitem.style.cursor = 'pointer';
          parishitem.addEventListener('click', () => {
            showParishInfo(parish);
            highlightSelectedParish(parish);
            focusOnPoint(parish.Latitude, parish.Longitude, 250.0);
          });
          
          parishesList.appendChild(parishitem);
        });
        
        parishesSection.appendChild(parishesList);
        priestInfo.appendChild(parishesSection);
      }
      
      // Add Google Maps link
      const mapsRow = document.createElement('div');
      mapsRow.className = 'info-row';
      mapsRow.innerHTML = `<a href="${priest.GoogleMaps}" target="_blank" class="info-link maps">${getTranslatedText('VIEW_ON_MAPS')}</a>`;
      priestInfo.appendChild(mapsRow);
      
      // Show the info panel
      infoPanel.style.display = 'block';
    }

    // Handle search input
    function handleSearch(event) {
      const searchTerm = event.target.value.toLowerCase();
      const searchResultsContainer = document.getElementById('searchResults');
      
      // Reset search results
      searchResultsContainer.innerHTML = '';
      searchResults = [];
      selectedSearchIndex = -1;
      
      if (searchTerm.length < 1) {
        resetSearchResultsContainer();
        resetAllMarkers();
        return;
      }
      
      // Filter priests based on search term
      const matchingPriests = priests.filter(priest => 
        priest.Name.toLowerCase().includes(searchTerm) || 
        (priest['Location/Area'] && priest['Location/Area'].toLowerCase().includes(searchTerm))
      ).map(priest => ({ data: priest, type: 'priest' }));
      
      // Filter parishes based on search term
      const matchingParishes = parishes.filter(parish => 
        parish.ParishName.toLowerCase().includes(searchTerm) ||
        (parish.Notes && parish.Notes.toLowerCase().includes(searchTerm))
      ).map(parish => ({ data: parish, type: 'parish' }));
      
      // Combine the results
      const combinedResults = [...matchingPriests, ...matchingParishes];
      
      // Update searchResults array with just the data
      searchResults = combinedResults.map(item => item.data);
      
      // Highlight matching markers
      if (combinedResults.length > 0) {
        // Reset all markers first
        resetAllMarkers();
        
        // Highlight priest markers
        matchingPriests.forEach(item => {
          scene.children
            .filter(obj => obj.name === 'priest-marker' && obj.priestData && obj.priestData.Name === item.data.Name)
            .forEach(marker => {
              marker.material.color.set('yellow');
            });
        });
        
        // Highlight parish markers
        matchingParishes.forEach(item => {
          scene.children
            .filter(obj => obj.name === 'parish-marker' && obj.parishData && obj.parishData.ParishID === item.data.ParishID)
            .forEach(marker => {
              marker.material.color.set('yellow');
            });
        });
        
        // Populate search results dropdown
        combinedResults.forEach((item, i) => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result-item';
          resultItem.tabIndex = i + 200;
          
          if (item.type === 'priest') {
            resultItem.textContent = `${item.data.Name} (${item.data['Location/Area'] || 'Unknown'})`;
          } else {
            resultItem.textContent = `${item.data.ParishName} (Parish)`;
          }
          
          resultItem.addEventListener('click', () => {
            if (item.type === 'priest') {
              showPriestInfo(item.data);
              highlightSelectedPriest(item.data);
            } else {
              showParishInfo(item.data);
              highlightSelectedParish(item.data);
            }
            focusOnPoint(item.data.Latitude, item.data.Longitude, 250.0);
            resetSearchResultsContainer();
            document.getElementById('searchInput').value = '';
          });
          
          resultItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
              e.preventDefault();
              resultItem.click();
            }
          });
          
          searchResultsContainer.appendChild(resultItem);
        });
        
        searchResultsContainer.style.display = 'block';
      } else {
        resetSearchResultsContainer();
      }
    }

    function clearSearchResults(searchResultsContainer) {
        resetSearchResultsContainer();
        // Clear search input
        document.getElementById('searchInput').value = '';
    }

    function clickSearchResult(priest, searchResultsContainer) {
        // Show info panel
        showPriestInfo(priest);
        
        // Focus on the point
        focusOnPoint(priest.Latitude, priest.Longitude, 250.0);
        
        // Reset markers color
        markers.forEach(marker => {
            marker.material.color.set(CONFIG.markerColor);
        });
    }

    // Focus camera on a specific point
    function focusOnPoint(lat, lng, zoomLevel = CONFIG.minDistance) {
      // Calculate target position for the globe point
      const targetPosition = getPointOnGlobe(lat - 5, lng, 2);
      
      // Normalized direction vector
      const direction = new THREE.Vector3();
      direction.subVectors(targetPosition, new THREE.Vector3(0, 0, 0)).normalize();
      
      // Get current distance from camera to center
      const currentDistance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
      
      // Calculate target distance
      const targetDistance = Math.max(
        CONFIG.minDistance,
        Math.min(controls.maxDistance, currentDistance * (zoomLevel / CONFIG.currentZoomLevel))
      );
      CONFIG.currentZoomLevel = zoomLevel;

      // Calculate new camera position
      const newPosition = direction.multiplyScalar(targetDistance);
      
      // Calculate new lookAt target based on target distance
      const newTarget = calculateLookAtTarget(targetDistance);
      
      // Animate camera move
      const startPosition = camera.position.clone();
      const startTarget = controls.target.clone();
      const startTime = Date.now();
      
      function animateCamera() {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / CONFIG.focusAnimationDuration, 1);
        
        // Easing function (ease-out)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPosition, newPosition, easeProgress);
        
        // Interpolate target
        controls.target.lerpVectors(startTarget, newTarget, easeProgress);
        
        // Update controls
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        } else {
          // Animation complete
          controls.update();
        }
      }
      
      // Start animation
      animateCamera();
    }


    // Initialize the application
    init();
  </script>
</body>
</html>
