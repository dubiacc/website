<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Catholic Resistance Globe</title>
  <link href="https://fonts.googleapis.com/css2?family=UnifrakturMaguntia&display=swap" rel="stylesheet">
  <script src="https://unpkg.com/three@0.137.0/build/three.min.js"></script>
  <script src="https://unpkg.com/three-globe@2.24.4/dist/three-globe.min.js"></script>
  <script src="https://unpkg.com/three@0.137.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://unpkg.com/papaparse@5.3.0/papaparse.min.js"></script>
  <style>
    :root {
      --background-color: #f5f5f5;
      --text-color: #333;
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-text: #333;
      --atmospheric-color: #ccc;
      --search-bg: white;
      --search-text: #333;
      --search-placeholder: #999;
      --search-results-bg: white;
      --search-results-hover: #f0f0f0;
      --link-color: #8b0000;
      --focus-col: rgb(61, 99, 170);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #121212;
        --text-color: #f5f5f5;
        --panel-bg: rgba(33, 33, 33, 0.95);
        --panel-text: #f5f5f5;
        --atmospheric-color: #3a228a;
        --search-bg: #333;
        --search-text: #f5f5f5;
        --search-placeholder: #777;
        --search-results-bg: #333;
        --search-results-hover: #444;
        --link-color: #ff6b6b;
      }
    }
    
    * {
        margin: 0px;
        padding: 0px;
    }

    html {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background-color);
      font-family: Arial, sans-serif;
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      height: 100%;
    }
    
    #globeContainer {
        position: absolute;
        height: 100%;
        width: 100%;
    }
    
    .title {
        mix-blend-mode: difference;
        width: 100%;
        text-align: center;
        font-family: 'UnifrakturMaguntia', serif;
        font-size: 5rem;
        color: #ffffff;
        z-index: 10;
        margin: 2rem 0px;
    }
    
    .search-container {
        display: flex;
        justify-content: space-between;
        flex-direction: column;
        pointer-events: none;
        z-index: 10;
        flex-grow: 1;
        max-width: 500px;
        width: 100%;
    }

    #priestInfo {
        display: flex;
        flex-direction: column;
    }

    .search-input {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        padding: 10px;
        font-style: italic;
        border: none;
        background: var(--search-bg);
        color: var(--search-text);
        font-size: 1.5rem;
        outline: none;
        border: 3px solid var(--search-bg);
        pointer-events: all;
        margin-left: 10px;
        margin-right: 10px;
    }
    
    .search-input:focus {
        border: 3px solid var(--focus-col);
    }

    .search-input::placeholder {
      color: var(--search-placeholder);
    }
    
    .search-results {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        font-style: italic;
        overflow-y: scroll;
        background: var(--search-results-bg);
        border-radius: 0 0 5px 5px;
        z-index: 11;
        display: none;
        pointer-events: all;
        margin-left: 10px;
        margin-right: 10px;
        max-height: 200px;
        overflow-y: scroll;
    }
    
    .search-result-item {
      padding: 10px;
      cursor: pointer;
      transition: background-color 0.2s;
      border: 3px solid transparent;
      font-size: 1.5rem;
    }
    
    .search-result-item:focus {
        border: 3px solid var(--focus-col);
        background-color: var(--search-results-hover);
    }

    .info-panel {
        margin-left: 10px;
        margin-right: 10px;
        margin-bottom: 10px;
        box-shadow: 2.5px 2.5px 5px black;
        pointer-events: all;
        position: relative;
        background: white;
        padding: 20px;
        max-height: 70vh;
        overflow-y: auto;
        z-index: 10;
        display: none;
        background: var(--panel-bg);
        color: var(--panel-text);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        font-family: 'Times';
        font-style: italic;
    }
    
    .info-panel h2 {
        margin-top: 0;
        margin-bottom: 21px;
        font-size: 2rem;
        text-transform: uppercase;
        font-weight: bold;
    }
    
    .info-row {
        margin-bottom: 4px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
    }
    
    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        background: #cc0000;
        font-size: 2rem;
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    
    .info-link {
        background: #700000;
        color: white;
        padding: 10px;
        font-weight: bold;
        font-style: normal;
        font-family: sans-serif;
        margin-top: 1rem;
        text-decoration: none;
    }
    
    .info-link:hover {
      text-decoration: underline;
    }
    
    @media (max-width: 600px) {
      .title {
        font-size: 3.5rem;
      }
      
      .info-panel {
        max-height: 60vh;
      }
    }
  </style>
</head>
<body>

  <h1 class="title">Catholic Resistance</h1>

  <div class="search-container">
    <div style="display: flex; flex-direction: column;">
        <input autofocus="true" type="text" class="search-input" placeholder="Search by name or location..." id="searchInput">
        <div class="search-results" id="searchResults"></div>
    </div>

    <div class="info-panel" id="infoPanel">
        <button class="close-btn" id="closeBtn">Ã—</button>
        <h2 id="priestName"></h2>
        <div id="priestInfo"></div>
      </div>
  </div>
  
  <div id="globeContainer"></div>

  <script>
    // Configuration - Change these values to configure the application
    const CONFIG = {
      currentZoomLevel: 400.0,
      dataUrl: null, // Set to CSV URL or null to use the default data
      fieldOrder: [
        'Type', 'Born Year', 'Associates With', 'Beliefs', 'Location/Area',
        'Contact/Website', 'Ordained in Rite', 'Ordained By', 'Consecrated in Rite',
        'Consecrated By', 'Bishop Line', 'Notes'
      ],
      markerColor: '#ff0000',
      markerPulseColor: 'rgba(255, 0, 0, 0.4)',
      markerSize: 1.0,
      markerRingSize: 1.8,
      labelAltitude: 0.001,
      autoRotate: false,
      autoRotateSpeed: 0.1,
      theme: 'light', // 'light', 'dark', or null for system preference
      focusAnimationDuration: 2000, // ms to animate to a point
      focusDistanceFactor: 0.4, // distance factor when focusing on a point (lower = closer)
      cloudOpacity: 0.8, // Add this line for cloud opacity
      cloudBrightness: 1.2 // Add this line for cloud brightness
    };

    // Global variables
    let renderer, scene, camera, controls, globe;
    let priests = [];
    let selectedPoint = null;
    let isGlobeReady = false;
    let raycaster, mouse;
    let dayNightMaterial;
    let currentTheme = getTheme();
    let pulseMeshes = [];
    let searchResults = [];
    let selectedSearchIndex = -1;
    let enhancedEarth = null;
    
    // Language mapping and geography functions
    const languageLatitudeMap = {
      // Top languages by number of speakers + European languages + CJK + Filipino
      "zh": 35.0, // Chinese (Mandarin)
      "es": 40.0, // Spanish - Spain (will adjust based on longitude)
      "en": 51.0, // English - UK (will adjust based on longitude)
      "hi": 20.0, // Hindi - Northern India
      "ar": 25.0, // Arabic - Arabian Peninsula
      "pt": -10.0, // Portuguese - Brazil (will adjust based on longitude)
      "bn": 23.0, // Bengali - Bangladesh/East India
      "ru": 55.0, // Russian
      "ja": 36.0, // Japanese
      "pa": 30.0, // Punjabi
      "de": 51.0, // German
      "jv": -7.5, // Javanese
      "ko": 37.5, // Korean
      "fr": 46.0, // French (will adjust based on longitude)
      "te": 16.0, // Telugu
      "mr": 18.0, // Marathi
      "tr": 39.0, // Turkish
      "ta": 11.0, // Tamil
      "vi": 16.0, // Vietnamese
      "ur": 30.0, // Urdu
      "it": 42.0, // Italian
      "th": 15.0, // Thai
      "gu": 22.0, // Gujarati
      "pl": 52.0, // Polish
      "uk": 49.0, // Ukrainian
      "fa": 32.0, // Persian
      "ro": 46.0, // Romanian
      "nl": 52.0, // Dutch
      "fil": 14.0, // Filipino
      "sv": 60.0, // Swedish
      "cs": 50.0, // Czech
      "hu": 47.0, // Hungarian
      "el": 38.0, // Greek
      "da": 56.0, // Danish
      "fi": 62.0, // Finnish
      "no": 60.0, // Norwegian
      "bg": 42.0, // Bulgarian
      "hr": 45.0, // Croatian
      "sk": 48.0, // Slovak
      "sr": 44.0, // Serbian
      "lt": 55.0, // Lithuanian
      "lv": 57.0, // Latvian
      "et": 59.0, // Estonian
      "sl": 46.0, // Slovenian
      "is": 65.0, // Icelandic
      "ca": 41.0, // Catalan
      "eu": 43.0, // Basque
      "ga": 53.0, // Irish
      "gl": 42.0, // Galician
      "cy": 52.0, // Welsh
      "gd": 57.0, // Scottish Gaelic
      "be": 53.0, // Belarusian
      "mk": 41.5, // Macedonian
      "sq": 41.0, // Albanian
      "mt": 35.9, // Maltese
      "id": -0.8, // Indonesian
      "ms": 2.5,  // Malay
      "sw": -6.0, // Swahili
      "am": 9.0,  // Amharic
      "yo": 7.5,  // Yoruba
      "zu": -29.0, // Zulu
      "xh": -33.0, // Xhosa
      "he": 31.0, // Hebrew
      "tl": 14.6  // Tagalog
    };

    // Define language longitude ranges for geographic consistency check
    function languageLongitudeRanges() {
      return {
      "en": [
        { min: -170, max: -30, lat: 40.0 },    // North America
        { min: -30, max: 30, lat: 51.0 },      // UK
        { min: 30, max: 100, lat: 20.0 },      // South Asia (India)
        { min: 100, max: 180, lat: -25.0 }     // Australia/NZ
      ],
      "es": [
        { min: -120, max: -30, lat: 15.0 },    // Latin America
        { min: -30, max: 30, lat: 40.0 }       // Spain
      ],
      "pt": [
        { min: -120, max: -30, lat: -10.0 },   // Brazil
        { min: -30, max: 30, lat: 39.0 }       // Portugal
      ],
      "fr": [
        { min: -120, max: -30, lat: 45.0 },    // Quebec/Canada
        { min: -30, max: 30, lat: 46.0 },      // France
        { min: 0, max: 50, lat: 14.0 }         // Francophone Africa
      ],
      "ar": [
        { min: -30, max: 0, lat: 30.0 },       // North Africa
        { min: 0, max: 60, lat: 25.0 }         // Middle East
      ],
      "zh": [
        { min: 70, max: 140, lat: 35.0 }       // China
      ],
      "hi": [
        { min: 60, max: 100, lat: 20.0 }       // India
      ],
      "ru": [
        { min: 20, max: 180, lat: 55.0 }       // Russia
      ],
      "ja": [
        { min: 120, max: 150, lat: 36.0 }      // Japan
      ],
      "ko": [
        { min: 120, max: 135, lat: 37.5 }      // Korea
      ]
    };
  }
    
    // Language-based latitude estimation with geographical consistency check
    function estimateLatitude(longitude) {
      const languages = getBrowserLanguages();
      let bestLat = null;
      const llr = languageLongitudeRanges();

      // First try to find a geographically consistent language
      for (const language of languages) {
        const langCode = getLanguageCode(language);
        
        // Check if this language has specific longitude ranges defined
        if (llr[langCode]) {
          for (const range of llr[langCode]) {
            // Check if the detected longitude falls within this language's expected range
            if (longitude >= range.min && longitude <= range.max) {
              console.log(`Found matching language ${langCode} for longitude ${longitude}, using latitude ${range.lat}`);
              return range.lat;
            }
          }
        }
      }
      
      // If no geographically consistent language found, try the general language map
      for (const language of languages) {
        const langCode = getLanguageCode(language);
        if (languageLatitudeMap[langCode]) {
          bestLat = languageLatitudeMap[langCode];
          break;
        }
      }
      
      // Fall back to hemisphere estimation based on longitude if no language match
      if (bestLat === null) {
        // Most populated areas are in Northern hemisphere
        bestLat = 20.0;
        
        // Special case for southern hemisphere longitudes (South America, Australia, etc.)
        if ((longitude > -120 && longitude < -30) || (longitude > 100 && longitude < 180)) {
          bestLat = -20.0;
        }
      }
      
      return bestLat;
    }

    // Get all browser languages
    function getBrowserLanguages() {
      if (navigator.languages && navigator.languages.length) {
        return Array.from(navigator.languages);
      }
      return [navigator.language || navigator.userLanguage || 'en'];
    }

    // Extract language code from full locale string
    function getLanguageCode(locale) { 
      console.log(locale);
      return locale.split('-')[0].toLowerCase(); 
    }

    // 7. Improved click detection to prevent clicking through the globe
    function isPointOnFrontSide(hitPoint, camera) {
      // Vector from camera to hit point
      const cameraToHit = new THREE.Vector3().subVectors(hitPoint, camera.position);
      
      // Vector from camera to globe center
      const cameraToCenter = new THREE.Vector3().subVectors(new THREE.Vector3(0, 0, 0), camera.position);
      
      // If dot product is positive, the hit is on back side
      return cameraToHit.dot(cameraToCenter) <= 0;
    }

    // Calculate solar position with accurate Earth tilt
    function calculateSolarPosition(dt) {
      // Day of year (0-365)
      const start = new Date(dt.getUTCFullYear(), 0, 0);
      const diff = dt - start;
      const dayOfYear = Math.floor(diff / (1000 * 60 * 60 * 24));
      
      // Convert to radians for the calculations
      const dayAngle = 2 * Math.PI * dayOfYear / 365.25;
      
      // Axial tilt calculation (more accurate declination angle)
      // Uses astronomical formula with the obliquity of the ecliptic
      const declination = 0.4093 * Math.sin(dayAngle - 1.405);
      
      // Equation of time (difference between solar time and mean time)
      const eqTime = 229.18 * (0.000075 + 0.001868 * Math.cos(dayAngle) 
                - 0.032077 * Math.sin(dayAngle) 
                - 0.014615 * Math.cos(2 * dayAngle) 
                - 0.040849 * Math.sin(2 * dayAngle));
      
      // Calculate solar hour angle
      const hour = dt.getUTCHours();
      const minutes = dt.getUTCMinutes();
      const seconds = dt.getUTCSeconds();
      const totalSeconds = hour * 3600 + minutes * 60 + seconds;
      
      // Convert to longitude (-180 to 180)
      const longitude = (totalSeconds / 86400) * 360 - 180;
      
      // Adjust for equation of time
      const adjustedLongitude = longitude + eqTime / 60 * 15;
      
      // Convert declination from radians to degrees
      const declinationDegrees = declination * (180 / Math.PI);
      
      return [adjustedLongitude, declinationDegrees];
    }

    // Add a blue marker for user location
    function addUserLocationMarker(lat, lng) {
      // Remove any existing user location marker
      const existingMarker = scene.getObjectByName('user-location');
      if (existingMarker) {
        scene.remove(existingMarker);
      }
      
      // Create blue marker geometry
      const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
      const markerMaterial = new THREE.MeshBasicMaterial({ color: '#0066ff' });
      const marker = new THREE.Mesh(markerGeometry, markerMaterial);
      
      // Set marker position
      const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
      marker.position.set(position.x, position.y, position.z);
      marker.name = 'user-location';
      
      // Add to scene
      scene.add(marker);
    }

    function centerOnTimezone() {
      // Get local timezone offset in minutes
      const timezoneOffsetMinutes = new Date().getTimezoneOffset();
      
      // Convert to hours (negative because getTimezoneOffset returns difference from UTC)
      const timezoneOffsetHours = -timezoneOffsetMinutes / 60;
      
      // Calculate approximate longitude (15 degrees per hour)
      const approximateLongitude = timezoneOffsetHours * 15;
      
      // Get browser languages and estimate latitude based on geographical consistency
      const estimatedLatitude = estimateLatitude(approximateLongitude);
      
      console.log(`Browser languages: ${getBrowserLanguages().join(', ')}, approximate longitude: ${approximateLongitude}, estimated latitude: ${estimatedLatitude}`);
      
      // Center globe on this position
      focusOnPoint(estimatedLatitude, approximateLongitude);
    }

    function showProximitySearchResults(results) {
        const searchResultsContainer = document.getElementById('searchResults');
        const searchInput = document.getElementById('searchInput');
        
        // Clear previous results
        searchResultsContainer.innerHTML = '';
        searchResults = [];
        selectedSearchIndex = -1;
        
        // Add results to global searchResults array
        searchResults = results.map(result => result.priestData);
        
        // Create result items
        results.forEach((result, i) => {
            const priest = result.priestData;
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            resultItem.tabIndex = i + 200;
            resultItem.textContent = `${priest.Name} (${priest['Location/Area'] || 'Unknown'})`;
            
            resultItem.addEventListener('click', () => {
            showPriestInfo(priest);
            focusOnPoint(priest.Latitude, priest.Longitude);
            highlightSelectedPriest(priest);
            searchResultsContainer.style.display = 'none';
            });
            
            resultItem.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                resultItem.click();
            }
            });
            
            searchResultsContainer.appendChild(resultItem);
        });
        
        // Display results
        searchResultsContainer.style.display = 'block';
    }

    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          // Success callback
          (position) => {
            const userLat = position.coords.latitude;
            const userLng = position.coords.longitude;
            
            // Add a blue marker for user location
            addUserLocationMarker(userLat, userLng);
            
            // Center globe on user location
            focusOnPoint(userLat, userLng);
          },
          // Error callback
          (error) => {
            console.log('Geolocation error:', error);
            // Center on timezone if location isn't available
            centerOnTimezone();
          }
        );
      } else {
        // Geolocation not supported
        console.log('Geolocation not supported by this browser');
        centerOnTimezone();
      }
    }

    // Adjust rotation speed based on zoom level - slower when zoomed in
    function adjustRotationSpeed() {
      const distance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
      const zoomRange = controls.maxDistance - controls.minDistance;
      const zoomFactor = (distance - controls.minDistance) / zoomRange;
      
      const minSpeed = 0.2; // Min rotation speed when fully zoomed in
      const maxSpeed = 1.0; // Max rotation speed when zoomed out
      
      controls.rotateSpeed = minSpeed + zoomFactor * (maxSpeed - minSpeed);
    }

    async function initEnhancedGlobe() {
      // Create new Earth object
      enhancedEarth = new EnhancedEarth(scene, camera);
      
      // Set cloud options from CONFIG
      enhancedEarth.options.cloudOpacity = CONFIG.cloudOpacity;
      enhancedEarth.options.cloudBrightness = CONFIG.cloudBrightness;
      
      await enhancedEarth.init();
      
      // Set the globe reference to the earth mesh for compatibility
      globe = enhancedEarth.getEarthMesh();
      isGlobeReady = true;
      
      // Load priests data
      loadPriestsData();
      
      // Initial solar position
      const dt = new Date();
      const [longitude, declination] = calculateSolarPosition(dt);
      enhancedEarth.updateSunDirection(longitude, declination);
      
      // Center globe based on user location/timezone
      centerOnTimezone();
      
      // Remove this line - no UI control for cloud opacity
      // addCloudOpacityControl();
      
      // Update solar position periodically
      setInterval(() => {
        const dt = new Date();
        const [longitude, declination] = calculateSolarPosition(dt);
        enhancedEarth.updateSunDirection(longitude, declination);
      }, 60000); // Update every minute
    }

    // Main initialization function
    function init() {
      // Initialize Three.js scene
      initScene();
      
      // Initialize raycaster for interactions
      raycaster = new THREE.Raycaster();
      mouse = new THREE.Vector2();
      
      // Initialize enhanced globe
      initEnhancedGlobe();
      
      // Set up event listeners
      setupEventListeners();
      
      // Request user location
      getUserLocation();
      
      // Start animation loop
      enhancedAnimate();
    }
    
    // Get current theme (light/dark)
    function getTheme() {
      if (CONFIG.theme) {
        return CONFIG.theme;
      }
      
      if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
        return 'dark';
      }
      
      return 'light';
    }
    
    // Initialize Three.js scene
    function initScene() {
      // Initialize renderer
      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.getElementById('globeContainer').appendChild(renderer.domElement);

      // Initialize scene
      scene = new THREE.Scene();
      
      // Set background color based on theme
      const backgroundColor = currentTheme === 'dark' ? 0x121212 : 0xf5f5f5;
      scene.background = new THREE.Color(backgroundColor);
      
      scene.add(new THREE.AmbientLight(0xeeeeee, 0.3));
      
      // Initialize camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      
      const dLight = new THREE.DirectionalLight(0xffffff, 0.8);
      dLight.position.set(-800, 2000, 400);
      camera.add(dLight);
      
      const dLight1 = new THREE.DirectionalLight(0x7982f6, 1);
      dLight1.position.set(-200, 500, 200);
      camera.add(dLight1);
      
      const dLight2 = new THREE.PointLight(0x8566cc, 0.5);
      dLight2.position.set(-200, 500, 200);
      camera.add(dLight2);
      
      camera.position.z = CONFIG.currentZoomLevel;
      camera.position.x = 0;
      camera.position.y = 0;
      
      scene.add(camera);
      
      // Add fog for atmospheric effect
      const fogColor = currentTheme === 'dark' ? 0x333333 : 0xcccccc;
      scene.fog = new THREE.Fog(fogColor, 400, 2000);
      
      // Initialize orbit controls
      controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.dynamicDampingFactor = 0.01;
      controls.enablePan = false;
      controls.minDistance = 200;
      controls.maxDistance = 400;
      controls.rotateSpeed = 0.8;
      controls.zoomSpeed = 1;
      controls.autoRotate = CONFIG.autoRotate;
      controls.autoRotateSpeed = CONFIG.autoRotateSpeed;
         
      controls.minPolarAngle = 5 * (Math.PI / 180);  // 5 degrees from north pole
      controls.maxPolarAngle = 175 * (Math.PI / 180); // 5 degrees from south pole
    }
    
    // Texture cache using IndexedDB
    const TextureCache = {
      dbName: 'earth-texture-cache',
      dbVersion: 1,
      db: null,

      init() {
        return new Promise((resolve, reject) => {
          const request = indexedDB.open(this.dbName, this.dbVersion);
          
          request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains('textures')) {
              db.createObjectStore('textures', { keyPath: 'url' });
            }
          };
          
          request.onsuccess = (event) => {
            this.db = event.target.result;
            resolve();
          };
          
          request.onerror = (event) => {
            console.error('IndexedDB error:', event.target.error);
            reject(event.target.error);
          };
        });
      },

      storeTexture(url, blob) {
        return new Promise((resolve, reject) => {
          if (!this.db) return reject(new Error('Database not initialized'));
          
          const transaction = this.db.transaction(['textures'], 'readwrite');
          const store = transaction.objectStore('textures');
          
          const item = { url, blob, timestamp: Date.now() };
          const request = store.put(item);
          
          request.onsuccess = () => resolve();
          request.onerror = (event) => reject(event.target.error);
        });
      },

      getTexture(url) {
        return new Promise((resolve, reject) => {
          if (!this.db) return reject(new Error('Database not initialized'));
          
          const transaction = this.db.transaction(['textures'], 'readonly');
          const store = transaction.objectStore('textures');
          
          const request = store.get(url);
          
          request.onsuccess = (event) => {
            resolve(event.target.result ? event.target.result.blob : null);
          };
          
          request.onerror = (event) => reject(event.target.error);
        });
      }
    };

    // Progressive texture loader
    const TextureManager = {
      baseUrl: 'https://dubia.cc/',
      resolutions: {
        low: '2k_',
        high: '8k_'
      },
      textureTypes: [
        'earth_daymap',
        'earth_nightmap',
        'earth_normal_map',
        'earth_specular_map',
        'earth_clouds'
      ],
      loadedTextures: {
        low: {},
        high: {}
      },
      
      async init() {
        await TextureCache.init();
        return this;
      },
      
      getTextureUrl(type, resolution) {
        const prefix = this.resolutions[resolution];
        return `${this.baseUrl}${prefix}${type}.avif`;
      },
      
      async loadTexture(type, resolution, retryCount = 0, maxRetries = 3) {
  const url = this.getTextureUrl(type, resolution);
  
  // Return cached texture if already loaded
  if (this.loadedTextures[resolution][type]) {
    return this.loadedTextures[resolution][type];
  }
  
  // Try to get from cache
  try {
    const cachedBlob = await TextureCache.getTexture(url);
    if (cachedBlob) {
      const texture = await this._createTextureFromBlob(cachedBlob);
      this.loadedTextures[resolution][type] = texture;
      return texture;
    }
  } catch (err) {
    console.warn('Error loading texture from cache:', err);
  }
  
  // Fetch from network with retry logic
  try {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to load texture: ${url}`);
    
    const blob = await response.blob();
    
    // Store in cache
    try {
      await TextureCache.storeTexture(url, blob);
    } catch (err) {
      console.warn('Error storing texture in cache:', err);
    }
    
    // Create texture
    const texture = await this._createTextureFromBlob(blob);
    this.loadedTextures[resolution][type] = texture;
    return texture;
  } catch (err) {
    // Retry logic
    if (retryCount < maxRetries) {
      console.warn(`Retry ${retryCount + 1}/${maxRetries} for texture: ${url}`);
      // Exponential backoff - wait longer between each retry
      await new Promise(resolve => setTimeout(resolve, 1000 * Math.pow(2, retryCount)));
      return this.loadTexture(type, resolution, retryCount + 1, maxRetries);
    }
    
    console.error('Error loading texture after retries:', err);
    // Return a default fallback texture
    return this._createFallbackTexture(type);
  }
},

      // 2. Add a new method to TextureManager to create fallback textures
      _createFallbackTexture(type) {
        console.log(`Creating fallback texture for: ${type}`);
        
        // Create a canvas with a solid color
        const canvas = document.createElement('canvas');
        canvas.width = 512;
        canvas.height = 256;
        const ctx = canvas.getContext('2d');
        
        // Different colors for different texture types
        let color;
        switch (type) {
          case 'earth_daymap':
            color = '#1a4d7e'; // Dark blue for day
            break;
          case 'earth_nightmap':
            color = '#000020'; // Near black for night
            break;
          case 'earth_normal_map':
            color = '#8080ff'; // Normal map blue
            break;
          case 'earth_specular_map':
            color = '#000000'; // Black for no specular
            break;
          case 'earth_clouds':
            color = '#ffffff'; // White with transparancy
            ctx.globalAlpha = 0.2;
            break;
          default:
            color = '#000000'; // Default black
        }
        
        // Fill with base color
        ctx.fillStyle = color;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        // Create texture from canvas
        const texture = new THREE.Texture(canvas);
        texture.needsUpdate = true;
        return texture;
      },

      _createTextureFromBlob(blob) {
        return new Promise((resolve, reject) => {
          const url = URL.createObjectURL(blob);
          const loader = new THREE.TextureLoader();
          
          loader.load(
            url,
            (texture) => {
              URL.revokeObjectURL(url);
              texture.minFilter = THREE.LinearMipmapLinearFilter;
              texture.magFilter = THREE.LinearFilter;
              texture.encoding = THREE.sRGBEncoding;
              resolve(texture);
            },
            undefined,
            (err) => {
              URL.revokeObjectURL(url);
              reject(err);
            }
          );
        });
      },
      
      async loadAllTextures(resolution) {
        const promises = this.textureTypes.map(type => 
          this.loadTexture(type, resolution)
        );
        
        try {
          const textures = await Promise.all(promises);
          const result = {};
          
          this.textureTypes.forEach((type, index) => {
            result[type] = textures[index];
          });
          
          return result;
        } catch (err) {
          console.error('Error loading all textures:', err);
          throw err;
        }
      }
    };

    // Earth PBR shader
    const EarthPBRShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          
          vec4 mvPosition = viewMatrix * worldPosition;
          vViewPosition = -mvPosition.xyz;
          
          gl_Position = projectionMatrix * mvPosition;
        }
      `,
      
      fragmentShader: `
        uniform sampler2D dayMap;
        uniform sampler2D nightMap;
        uniform sampler2D normalMap;
        uniform sampler2D specularMap;
        uniform vec3 sunDirection;
        // Remove this line - it's causing the error
        // uniform vec3 cameraPosition; 
        
        // Earth properties
        uniform float normalScale;
        uniform float specularIntensity;
        uniform float roughness;
        uniform float fresnelPower;
        uniform float atmosphereIntensity;
        
        varying vec3 vNormal;
        varying vec2 vUv;
        varying vec3 vViewPosition;
        varying vec3 vWorldPosition;
        
        // Physically-based rendering functions
        vec3 perturbNormal(vec3 normal, vec3 viewPosition, vec2 uv) {
          // Tangent space normal map calculation
          vec3 q0 = dFdx(viewPosition);
          vec3 q1 = dFdy(viewPosition);
          vec2 st0 = dFdx(uv);
          vec2 st1 = dFdy(uv);
          
          vec3 S = normalize(q0 * st1.t - q1 * st0.t);
          vec3 T = normalize(-q0 * st1.s + q1 * st0.s);
          vec3 N = normal;
          
          vec3 mapN = texture2D(normalMap, uv).xyz * 2.0 - 1.0;
          mapN.xy *= normalScale;
          
          mat3 tsn = mat3(S, T, N);
          return normalize(tsn * mapN);
        }
        
        // Schlick's approximation for Fresnel
        float fresnel(float cosTheta, float F0, float power) {
          return F0 + (1.0 - F0) * pow(1.0 - cosTheta, power);
        }
        
        void main() {
          // Normalize vectors
          vec3 viewDir = normalize(vViewPosition);
          vec3 normal = normalize(vNormal);
          
          // Apply normal mapping
          if (normalScale > 0.0) {
            normal = perturbNormal(normal, vViewPosition, vUv);
          }
          
          // Calculate the light intensity based on sun angle with soft transition
          float NdotL = dot(normal, sunDirection);
          float lightIntensity = smoothstep(-0.15, 0.15, NdotL);
          
          // Sample the day and night textures
          vec3 dayColor = texture2D(dayMap, vUv).rgb;
          vec3 nightColor = texture2D(nightMap, vUv).rgb * 0.5; // Dim the night lights
          
          // Sample the specular map
          float specular = texture2D(specularMap, vUv).r;
          
          // Base color with day/night transition
          vec3 color = mix(nightColor, dayColor, lightIntensity);
          
          // Add specular highlights when lit by the sun
          if (NdotL > 0.0) {
            // Blinn-Phong specular
            vec3 halfVector = normalize(sunDirection + viewDir);
            float NdotH = max(0.0, dot(normal, halfVector));
            float specularFactor = pow(NdotH, (1.0 - roughness) * 100.0) * specular * specularIntensity;
            
            color += specularFactor * vec3(1.0);
          }
          
          // Calculate fresnel effect (rim lighting)
          float NdotV = max(0.001, dot(normal, viewDir));
          float fresnelFactor = fresnel(NdotV, 0.1, fresnelPower);
          
          // Add atmosphere rim
          vec3 atmosphereColor = vec3(0.3, 0.6, 1.0) * atmosphereIntensity;
          color = mix(color, atmosphereColor, fresnelFactor * 0.5);
          
          // Output final color
          gl_FragColor = vec4(color, 1.0);
        }
      `,
      
      uniforms: {
        dayMap: { value: null },
        nightMap: { value: null },
        normalMap: { value: null },
        specularMap: { value: null },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
        // Don't reference cameraPosition here as it's automatically included
        normalScale: { value: 1.0 },
        specularIntensity: { value: 0.5 },
        roughness: { value: 0.5 },
        fresnelPower: { value: 4.0 },
        atmosphereIntensity: { value: 1.0 }
      }
    };

    // Cloud shader
    const CloudShader = {
      vertexShader: `
        varying vec2 vUv;
        varying vec3 vNormal;
        
        void main() {
          vUv = uv;
          vNormal = normalize(normalMatrix * normal);
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      
      fragmentShader: `
        uniform sampler2D cloudMap;
        uniform vec3 sunDirection;
        uniform float cloudOpacity;
        uniform float cloudBrightness;
        
        varying vec2 vUv;
        varying vec3 vNormal;
        
        void main() {
          vec4 cloudTexel = texture2D(cloudMap, vUv);
          
          // Make clouds self-shadow based on sun direction
          float NdotL = dot(vNormal, sunDirection);
          float lightIntensity = smoothstep(-0.2, 0.4, NdotL);
          
          // Brighten clouds in sunlight
          vec3 cloudColor = cloudTexel.rgb * cloudBrightness * lightIntensity;
          
          // Output with adjusted opacity
          gl_FragColor = vec4(cloudColor, cloudTexel.a * cloudOpacity);
        }
      `,
      
      uniforms: {
        cloudMap: { value: null },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) },
        cloudOpacity: { value: 0.8 },
        cloudBrightness: { value: 1.2 }
      }
    };

    // Atmospheric glow shader
    const AtmosphereShader = {
      vertexShader: `
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
          vNormal = normalize(normalMatrix * normal);
          vPosition = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      
      fragmentShader: `
        uniform vec3 glowColor;
        uniform float power;
        uniform float atmosphereIntensity;
        uniform vec3 sunDirection;
        
        varying vec3 vNormal;
        varying vec3 vPosition;
        
        void main() {
          // Fresnel-like glow effect
          float intensity = pow(0.75 - dot(vNormal, vec3(0, 0, 1.0)), power);
          
          // Modify intensity based on sun direction for a more realistic effect
          float sunFactor = max(0.5, dot(vNormal, sunDirection));
          intensity *= sunFactor;
          
          // Apply atmosphere intensity
          vec3 glow = glowColor * intensity * atmosphereIntensity;
          
          gl_FragColor = vec4(glow, intensity);
        }
      `,
      
      uniforms: {
        glowColor: { value: new THREE.Color(0x3a88ff) },
        power: { value: 2.0 },
        atmosphereIntensity: { value: 1.0 },
        sunDirection: { value: new THREE.Vector3(1, 0, 0) }
      }
    };

    // Earth object with PBR rendering
    class EnhancedEarth {
      constructor(scene, camera) {
        this.scene = scene;
        this.camera = camera;
        this.textureManager = null;
        this.earthMesh = null;
        this.cloudMesh = null;
        this.atmosphereMesh = null;
        this.currentResolution = 'low';
        this.earthRadius = 1.0;
        this.cloudRadius = 1.02;
        this.atmosphereRadius = 1.1;
        this.zoomThreshold = 250;
        
        // Shader materials
        this.earthMaterial = null;
        this.cloudMaterial = null;
        this.atmosphereMaterial = null;
        
        // Options
        this.options = {
          normalScale: 1.0,
          specularIntensity: 0.5,
          roughness: 0.7,
          fresnelPower: 4.0,
          atmosphereIntensity: 1.0,
          cloudOpacity: 0.8,
          cloudBrightness: 1.2,
          cloudRotationSpeed: 0.0005
        };
      }
      
      async init() {
        // Initialize texture manager
        this.textureManager = await TextureManager.init();
        
        // Create geometries
        const earthGeometry = new THREE.SphereGeometry(this.earthRadius, 64, 64);
        const cloudGeometry = new THREE.SphereGeometry(this.cloudRadius, 64, 64);
        const atmosphereGeometry = new THREE.SphereGeometry(this.atmosphereRadius, 64, 64);
        
        // Create materials
        this.earthMaterial = new THREE.ShaderMaterial({
          vertexShader: EarthPBRShader.vertexShader,
          fragmentShader: EarthPBRShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(EarthPBRShader.uniforms)
        });
        
        this.cloudMaterial = new THREE.ShaderMaterial({
          vertexShader: CloudShader.vertexShader,
          fragmentShader: CloudShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(CloudShader.uniforms),
          transparent: true,
          blending: THREE.CustomBlending,
          blendSrc: THREE.SrcAlphaFactor,
          blendDst: THREE.OneMinusSrcAlphaFactor
        });
        
        this.atmosphereMaterial = new THREE.ShaderMaterial({
          vertexShader: AtmosphereShader.vertexShader,
          fragmentShader: AtmosphereShader.fragmentShader,
          uniforms: THREE.UniformsUtils.clone(AtmosphereShader.uniforms),
          transparent: true,
          blending: THREE.AdditiveBlending,
          side: THREE.BackSide
        });
        
        // Create meshes
        this.earthMesh = new THREE.Mesh(earthGeometry, this.earthMaterial);
        this.earthMesh.name = 'earth-mesh';
        
        this.cloudMesh = new THREE.Mesh(cloudGeometry, this.cloudMaterial);
        this.cloudMesh.name = 'cloud-mesh';
        
        this.atmosphereMesh = new THREE.Mesh(atmosphereGeometry, this.atmosphereMaterial);
        this.atmosphereMesh.name = 'atmosphere-mesh';
        
        // Add to scene
        this.scene.add(this.earthMesh);
        this.scene.add(this.cloudMesh);
        this.scene.add(this.atmosphereMesh);
        
        // Load initial low-resolution textures
        await this.loadTextures('low');
        
        // Set up zoom listener
        this.setupZoomListener();
        
        return this;
      }
      
      async loadTextures(resolution) {
        try {
          const textures = await this.textureManager.loadAllTextures(resolution);
          
          // Update Earth shader uniforms
          this.earthMaterial.uniforms.dayMap.value = textures.earth_daymap;
          this.earthMaterial.uniforms.nightMap.value = textures.earth_nightmap;
          this.earthMaterial.uniforms.normalMap.value = textures.earth_normal_map;
          this.earthMaterial.uniforms.specularMap.value = textures.earth_specular_map;
          
          // Update Cloud shader uniform
          this.cloudMaterial.uniforms.cloudMap.value = textures.earth_clouds;
          
          this.currentResolution = resolution;
          console.log(`Loaded ${resolution} resolution textures`);
          
          // Update shader properties
          this.updateShaderProperties();
          
          return true;
        } catch (err) {
          console.error('Critical error loading textures:', err);
          
          // Create a simple fallback Earth if we reached this point
          this.createFallbackEarth();
          
          return false;
        }
      }

      createFallbackEarth() {
        console.warn('Creating fallback Earth due to texture loading failures');
        
        // Create a simple material for Earth
        const fallbackEarthMaterial = new THREE.MeshPhongMaterial({
          color: 0x2233aa,  // Blue color
          emissive: 0x112244,
          specular: 0x333333,
          shininess: 25
        });
        
        // Apply the fallback material
        this.earthMesh.material = fallbackEarthMaterial;
        
        // Create a simple material for clouds
        const fallbackCloudMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.1
        });
        
        // Apply the fallback cloud material
        this.cloudMesh.material = fallbackCloudMaterial;
        
        // Create a simple material for atmosphere
        const fallbackAtmosphereMaterial = new THREE.MeshBasicMaterial({
          color: 0x3366ff,
          transparent: true,
          opacity: 0.2,
          side: THREE.BackSide
        });
        
        // Apply the fallback atmosphere material
        this.atmosphereMesh.material = fallbackAtmosphereMaterial;
        
        // Set flag to prevent further texture loading attempts
        this.textureLoadingFailed = true;
      }

      updateShaderProperties() {
        // Update Earth material uniforms
        this.earthMaterial.uniforms.normalScale.value = this.options.normalScale;
        this.earthMaterial.uniforms.specularIntensity.value = this.options.specularIntensity;
        this.earthMaterial.uniforms.roughness.value = this.options.roughness;
        this.earthMaterial.uniforms.fresnelPower.value = this.options.fresnelPower;
        this.earthMaterial.uniforms.atmosphereIntensity.value = this.options.atmosphereIntensity;
        
        // Update Cloud material uniforms
        this.cloudMaterial.uniforms.cloudOpacity.value = this.options.cloudOpacity;
        this.cloudMaterial.uniforms.cloudBrightness.value = this.options.cloudBrightness;
        
        // Update Atmosphere material uniforms
        this.atmosphereMaterial.uniforms.atmosphereIntensity.value = this.options.atmosphereIntensity;
      }
      
      updateSunDirection(longitude, declination) {
        // Convert longitude and declination to Cartesian coordinates
        const phi = (90 - declination) * Math.PI / 180;
        const theta = longitude * Math.PI / 180;
        
        const sunX = Math.sin(phi) * Math.cos(theta);
        const sunY = Math.cos(phi);
        const sunZ = Math.sin(phi) * Math.sin(theta);
        
        const sunDirection = new THREE.Vector3(sunX, sunY, sunZ);
        
        // Update shader uniforms
        this.earthMaterial.uniforms.sunDirection.value = sunDirection;
        this.cloudMaterial.uniforms.sunDirection.value = sunDirection;
        this.atmosphereMaterial.uniforms.sunDirection.value = sunDirection;
      }
      
      setupZoomListener() {
        // Check zoom level periodically
        setInterval(() => {
          // Skip if texture loading previously failed
          if (this.textureLoadingFailed) return;
          
          const distance = this.camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
          
          // Switch to high-res textures when zoomed in
          if (distance < this.zoomThreshold && this.currentResolution === 'low') {
            this.loadTextures('high');
          }
          // Switch back to low-res textures when zoomed out
          else if (distance >= this.zoomThreshold && this.currentResolution === 'high') {
            this.loadTextures('low');
          }
        }, 1000);
      }
      
      update() {
        if (this.cloudMesh) {
          this.cloudMesh.rotation.y += this.options.cloudRotationSpeed;
        }
      }
      
      setCloudOpacity(opacity) {
        this.options.cloudOpacity = opacity;
        if (this.cloudMaterial && this.cloudMaterial.uniforms.cloudOpacity) {
          this.cloudMaterial.uniforms.cloudOpacity.value = opacity;
        }
      }
      
      getEarthMesh() {
        return this.earthMesh;
      }
    }


    function getKeyboardFocusableElements(element = document) {
        return Array.from(element.querySelectorAll(
            'a, button, input, textarea, select, details,[tabindex]:not([tabindex="-1"])'
        ))
        .filter(el => !el.hasAttribute('disabled'))
        .sort((a, b) => {
            // Get explicit tabindex values
            const aTabIndex = parseInt(a.getAttribute('tabindex') || '0', 10);
            const bTabIndex = parseInt(b.getAttribute('tabindex') || '0', 10);
            
            // Sort by tabindex (elements with tabindex > 0 come first, in numerical order)
            if (aTabIndex > 0 && bTabIndex > 0) {
                return aTabIndex - bTabIndex;
            }
            
            // Elements with tabindex > 0 come before elements with tabindex = 0
            if (aTabIndex > 0) return -1;
            if (bTabIndex > 0) return 1;
            
            // Elements with tabindex = 0 are sorted by their DOM position
            return 0;
        });
    }

    // Set up event listeners
    function setupEventListeners() {
      // Window resize event
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
        // Search input events
        const searchInput = document.getElementById('searchInput');
        const searchResults = document.getElementById('searchResults');
        
        searchInput.addEventListener('input', handleSearch);
        
        // Reset selection index when focusing back on the search input
        searchInput.addEventListener('focus', () => {
            // Reset the selectedSearchIndex when focus returns to input
            selectedSearchIndex = -1;
            
            if (searchResults.children.length > 0) {
            searchResults.style.display = 'block';
            }
        });

        document.body.addEventListener('keydown', (e) => {
    const searchResults = document.getElementById('searchResults');
    
    // Only handle arrow keys when search results are visible
    if (searchResults.style.display === 'block' && 
        (e.key === 'ArrowDown' || e.key === 'ArrowUp' || 
         e.key === 'ArrowRight' || e.key === 'ArrowLeft')) {
        
        e.preventDefault();
        
        // Get all focusable elements
        const focusableElements = getKeyboardFocusableElements();
        
        // Get current element's position in the tab order
        const currentElement = document.activeElement;
        const currentIndex = focusableElements.indexOf(currentElement);
        
        if (currentIndex !== -1) {
            // Determine next position based on arrow key
            let nextIndex;
            if (e.key === 'ArrowDown' || e.key === 'ArrowRight') {
                nextIndex = Math.min(currentIndex + 1, focusableElements.length - 1);
            } else {
                nextIndex = Math.max(currentIndex - 1, 0);
            }
            
            // Focus the next element
            if (nextIndex !== currentIndex) {
                focusableElements[nextIndex].focus();
                
                // If it's a search result item, ensure it's visible
                if (focusableElements[nextIndex].classList.contains('search-result-item')) {
                    focusableElements[nextIndex].scrollIntoView({ block: 'nearest' });
                }
            }
        }
    }
});

        // Simplified searchInput event listener - just for Enter and Escape
        searchInput.addEventListener('keydown', (e) => {
            // Handle Enter key regardless of search results visibility
            if (e.key === 'Enter') {
                e.preventDefault();
                selectSearchResult();
                return;
            }
            
            if (searchResults.style.display === 'block' && e.key === 'Escape') {
                e.preventDefault();
                searchResults.style.display = 'none';
            }
        });
            
        // Close button event - reset highlights when panel closes
        document.getElementById('closeBtn').addEventListener('click', () => {
            document.getElementById('infoPanel').style.display = 'none';
            resetAllMarkers();
        });

        // Click event for globe interactions
        renderer.domElement.addEventListener('click', onDocumentMouseClick);
        

      // Close search results when clicking outside
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
          searchResults.style.display = 'none';
        }
      });
      
      // Theme change detection
      if (window.matchMedia) {
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', () => {
          if (!CONFIG.theme) {
            currentTheme = getTheme();
            updateTheme();
          }
        });
      }
      
      // Update camera change events
      controls.addEventListener('change', onCameraChange);
    }
    
    // Handle camera change for day/night shader
    function onCameraChange() {
      // Adjust rotation speed based on zoom level
      adjustRotationSpeed();
    }
    
    // Update theme visuals
    function updateTheme() {
      // Update background
      const backgroundColor = currentTheme === 'dark' ? 0x121212 : 0xf5f5f5;
      scene.background = new THREE.Color(backgroundColor);
      
      // Update fog
      const fogColor = currentTheme === 'dark' ? 0x333333 : 0xcccccc;
      scene.fog = new THREE.Fog(fogColor, 400, 2000);
      
      // Update atmosphere
      globe.atmosphereColor(currentTheme === 'dark' ? "#3a228a" : "#ccc");
      
      // Update day texture (would require reloading textures)
      // This would be better handled by recreating the globe
    }
    

    function resetAllMarkers() {
      scene.children
        .filter(obj => obj.name === 'priest-marker')
        .forEach(marker => marker.material.color.set(CONFIG.markerColor));
      
      scene.children
        .filter(obj => obj.name === 'priest-pulse')
        .forEach(pulse => {
          pulse.children
            .filter(child => child.isMesh)
            .forEach(mesh => mesh.material.color.set(CONFIG.markerPulseColor));
        });
    }

    function highlightSelectedPriest(priest) {
      resetAllMarkers();
      
      scene.children
        .filter(obj => obj.name === 'priest-marker')
        .filter(marker => marker.priestData?.Name === priest.Name)
        .forEach(marker => marker.material.color.set('yellow'));
      
      scene.children
        .filter(obj => obj.name === 'priest-pulse')
        .filter(pulse => pulse.priestData?.Name === priest.Name)
        .forEach(pulse => {
          pulse.children
            .filter(child => child.isMesh)
            .forEach(mesh => mesh.material.color.set('rgba(255, 255, 0, 0.4)'));
        });
    }


    // Select the current search result
    function selectSearchResult(priest) {
        const searchResultsContainer = document.getElementById('searchResults');
        const items = searchResultsContainer.querySelectorAll('.search-result-item');
        
        // If no selection but we have results, select the first one
        if (selectedSearchIndex < 0 && items.length > 0) {
            selectedSearchIndex = 0;
        }
        
        if (selectedSearchIndex >= 0 && selectedSearchIndex < items.length) {
            const priest = searchResults[selectedSearchIndex];
            if (!priest) return;
            
            showPriestInfo(priest);
            focusOnPoint(priest.Latitude, priest.Longitude);
            highlightSelectedPriest(priest);
            
            // Hide search results and clear input
            searchResultsContainer.style.display = 'none';
            document.getElementById('searchInput').value = '';
        }
    }
          
    // Mouse click event handler
    function onDocumentMouseClick(event) {
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
      
      raycaster.setFromCamera(mouse, camera);
      
      // First check if we hit the globe itself
      const globeIntersects = raycaster.intersectObject(globe);
      
      // If hit on globe, determine if it's front or back side
      if (globeIntersects.length > 0) {
        const hitPoint = globeIntersects[0].point;
        
        // Skip if we hit the back side
        if (!isPointOnFrontSide(hitPoint, camera)) {
          return;
        }
      }
      
      // Check for priest marker hits
      const objects = scene.children.filter(obj => 
        obj.name === 'priest-marker' || obj.name === 'priest-pulse' || obj.name === 'priest-marker-invisible'
      );
      
      const intersects = raycaster.intersectObjects(objects, true);
      
      if (intersects.length > 0) {
        // Filter out back-side hits
        const frontSideHits = intersects.filter(hit => 
          isPointOnFrontSide(hit.point, camera)
        );
        
        if (frontSideHits.length === 0) return;
        
        // Process hits as before, but only for front-side objects
        const hitPriests = new Map();
        
        for (const hit of frontSideHits) {
          const obj = hit.object;
          const priestData = obj.name === 'priest-marker' || obj.name === 'priest-marker-invisible'
            ? obj.priestData 
            : obj.parent.priestData;
          
          if (priestData && !hitPriests.has(priestData.Name)) {
            hitPriests.set(priestData.Name, {
              priestData: priestData,
              distance: hit.distance
            });
          }
        }
        
        // Convert to array and sort by distance
        const hitResults = Array.from(hitPriests.values())
          .sort((a, b) => a.distance - b.distance);
        
        if (hitResults.length === 1) {
          // Single priest hit
          const priestData = hitResults[0].priestData;
          showPriestInfo(priestData);
          highlightSelectedPriest(priestData);
          focusOnPoint(priestData.Latitude, priestData.Longitude);
        } else if (hitResults.length > 1) {
          // Multiple priests hit
          showProximitySearchResults(hitResults);
        }
      }
    }

    // Function to display search results when multiple priests are selected
    function showProximitySearchResults(results) {
      const searchResultsContainer = document.getElementById('searchResults');
      
      // Clear previous results
      searchResultsContainer.innerHTML = '';
      searchResults = [];
      selectedSearchIndex = -1;
      
      // Add results to global searchResults array
      searchResults = results.map(result => result.priestData);
      
      // Create result items
      results.forEach((result, i) => {
        const priest = result.priestData;
        const resultItem = document.createElement('div');
        resultItem.className = 'search-result-item';
        resultItem.tabIndex = i + 200;
        resultItem.textContent = `${priest.Name} (${priest['Location/Area'] || 'Unknown'})`;
        
        resultItem.addEventListener('click', () => {
          showPriestInfo(priest);
          focusOnPoint(priest.Latitude, priest.Longitude);
          highlightSelectedPriest(priest);
          searchResultsContainer.style.display = 'none';
        });
        
        resultItem.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' || e.key === ' ') {
            e.preventDefault();
            resultItem.click();
          }
        });
        
        searchResultsContainer.appendChild(resultItem);
      });
      
      // Display results
      searchResultsContainer.style.display = 'block';
    }

    // Animation loop
    function enhancedAnimate() {
      requestAnimationFrame(enhancedAnimate);
      
      // Update Earth's cloud rotation if available
      if (enhancedEarth) {
        enhancedEarth.update();
      }
      
      // Animate pulse rings for markers
      animatePulseRings();
      
      controls.update();
      renderer.render(scene, camera);
    }
    
    // Animate pulse rings
    function animatePulseRings() {
      const time = Date.now() * 0.001; // time in seconds
      
      pulseMeshes.forEach(mesh => {
        // Pulse scale with sine wave (0.8 to 1.2)
        const scale = 1 + 0.2 * Math.sin(time * 2 + mesh.pulseOffset);
        mesh.scale.set(scale, scale, scale);
        
        // Pulse opacity (0.4 to 0.8)
        mesh.material.opacity = 0.4 + 0.2 * Math.abs(Math.sin(time + mesh.pulseOffset));
      });
    }
    
    // Load priests data
    function loadPriestsData() {
      // Default data as fallback
      const defaultCsvData = `Type,Name,Born Year,Associates With,Beliefs,Location/Area,Contact/Website,Ordained in Rite,Ordained By,Consecrated in Rite,Consecrated By,Bishop Line,Notes
Bishop,Richard Williamson,,SSPX (originally),Resistance,England,,Old Rite,Archbishop Lefebvre,Old Rite,Archbishop Lefebvre,Lefebvre,Consecrated in 1988 by Archbishop Lefebvre; leads "SSPX Resistance"
Bishop,Gerardo Zendejas,,Resistance,Non-sede,USA,https://thebluepaper.org/,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated bishop on May 11 2017 by Bp. Williamson
Bishop,Jean-Michel Faure,1941,Resistance,Non-sede,France,,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2015 by Bp. Williamson in Brazil
Bishop,Paul Morgan,,Independent? (formerly SSPX),Mixed,Unknown,,Old Rite,Archbishop Lefebvre,,,,Former SSPX District Superior of GB; uncertain present status
Bishop,Thomas Aquinas (OSB),,Resistance,Non-sede,Brazil,,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2016 by Bp. Williamson (Nova Friburgo)
Bishop,Giacomo Ballini,,Resistance,Non-sede,Italy/Ireland,,Old Rite,,Old Rite,Bp. R. Williamson,Lefebvre,Works with Fr. Chazal/Hewko
Bishop,Czeslaw Stobnicki,,Resistance,Non-sede,Poland,,Old Rite,,Old Rite,Bp. R. Williamson,Lefebvre,Little info available; mention as "Bp. Stobnicki (PL)"
Bishop,Carlo Maria ViganÃ²,1941,Independent? (ex-Nuncio),Unclear (traditional-leaning),Europe,,New Rite (likely),Pope Paul VI or John Paul II,New Rite (likely),,,"Conciliar, sometimes labeled "sede?" by rumor, but no official claim"
Father,Martin Fuchs,,Resistance,Non-sede,Austria,https://corjesu.info/wordpress/?p=2240,Old Rite,,,,,Mentioned with "SSPX Resistance" in Austria
Father,Peter Lang,,Resistance,Non-sede,Germany,pater.lang@gmx.de,Old Rite,,,,,German SSPX Resistance priest`;
      
      if (CONFIG.dataUrl) {
        // Fetch data from configured URL
        fetch(CONFIG.dataUrl)
          .then(response => response.text())
          .then(csvData => {
            parseAndProcessData(csvData);
          })
          .catch(error => {
            console.error('Error loading data:', error);
            console.log('Falling back to default data');
            parseAndProcessData(defaultCsvData);
          });
      } else {
        // Use default hardcoded data
        parseAndProcessData(defaultCsvData);
      }
    }
    
    // Parse and process CSV data
    function parseAndProcessData(csvData) {
      Papa.parse(csvData, {
        header: true,
        skipEmptyLines: true,
        complete: (results) => {
          // Process data and add missing columns (lat, long, GoogleMaps)
          priests = addGeoData(results.data);
          
          // Once data is loaded, populate the globe
          window.setTimeout(function() {
            populateGlobeWithMarkers(priests);
          }, 400);
        },
        error: (error) => {
          console.error('Error parsing CSV:', error);
        }
      });
    }
    
    // Add geographic data to priests
    function addGeoData(priests) {
      return priests.map(priest => {
        // Assign locations to actual coordinates
        let lat, lng;
        
        switch(priest['Location/Area']) {
          case 'England':
            lat = 52.3555; lng = -1.1743;
            break;
          case 'USA':
            lat = 37.0902; lng = -95.7129;
            break;
          case 'France':
            lat = 46.2276; lng = 2.2137;
            break;
          case 'Brazil':
            lat = -14.2350; lng = -51.9253;
            break;
          case 'Italy/Ireland':
            lat = 41.8719; lng = 12.5674; // Using Italy
            break;
          case 'Poland':
            lat = 51.9194; lng = 19.1451;
            break;
          case 'Europe':
            lat = 48.8566; lng = 2.3522; // Using Paris as a European center
            break;
          case 'Austria':
            lat = 47.5162; lng = 14.5501;
            break;
          case 'Germany':
            lat = 51.1657; lng = 10.4515;
            break;
          default:
            // Random coordinates for unknown locations
            lat = parseFloat((Math.random() * 180 - 90).toFixed(4));
            lng = parseFloat((Math.random() * 360 - 180).toFixed(4));
        }
        
        return {
          ...priest,
          Latitude: lat,
          Longitude: lng,
          GoogleMaps: `https://maps.google.com/?q=${lat},${lng}`
        };
      });
    }
    
    function getPointOnGlobe(lat, lng, altitude = 0) {
      const phi = (90 - lat) * Math.PI / 180;
      const theta = (lng + 180) * Math.PI / 180;
      
      const radius = 1.0 + altitude; // Earth radius + altitude
      
      const x = -radius * Math.sin(phi) * Math.cos(theta);
      const y = radius * Math.cos(phi);
      const z = radius * Math.sin(phi) * Math.sin(theta);
      
      return new THREE.Vector3(x, y, z);
    }

    // Populate the globe with markers and pulse rings
    function populateGlobeWithMarkers(data) {
      if (!globe) return;
      
      // Clear any existing markers
      const existingMarkers = scene.children.filter(obj => 
        obj.name === 'priest-marker' || obj.name === 'priest-pulse' || obj.name === 'priest-marker-invisible'
      );
      existingMarkers.forEach(marker => scene.remove(marker));
      
      // Clear pulse meshes array
      pulseMeshes = [];
      
      // Create markers for each priest
      data.forEach(priest => {
        // Get coordinates
        const lat = priest.Latitude;
        const lng = priest.Longitude;
        
        // Calculate position on globe surface
        const position = getPointOnGlobe(lat, lng, CONFIG.labelAltitude);
        
        // Add dot marker
        const markerGeometry = new THREE.SphereGeometry(CONFIG.markerSize, 16, 16);
        const markerMaterial = new THREE.MeshBasicMaterial({ color: CONFIG.markerColor });
        const marker = new THREE.Mesh(markerGeometry, markerMaterial);
        
        // Set marker position
        marker.position.set(position.x, position.y, position.z);
        marker.name = 'priest-marker';
        marker.priestData = priest; // Store the priest data on the object for click handling
        
        // Add marker to scene
        scene.add(marker);
        
        // Add pulsating ring around marker
        const pulseGeometry = new THREE.RingGeometry(CONFIG.markerSize, CONFIG.markerRingSize, 32);
        const pulseMaterial = new THREE.MeshBasicMaterial({
          color: CONFIG.markerPulseColor,
          transparent: true,
          opacity: 0.6,
          side: THREE.DoubleSide
        });
        
        // Create a 3D object for the pulse ring
        const pulse = new THREE.Group();
        const pulseMesh = new THREE.Mesh(pulseGeometry, pulseMaterial);
        
        // Make the ring face the camera
        pulseMesh.lookAt(0, 0, 0);
        pulse.add(pulseMesh);
        
        // Position pulse at same coordinates as marker
        pulse.position.set(position.x, position.y, position.z);
        pulse.lookAt(0, 0, 0);
        pulse.name = 'priest-pulse';
        pulse.priestData = priest;
        
        // Add random offset for animation
        pulseMesh.pulseOffset = Math.random() * Math.PI * 2;
        
        // Add to pulse meshes array for animation
        pulseMeshes.push(pulseMesh);
        
        // Add pulse to scene
        scene.add(pulse);
        
        // Add invisible larger detection ring
        const invisibleRingGeometry = new THREE.CircleGeometry(CONFIG.markerRingSize * 4, 32);
        const invisibleRingMaterial = new THREE.MeshBasicMaterial({
          transparent: true,
          opacity: 0.0, // Completely invisible
          side: THREE.DoubleSide
        });
        
        const invisibleRing = new THREE.Mesh(invisibleRingGeometry, invisibleRingMaterial);
        
        // Make it face the camera
        invisibleRing.lookAt(0, 0, 0);
        
        // Position at same coordinates as marker
        invisibleRing.position.set(position.x, position.y, position.z);
        invisibleRing.name = 'priest-marker-invisible';
        invisibleRing.priestData = priest; // Same priest data
        
        // Add to scene
        scene.add(invisibleRing);
      });
    }

    // Show priest info in the panel
    function showPriestInfo(priest) {
      const infoPanel = document.getElementById('infoPanel');
      const priestName = document.getElementById('priestName');
      const priestInfo = document.getElementById('priestInfo');
      
      // Set priest name
      priestName.textContent = priest.Name;
      
      // Clear previous info
      priestInfo.innerHTML = '';
      
      // Add fields in configured order
      CONFIG.fieldOrder.forEach(field => {
        if (priest[field]) {
          const row = document.createElement('div');
          row.className = 'info-row';
          
          if (field === 'Contact/Website' && priest[field].startsWith('http')) {
            row.innerHTML = `<strong>${field}:</strong> <a href="${priest[field]}" target="_blank" class="info-link">${priest[field]}</a>`;
          } else {
            row.innerHTML = `<strong>${field}:</strong> <p>${priest[field]}</p>`;
          }
          
          priestInfo.appendChild(row);
        }
      });
      
      // Add Google Maps link
      const mapsRow = document.createElement('div');
      mapsRow.className = 'info-row';
      mapsRow.innerHTML = `<a href="${priest.GoogleMaps}" target="_blank" class="info-link">View on Google Maps</a>`;
      priestInfo.appendChild(mapsRow);
      
      // Show the info panel
      infoPanel.style.display = 'block';
    }
    
    // Handle search input
    function handleSearch(event) {
        const searchTerm = event.target.value.toLowerCase();
        const searchResultsContainer = document.getElementById('searchResults');
        
        // Reset search results
        searchResultsContainer.innerHTML = '';
        searchResults = [];
        selectedSearchIndex = -1;
        
        if (searchTerm.length < 1) {
            searchResultsContainer.style.display = 'none';
            resetAllMarkers();
            return;
        }
        
        // Filter priests based on search term
        searchResults = priests.filter(priest => 
            priest.Name.toLowerCase().includes(searchTerm) || 
            (priest['Location/Area'] && priest['Location/Area'].toLowerCase().includes(searchTerm))
        );
        
        // Highlight matching markers
        const markers = globe.children.filter(obj => obj.name === 'priest-marker');
        markers.forEach(marker => {
            const priest = marker.priestData;
            const isMatch = searchResults.some(p => p.Name === priest.Name);
            
            marker.material.color.set(isMatch ? 'yellow' : CONFIG.markerColor);
        });
        
        // Populate search results dropdown
        if (searchResults.length > 0) {
            searchResults.forEach((priest, i) => {
            const resultItem = document.createElement('div');
            resultItem.className = 'search-result-item';
            // Use consecutive tabindex values starting from 1 higher than the search input
            resultItem.tabIndex = i + 200; 
            resultItem.textContent = `${priest.Name} (${priest['Location/Area'] || 'Unknown'})`;
            
            // Add click and keydown handlers
            resultItem.addEventListener('click', () => {
                showPriestInfo(priest);
                focusOnPoint(priest.Latitude, priest.Longitude);
                highlightSelectedPriest(priest);
                searchResultsContainer.style.display = 'none';
                document.getElementById('searchInput').value = '';
            });
            
            resultItem.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                resultItem.click();
                }
            });
            
            searchResultsContainer.appendChild(resultItem);
            });
            
            searchResultsContainer.style.display = 'block';
        } else {
            searchResultsContainer.style.display = 'none';
        }
    }

    function clearSearchResults(searchResultsContainer) {
        searchResultsContainer.style.display = 'none';
        // Clear search input
        document.getElementById('searchInput').value = '';
    }

    function clickSearchResult(priest, searchResultsContainer) {
        // Show info panel
        showPriestInfo(priest);
        
        // Focus on the point
        focusOnPoint(priest.Latitude, priest.Longitude);
        
        // Reset markers color
        markers.forEach(marker => {
            marker.material.color.set(CONFIG.markerColor);
        });
    }

    // Focus camera on a specific point
    function focusOnPoint(lat, lng, zoomLevel = 200.0) {
      // Calculate target position with Earth radius and adjusted coordinates
      const targetPosition = getPointOnGlobe(lat - 5, lng, 2);
      
      // Normalized direction vector
      const direction = new THREE.Vector3();
      direction.subVectors(targetPosition, new THREE.Vector3(0, 0, 0)).normalize();
      
      // Get current distance from camera to center
      const currentDistance = camera.position.distanceTo(new THREE.Vector3(0, 0, 0));
      
      // Calculate target distance
      const targetDistance = Math.max(
        controls.minDistance,
        Math.min(controls.maxDistance, currentDistance * (zoomLevel / CONFIG.currentZoomLevel))
      );
      CONFIG.currentZoomLevel = zoomLevel;

      // Calculate new camera position
      const newPosition = direction.multiplyScalar(targetDistance);
      
      // Animate camera move
      const startPosition = camera.position.clone();
      const startTime = Date.now();
      
      function animateCamera() {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / CONFIG.focusAnimationDuration, 1);
        
        // Easing function (ease-out)
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        
        // Interpolate position
        camera.position.lerpVectors(startPosition, newPosition, easeProgress);
        
        // Look at center
        camera.lookAt(0, 0, 0);
        
        // Update controls
        controls.update();
        
        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animateCamera);
        } else {
          // Animation complete - update controls target
          controls.target.set(0, 0, 0);
          controls.update();
        }
      }
      
      // Start animation
      animateCamera();
    }

    // Initialize the application
    init();
    </script>
</body>
</html>
