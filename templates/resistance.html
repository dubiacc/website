<!DOCTYPE html>
<html lang="$$LANG$$">
<head>
  <title>$$resistance-title$$</title>
  <meta name="description" content="$$resistance-desc$$">
  <link rel="alternate" hreflang="en" href="$$ROOT_HREF$$/en/resistance.html">
  <link rel="alternate" hreflang="de" href="$$ROOT_HREF$$/de/resistance.html">
  <link rel="alternate" hreflang="fr" href="$$ROOT_HREF$$/fr/resistance.html">
  <link rel="alternate" hreflang="es" href="$$ROOT_HREF$$/es/resistance.html">
  <link rel="alternate" hreflang="it" href="$$ROOT_HREF$$/it/resistance.html">
  <link rel="alternate" hreflang="pt" href="$$ROOT_HREF$$/pt/resistance.html">
  <link rel="alternate" hreflang="x-default" href="$$ROOT_HREF$$/en/resistance.html">
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#161616" media="(prefers-color-scheme: dark)">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-RegularItalic.woff2" as="font" type="font/woff2">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-Regular.woff2" as="font" type="font/woff2">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-Semibold.woff2" as="font" type="font/woff2">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <link rel="stylesheet" href="/static/css/leaflet.css" rel="stylesheet" type="text/css"/>
  <script src="/static/js/leaflet.js" type="application/javascript"></script>
  <script src="/static/js/qrcode.min.js" type="application/javascript"></script>
  <link href="/static/css/maplibre-gl.css" rel="stylesheet" type="text/css"/>
  <script src="/static/js/maplibre-gl.js" type="application/javascript"></script>
  <script src="/static/js/leaflet-maplibre-gl.js" type="application/javascript"></script>
  <script src="/static/js/geotz.js" type="application/javascript"></script>

  <style>
    :root {
      --background-color: #f5f5f5;
      --text-color: #333;
      --panel-bg: rgba(255, 255, 255);
      --panel-text: #333;
      --atmospheric-color: #ccc;
      --search-bg: white;
      --search-text: #333;
      --search-placeholder: #999;
      --search-results-bg: white;
      --search-results-hover: #f0f0f0;
      --link-color: #8b0000;
      --focus-col: rgb(61, 99, 170);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #121212;
        --text-color: #f5f5f5;
        --panel-bg: rgba(33, 33, 33);
        --panel-text: #f5f5f5;
        --atmospheric-color: #3a228a;
        --search-bg: #333;
        --search-text: #f5f5f5;
        --search-placeholder: #777;
        --search-results-bg: #333;
        --search-results-hover: #444;
        --link-color: #ff6b6b;
      }
    }
    
    * {
        margin: 0px;
        padding: 0px;
    }

    html {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background-color);
      font-family: Arial, sans-serif;
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      height: 100%;
    }
    
    #mapContainer {
        position: absolute;
        height: 100%;
        width: 100%;
        z-index: 1;
    }
    
    .search-container {
      display: flex;
      justify-content: space-between;
      flex-direction: column;
      z-index: 1;
      flex-grow: 1;
    }

    #priestInfo {
        display: flex;
        flex-direction: column;
    }

    .search-input {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        padding: 10px 5px;
        font-style: italic;
        border: none;
        background: var(--search-bg);
        color: var(--search-text);
        font-size: 1.2rem;
        outline: none;
        border: 3px solid var(--search-bg);
        pointer-events: all;
        margin-top: 10px;
    }
    
    @media screen and (max-width: 450px) {
        .search-input, .sidebar-links, .search-container .links, .info-panel {
          margin: 0px 10px;
        }
        .info-panel {
          margin-bottom: 10px;
        }
        .search-input {
          margin-top: 5px;
          margin-bottom: 5px;
          padding: 5px;
        }
        .calendar-grid {
          gap: 2px;
          margin-bottom: 10px;
        }
        .calendar-day {
          border: none;
        }
        .calendar-day {
          padding: 5px;
        }
        .calendar-day-header {
          padding: 2px;
        }
        .calendar-title {
          hyphens: auto;
          word-break: break-all;
        }
        .calendar-popup {
          border-radius: 0px;
          overflow-y: scroll;
        }
        .calendar-day.has-events::after {
          bottom: 1px;
        }
        .calendar-bottom {
          padding: 0px 10px;
        }
        .calendar-top {
          padding: 20px 10px;
        }
    }
    .search-input:focus {
        border: 3px solid var(--focus-col);
    }

    .search-input::placeholder {
      color: var(--search-placeholder);
    }
    
    .search-results {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        font-style: italic;
        overflow-y: scroll;
        background: var(--search-results-bg);
        border-radius: 0 0 5px 5px;
        z-index: 11;
        pointer-events: all;
        max-height: 200px;
        flex-direction: column;
        overflow-y: scroll;
    }
    
    .search-result-item {
      padding: 5px;
      cursor: pointer;
      transition: background-color 0.2s;
      border: 3px solid transparent;
      font-size: 1.2rem;
    }
    
    .search-result-item:focus {
        border: 3px solid var(--focus-col);
        background-color: var(--search-results-hover);
    }
    
    .search-result-item:hover {
      background-color: var(--search-results-hover);
    }

    .info-panel {
        margin-bottom: 10px;
        box-shadow: 2.5px 2.5px 5px black;
        pointer-events: all;
        position: relative;
        background: white;
        padding: 20px;
        max-height: 70vh;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        flex-direction: column;
        flex-grow: 0;
        background: var(--panel-bg);
        color: var(--panel-text);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        font-family: 'Times';
        font-style: italic;
        font-size: 1.2rem;
    }
    
    .info-panel h2 {
        margin-top: 0;
        font-size: 2rem;
        font-weight: bold;
    }
    
    .info-row {
        margin-bottom: 4px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
    }
    
    /* Add these styles to your existing CSS */
    .notes-section, .mass-times-section {
      padding-top: 8px;
    }

    .notes-section strong, .mass-times-section strong {
      display: inline;
      padding-right: 5px;
    }

    .notes-section p, .mass-times-section p {
      display: inline;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .mass-times-section {
      color: #8b0000;
      font-weight: 500;
    }

    @media (prefers-color-scheme: dark) {
      .notes-section, .mass-times-section {
        border-top: 1px solid rgba(255,255,255,0.1);
      }
      
      .mass-times-section {
        color: #ff6b6b;
      }
    }

    /* Make title more prominent */
    #priestName {
      font-family: 'UnifrakturMaguntia', serif;
      font-size: 2.5rem;
    }

    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        background: #cc0000;
        font-size: 2rem;
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    .info-link {
      background: #004970;
      color: white;
      font-weight: bold;
      text-decoration: underline;
    }
    .info-link.maps {
        background: #700000;
        color: white;
        padding: 10px;
        font-weight: bold;
        font-style: normal;
        font-family: sans-serif;
        margin-top: 1rem;
        text-decoration: none;
        display: block;
        text-align: center;
    }
    
    .info-link.maps:hover {
      text-decoration: underline;
    }

  .parishes-section h3 {
    margin-top: 0;
    font-size: 1.3rem;
  }

  .parishes-list {
    list-style-type: none;
    padding-left: 0;
    margin-top: 5px;
    max-height: 150px;
    overflow-y: scroll;
  }

  @media (prefers-color-scheme: dark) {
    .parishes-section {
      border-top: 1px solid rgba(255,255,255,0.1);
    }
  }

  .priest-link {
      color: var(--link-color);
      text-decoration: underline;
      cursor: pointer;
      margin-top: 5px;
      display: inline-block;
    }
    
    .priest-link:hover {
      text-decoration: none;
    }
    
    .parish-item {
      cursor: pointer;
      transition: background-color 0.2s;
      padding: 4px;
      margin-bottom: 2px;
    }
    
    .parish-item strong {
      text-decoration: underline;
    }

    .parish-item:hover {
      background-color: rgba(128, 128, 128, 0.1);
      border-radius: 3px;
    }

    .links {
      display: flex;
      flex-direction: row;
      z-index: 1000;
      margin-top: 10px;
    }

    .outbound-link, .outbound-link:visited, .outbound-link:focus, .outbound-link:hover {
      color: white;
      font-size: 1rem;
      background-color: black;
      margin-right: 10px;
      padding: 5px;
      text-decoration: none;
      pointer-events: all;
    }

    @media (max-width: 800px) {
      .title {
        display: none;
      }
      
      .links {
        width: 100%;
        display: flex;
        flex-grow: 1;
      }
      .links > div {
        flex-direction: row;
        display: flex;
        flex-grow: 0;
      }
      .links > div > a {
        margin-top: 5px;
        flex-grow: 1;
        display: flex;
      }

      .info-panel {
        max-height: 60vh;
        font-size: 0.9rem;
      }
      #priestName {
        font-size: 1.4rem;
      }
      .search-input {
        font-size: 1.2rem;
      }
      .search-results, .search-result-item {
        font-size: 1.2rem;
      }
      .outbound-link, .outbound-link:visited, .outbound-link:focus, .outbound-link:hover {
        font-size: 1rem;
      }
      #priestInfo {
        font-size: 1rem;
      }
    }

    /* Import the same fonts as dubia.cc */
    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 400;
      font-style: normal;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-Regular.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 400;
      font-style: italic;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-RegularItalic.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 600;
      font-style: normal;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-Semibold.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Kanzlei Initialen';
      src: url('/static/font/kanzlei/Kanzlei-Initialen-D.ttf') format('truetype');
      font-display: swap;
      unicode-range: U+0044;
    }

    :root {
      --GW-serif-font-stack: "Source Serif Pro", "Apple Garamond", "Baskerville", "Libre Baskerville", "Droid Serif", "Times New Roman", "Times", serif;
      --GW-sans-serif-font-stack: "Lucida Sans Unicode", "Helvetica", "Trebuchet MS", sans-serif;
      --GW-monospaced-font-stack: "IBM Plex Mono", "Liberation Mono", "Consolas", "Courier", monospace;
    }

    /* Compact header styles */
    #header {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      max-width: 450px;
      z-index: 1000;
      pointer-events: none;
    }

    @media screen and (min-width: 450px) {
        #header {
          min-width: 450px;
        }
    }

    .title {
      font-family: 'UnifrakturMaguntia', serif;
      font-size: 2.5rem;
      color: var(--background-color);
      text-align: center;
      background: var(--text-color);
      mix-blend-mode: difference;
      width: 100%;
      text-align: center;
      font-family: 'UnifrakturMaguntia', serif;
      z-index: 1000;
      padding: 10px 0px;
      margin-bottom: 10px;
    }

    #sidebar {
      display: flex;
      justify-content: center;
      flex-direction: column;
      margin-top: 10px;
    }

    #sidebar a {
      display: block;
      border: 1px dotted currentColor;
      text-align: center;
      margin: 0 2px;
      color: var(--text-color);
      text-decoration: none;
      font-family: var(--GW-serif-font-stack);
    }

    #sidebar a.logo {
      display: flex;
      align-items: center;
      margin: 1px 0;
      background-color: var(--background-color);
    }

    #sidebar .sidebar-links {
      flex: 1 1 100%;
      display: flex;
      flex-flow: row wrap;
      pointer-events: initial;
    }

    #sidebar .sidebar-links > a {
        pointer-events: initial;
    }

    #sidebar .sidebar-links > * {
      font-variant-caps: small-caps;
      background: var(--background-color);
      align-content: center;
      justify-content: center;
      flex: 1;
      padding: 5px;
      pointer-events: initial;
      cursor: pointer;
    }

    /* Make the header more compact on mobile */
    @media all and (max-width: 649px) {
      .title {
        font-size: 1.8rem;
      }
      
      #sidebar .sidebar-links a {
        padding: 3px 5px;
        font-size: 0.9rem;
      }
    }

    /* Map-specific styles */
    .leaflet-popup-content {
      font-family: 'Source Serif Pro', serif;
      font-size: 1rem;
    }
    
    .priest-marker {
      background-color: #cc0000;
      border-radius: 50%;
      border: 2px solid white;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    
    .parish-marker {
      background-color: #003399;
      border-radius: 50%;
      border: 2px solid white;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    
    /* For the pulsing effect */
    .pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(204, 0, 0, 0.7);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(204, 0, 0, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(204, 0, 0, 0);
      }
    }

    /* For dark mode maps */
    .dark-map .leaflet-tile {
      filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
    }
    
    .dark-map .leaflet-container {
      background: #303030;
    }
    
    @font-face {
      font-family: 'UnifrakturMaguntia';
      font-style: normal;
      font-weight: 400;
      src: url('/static/font/unifraktur/UnifrakturMaguntia-Regular.ttf') format('ttf');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      font-display: swap;
    }

        .calendar-btn {
      background: #437700;
      color: white;
      padding: 10px;
      font-weight: bold;
      font-style: normal;
      font-family: sans-serif;
      margin-top: 0.5rem;
      text-decoration: none;
      display: block;
      text-align: center;
      cursor: pointer;
    }

    .calendar-btn:hover {
      background: #5a9900;
    }

    .calendar-popup {
      position: absolute;
      flex-grow: 1;
      justify-content: center;
      background: var(--panel-bg);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      overflow-y: auto;
      flex-direction: column;
      display: none;
      min-height: 100%;
      padding: 0px 20px;
      justify-content: flex-start;
      max-width: 410px;
      border-radius: 6px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .calendar-top {
      display: flex;
      flex: 0;
      flex-direction: column;
      padding: 20px 0px;
    }

    .calendar-bottom {
      display: flex;
      flex: 1;
      flex-direction: column;
      justify-content: flex-start;
      overflow-y: scroll;
    }

    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: start;
      margin-bottom: 5px;
    }

    .calendar-title {
      font-size: 1.5rem;
      font-weight: bold;
    }

    .calendar-close {
      background: #cc0000;
      color: white;
      width: 2.5rem;
      font-weight: bold;
      border: none;
      font-size: 2rem;
      cursor: pointer;
    }

    .calendar-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .calendar-nav button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-color);
    }

    .calendar-month-year {
      font-size: 1.2rem;
      font-weight: bold;
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 5px;
      margin-bottom: 15px;
    }

    .calendar-day-header {
      text-align: center;
      font-weight: bold;
      padding: 5px 0;
    }

    .calendar-day {
      text-align: center;
      padding: 10px 5px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      position: relative;
      cursor: pointer;
    }

    .calendar-day.has-events {
      position: relative;
      z-index: 1000;
      pointer-events: all !important;
    }

    .calendar-day:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .calendar-day.has-events::after {
      content: "";
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #1e88e5;
    }

    .calendar-day.other-month {
      color: rgba(128, 128, 128, 0.5);
    }

    .calendar-event {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(0, 0, 0, 0.05);
    }

    .calendar-event.cancelled {
      text-decoration: line-through;
      color: gray;
    }

    .calendar-event-title {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .calendar-event-time {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .calendar-event-location {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .calendar-event-priest {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .calendar-event-notes {
      font-style: italic;
      font-size: 0.9rem;
    }

    .calendar-event-cancelled {
      color: #cc0000;
      font-weight: bold;
      font-size: 0.9rem;
      margin-top: 5px;
    }

    .donate-link {
      background: #cc7700;
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      text-decoration: none;
      font-size: 0.9rem;
      display: inline-block;
      margin-top: 5px;
    }

    .donate-link:hover {
      background: #ff9900;
    }

    .show-more-btn {
      background: #004970;
      color: white;
      padding: 10px;
      font-weight: bold;
      font-style: normal;
      font-family: sans-serif;
      margin-top: 0.5rem;
      text-decoration: none;
      display: block;
      text-align: center;
      cursor: pointer;
    }

    .show-more-btn:hover {
      background: #006699;
    }

    /* Updated styling for the UI improvements */

/* Action buttons container */
.actions-container {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  margin-top: 16px;
  width: 100%;
}

/* Action button styles */
.action-btn {
  background: #700000;
  color: white;
  padding: 10px;
  font-weight: bold;
  font-style: normal;
  font-family: sans-serif;
  text-decoration: none;
  display: inline-block;
  text-align: center;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  flex-grow: 1;
  min-width: calc(50% - 8px);
  font-size: 0.9rem;
}

.action-btn:hover {
  background: #900000;
}

/* Donate button specific styling */
.donate-btn {
  background: #cc7700;
}

.donate-btn:hover {
  background: #ff9900;
}

/* Improve info panel */
.info-panel {
  max-width: 450px;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  border-radius: 6px;
  overflow: hidden;
}

/* Fix search results display */
.search-results {
  width: 100%;
  max-height: 250px;
  border: 1px solid rgba(0, 0, 0, 0.1);
}

.search-result-item {
  padding: 12px;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
  transition: all 0.2s ease;
}

.search-result-item:hover, .search-result-item:focus {
  background-color: rgba(112, 0, 0, 0.1);
  outline: none;
}

/* Parishes section formatting */
.parishes-section {
  padding-top: 8px;
}

.parishes-list {
  max-height: 180px;
  overflow-y: auto;
  border: 1px solid rgba(0, 0, 0, 0.1);
  border-radius: 4px;
}

.parish-item:hover {
  background-color: rgba(112, 0, 0, 0.1);
}

/* Consistent font size */
#priestName {
  font-family: 'Source Serif Pro', serif;
  font-size: 1.8rem;
  font-weight: bold;
}

/* Improve close button */
.close-btn {
  font-size: 1.5rem;
  width: 36px;
  height: 36px;
  background: #700000;
  color: white;
  border-radius: 50%;
  top: 12px;
  right: 12px;
}

@media (max-width: 800px) {
  .info-panel {
    max-height: 70vh;
  }
  
  .calendar-popup {
    max-width: none;
  }

  .action-btn {
    font-size: 0.85rem;
    padding: 8px;
  }
  
  #priestName {
    font-size: 1.5rem;
  }
}

/* Fix outbound links display based on search visibility */
.search-container:has(.search-results[style*="display: flex"]) .links {
  display: none;
}

/* Priest and parish markers hover effect */
.parish-marker, .priest-marker {
  transition: transform 0.2s ease;
}

.parish-marker:hover, .priest-marker:hover {
  transform: scale(1.2);
}

/* Make the calendar grid more attractive */
.calendar-grid {
  border-radius: 4px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.03);
}

.calendar-day-header {
  background: #700000;
  color: white;
  padding: 8px;
}

.calendar-day {
  transition: all 0.2s ease;
}

.calendar-day:hover {
  background: rgba(112, 0, 0, 0.1);
}

.calendar-day.has-events {
  font-weight: bold;
  color: #700000;
}

/* Improved action buttons container */
.actions-container {
  display: grid;
  grid-template-columns: repeat(2, 1fr);
  gap: 8px;
  margin-top: 16px;
  width: 100%;
}

/* Action button styles */
.action-btn {
  background: #700000;
  color: white;
  padding: 10px;
  font-weight: bold;
  font-style: normal;
  font-family: sans-serif;
  text-decoration: none;
  display: inline-block;
  text-align: center;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  font-size: 0.9rem;
}

.action-btn:hover {
  background: #900000;
}

/* Donate button specific styling */
.donate-btn {
  background: #cc7700;
}

.donate-btn:hover {
  background: #ff9900;
}

/* Improved search results */
.search-results {
  max-height: 250px;
  width: 100%;
  border: 1px solid rgba(0, 0, 0, 0.1);
  overflow-y: auto;
  background: var(--search-results-bg);
  border-radius: 0 0 5px 5px;
  z-index: 11;
  pointer-events: all;
  flex-direction: column;
}

.search-result-item {
  padding: 12px;
  cursor: pointer;
  transition: background-color 0.2s;
  border-bottom: 1px solid rgba(0, 0, 0, 0.05);
  font-size: 1rem;
}

.search-result-item small {
  color: #666;
  font-size: 0.85rem;
}

.search-result-item:focus {
  border: 3px solid var(--focus-col);
  background-color: var(--search-results-hover);
  outline: none;
}

.search-result-item:hover {
  background-color: var(--search-results-hover);
}

/* Connected result styles */
.search-result-item.connected {
  border-left: 3px solid #00cc00;
  padding-left: 9px;
}

/* Make sure priest name displays correctly */
#priestName {
  font-size: 1.8rem;
  font-weight: bold;
  line-height: 1.2;
}

/* Improve mobile display */
@media (max-width: 800px) {
  .actions-container {
    grid-template-columns: 1fr;
  }
  
  #priestName {
    font-size: 1.5rem;
  }
}
  </style>
</head>
<body>

  <header id="header">
    <nav id="sidebar">
      <h1 class="title">$$resistance-title$$</h1>
      <div class="sidebar-links">
        <a href="/$$LANG$$">$$special-homepage-desc$$</a>
        <a href="/$$LANG$$/$$special-topics-path$$">$$special-articles-title$$</a>
        <a href="/$$LANG$$/$$special-resources-path$$">$$special-resources-title$$</a>
      </div>
    </nav>

    <div class="search-container">
      <div style="display: flex; flex-direction: column;">
        <input autofocus="true" type="text" class="search-input" placeholder="$$search-placeholder$$" id="searchInput">
        <div class="links">
          <a class="outbound-link" href="mailto:info@dubia.cc">$$report-error$$</a>
          <a class="outbound-link" href="mailto:info@ducia.cc">$$request-mass$$</a>
        </div>
        <div class="search-results" id="searchResults">
        </div>
      </div>

      <div class="info-panel" id="infoPanel">
          <button class="close-btn" id="closeBtn">×</button>
          <h2 id="priestName"></h2>
          <div id="priestInfo"></div>
        </div>
    </div>
  </header>
  
  <div id="mapContainer"></div>

  <script>

// Configuration
window.CONFIG = {
  // Default center of the map (will be overridden by geolocation if available)
  defaultLat: 48.8566,
  defaultLng: 2.3522,
  defaultZoom: 4,
  
  // Styling
  priestMarkerColor: '#cc0000',
  parishMarkerColor: '#003399',
  lineColor: '#ccc',
  lineWeight: 2,
  lineOpacity: 0.7,
  
  // Marker sizes
  priestMarkerSize: 10,
  parishMarkerSize: 7,
  
  // Google Sheet ID
  sheetId: "16wO1gTdilEcdqsWfJ0mZn-hgYD2MRJ1SCKSAHzcDj18",
  
  // Current language
  currentLanguage: "$$LANG$$",
  
  // Min/max zoom for map controls
  minZoom: 2,
  maxZoom: 18,
};

// Data storage
window.locations = [];
window.religious = [];
window.events = [];
window.fundingData = [];
window.cancelledEvents = [];

// Maps for quick lookup
window.locationMap = new Map();
window.religiousMap = new Map();
window.fundingMap = new Map();
window.cancelledEventsMap = new Map();

// Map and layers
let map;
let priestMarkers = L.layerGroup();
let parishMarkers = L.layerGroup();
let connectionLines = L.layerGroup();
let userLocationMarker = null;

// Default data (fallback)
const defaultLocationsData = `"LocationID carmelites-hf-ireland","LocationType Convent","Name Carmelites of the Holy Face of Jesus","ReligiousIdMulti mother-irene, sister-anne-marie","Location 51.79025633971586, -9.112158704807591","Website https://carmelitesholyface.com/","GoogleMaps https://maps.app.goo.gl/WaokWwYAmujka5Sr7","ContactEmail ","ContactPhone ","Notes ",,,,,,,,,,,,,,,,
"hjm-seminary","Seminary","Hearts of Jesus and Mary Seminary","fr-chazal","10.342421706935285, 123.83294807185935","https://www.facebook.com/mariancorpsofst.piusx","https://maps.app.goo.gl/o8xmm2b5eQgNXDpy6",,,,,,,,,,,,,,,,,,,
"discalced-carm-ph","Mission","Our Lady of Mt. Carmel Oratory",,"14.185634883816563, 121.23247682974647","https://discalcedcarmelites.org.ph/","https://maps.app.goo.gl/tXxyMGo6smjHdLW1A",,,"https://www.facebook.com/ScapularConfraternityPH/",,,,,,,,,,,,,,,,
"carmel-stjosef-ger","Convent","Karmel St. Josef",,"48.1881613609616, 12.668123403146767","https://archive.is/FOkbD","https://maps.app.goo.gl/6uYEqhqvvmJskU2q9",,,"mittwochs und donnerstags von 10.45 Uhr – 11.15 Uhr",,,,,,,,,,,,,,,,
"mosteiro-santa-cruz","Convent","Mosteiro da Santa Cruz","bp-aquino","-22.188609036471846, -42.54923387378506","https://www.mosteirodasantacruz.org/","https://maps.app.goo.gl/fctDJNpysKvZGV7r9",,,,,,,,,,,,,,,,,,,
"nd-de-bellaigue","Convent","Monastery of Notre-Dame de Bellaigue","fr-placide","46.159681204461975, 2.7036650318380326",,"https://maps.app.goo.gl/aTsGWQcpfW6sUds99",,,,,,,,,,,,,,,,,,,
"sajm-seminary","Seminary","Séminaire Saint Louis Marie Grignion de Montfort",,"47.74520085682513, -0.41836116956105057","https://apotresdejesusetdemarie.fr/","https://maps.app.goo.gl/VEEQd6oNFp81vAa57",,,,,,,,,,,,,,,,,,,
"dominicans-avrille","Seminary","Couvent de la Haye-aux-Bonshommes","bp-faure","47.48959520825813, -0.5991638769394454","https://www.dominicainsavrille.fr/","https://maps.app.goo.gl/W9JSLZMaT2mRxRuN7",,,"Dominicans of Avrillé",,,,,,,,,,,,,,,,
"fbmv-monastery-br","Convent","Familia Beatae Mariae Virginis","fr-de-souza","-12.647034043093072, -38.454641870627555","fbmv.org","https://maps.app.goo.gl/QnUzGvGnKJqhCS7t5",,,,,,,,,,,,,,,,,,,
"escravas-de-maria","Convent","Escravas de Maria Rainha da Paz",,"-20.49268829846052, -54.588381673599734","https://escravasdemaria.blogspot.com/","https://maps.app.goo.gl/2A6QdLkDAtdPqGjL7",,,,,,,,,,,,,,,,,,,
"couvent-st-francois","Convent","Couvent Saint-François","fr-antoine","46.14674140135561, 4.674146280722483",,"https://maps.app.goo.gl/MvWE3PUgDHEmEM387",,,,,,,,,,,,,,,,,,,
"iglesia-san-jose-mx","Parish","Iglesia San José",,"25.413769408984333, -101.01484650357327","https://archive.is/wip/hSBrt","https://maps.app.goo.gl/JNjkwjnAYyzrcE3y6",,,,,,,,,,,,,,,,,,,
"sisters-of-cenacle-it","Convent","Discepole Del Cenacolo",,"41.686852501833265, 12.76151038779575","https://doncurzionitoglia.wordpress.com/","https://maps.app.goo.gl/KQmP2WbXb3euGsEb7",,,,,,,,,,,,,,,,,,,
"insituto-sen-do-rosario","Convent","Instituto Nossa Senhora do Rosário",,"-16.18156528170096, -49.025071755269636","https://archive.ph/wip/0J7iG","https://maps.app.goo.gl/x3TEJvMg4wWeytGm9",,,,,,,,,,,,,,,,,,,
"two-hearts-ny","Parish","Two Hearts Chapel","fr-voigt","45.44632838772738, -94.19997944646171","https://www.olhcutica.com/contact-us/","https://maps.app.goo.gl/mXU9QbHxmbTEhaCd7",,,,,,,,,,,,,,,,,,,
"korea-1","Home","K2 Building 870 Tongil-ro","fr-chazal","37.62066477428733, 126.92046529600468","http://mcspx.kr/","https://maps.app.goo.gl/kQjuF4DcLfTeL2277",,,"4th Floor",,,,,,,,,,,,,,,,
"brazil-1","Parish","Capela Ns. Senhora Auxiliadora","bp-aquino","-25.486584295509132, -54.51657041329986","https://linktr.ee/fronteiracatolica","https://maps.app.goo.gl/wBW5vW7Yek9aMjGs8",,,,,,,,,,,,,,,,,,,
"france-1","Parish","Resistance Lyon","bp-morgan","45.75765253947298, 4.833849821208268","https://archive.is/wip/AT1ci","https://maps.app.goo.gl/GZxKd7uwh4BTWz2X8",,,,,,,,,,,,,,,,,,,
"france-2","Parish","Resistance Vesoul","pr005","47.6302961028553, 6.1518852013996606","https://archive.is/wip/0P4F0","https://maps.app.goo.gl/KzsbiRKeWSA8ye1S7",,,"Messes: dimanche (sundays)",,,,,,,,,,,,,,,,
"france-3","Parish","Chapelle funéraire de Chantemerle","pr005","46.67380685692015, -0.6222973967898845","https://archive.is/wip/F85IR","https://maps.app.goo.gl/zRSjMHUpYHBwc5rCA",,,"Près Les Moutiers-sous-Chantemerle",,,,,,,,,,,,,,,,
"st-dominics-texas","Parish","St. Dominic's Chapel","fr-brocard, fr-voigt","29.561801447715514, -98.08086831544996","https://latinmasstexas.wordpress.com/","https://maps.app.goo.gl/qrok5TjTm4X3jtsB8",,,"Mass times are available by E-Mail only (privacy)",,,,,,,,,,,,,,,,
"france-1","Parish","Notre-Dame Gardienne de la Foi","fr-merode","43.11601384000813, -0.07281460031554028","https://notredamegardiennedelafoi.fr/poueyferre-agenda-des-messes/","https://maps.app.goo.gl/KyqYcgM63NkZqNfi9",,,,,,,,,,,,,,,,,,,
"france-4","Parish","Chapelle Sainte Cécile","pr018","44.7951732651947, -0.2649078805026371","https://archive.is/5UynZ","https://maps.app.goo.gl/z4z9vTiFoBxSHv3z6",,,,,,,,,,,,,,,,,,,
"france-5","Parish","Prieuré Notre-Dame du Christ-Roi","fr-pivert","46.6872639919537, 1.768072490512093","https://abbe-pivert.com/ministere-dominical/","https://maps.app.goo.gl/RMRd9NZu7g3fQNKi8",,,,,,,,,,,,,,,,,,,
"germany-1","Parish","Kloster Reichenstein","fr-lang","50.53938053457885, 6.200905050750951","https://archive.is/wip/t7ci0","https://maps.app.goo.gl/CSmSZxZzkLPpTcNC9",,,"Monastery itself is anti-Resistance, but they host Fr. Lang ",,,,,,,,,,,,,,,,
"france-6","Mission","Resistance Bootzheim","pr017","48.18820799140211, 7.572019137184236","https://archive.is/wip/fMTKy","https://maps.app.goo.gl/NnQowpQDU4L1sHe57",,,,,,,,,,,,,,,,,,,
"france-7","Mission","Prieuré du Coeur Immaculé","pr019","50.93784402582978, 2.541926369489603","https://archive.is/VAi3J","https://maps.app.goo.gl/6SjTNvedJvXDhFnt5",,,,,,,,,,,,,,,,,,,
"usa-oratory-sfheart-mary","Parish","Oratory of the Sorrowful Heart of Mary","fr-hewko, fr-ruiz","43.85315057363545, -71.90903296681068","https://www.stmaryskssspxmc.com","https://maps.app.goo.gl/dgFqaduxkLxLhDRa6",,,,,,,,,,,,,,,,,,,
"anaku-nigeria","Parish","Maria Virgo Fidelis Tridentine Priory Anaku","fr-chigbata","6.482843616569607, 6.93305980830839",,"https://maps.app.goo.gl/NH8izi9kb5uw22kq7",,,,,,,,,,,,,,,,,,,
"gabon-1","Home","gabon","fr-ondo","???","???","???",,,,,,,,,,,,,,,,,,,
"ireland-1-salthill","Home","Salthill, Galway, Ireland","fr-bufe","???","https://archive.is/8OH7m","???",,,,,,,,,,,,,,,,,,,
"ireland-2-kesh","Home","Kesh, Newry, and Dublin","fr-bufe","???","https://archive.is/8OH7m","???",,,,,,,,,,,,,,,,,,,
"ireland-3-newry","Home","Newry, Ireland","fr-bufe","???","https://archive.is/8OH7m","???",,,,,,,,,,,,,,,,,,,
"ireland-4-athlone","Home","Athlone, Ireland","fr-bufe","???","https://archive.is/8OH7m","???",,,,,,,,,,,,,,,,,,,
"ireland-5-dublin","Home","Dublin, Ireland","fr-bufe","???","https://archive.is/8OH7m","???",,,,,,,,,,,,,,,,,,,
"bruehwiler-st-gallen-ch","Home","Oratorium Heiliger Bruder Klaus Hüter des Vaterlandes","fr-bruhwiler","47.40894072384693, 9.331886481300096","https://abbe-pivert.com/wp-content/uploads/2019/05/Oratorium-St.-Gallen-GO-Nr.-1-2019.pdf","https://maps.app.goo.gl/W9vP4EwzmJkX4QYh9",,,,,,,,,,,,,,,,,,,
"chennai-st-anthony","Parish","St. Anthony’s Shrine",,"13.049088527376865, 80.2535663848687","https://www.facebook.com/indiatlm","https://maps.app.goo.gl/bhfT9UZEmyBx6giHA",,,,,,,,,,,,,,,,,,,
"kandigai-mcspx","Parish","SSPX- Marian Corps Fraire",,"12.635268838290955, 79.69335041962752",,"https://maps.app.goo.gl/p6nVJ5BRDHVzdvZG9",,,,,,,,,,,,,,,,,,,
"zendejas-ny","Parish","Bishop Zendejas Seminary","bp-zendejas","41.2499877080973, -73.52725929669987",,"https://maps.app.goo.gl/x12vemZXdKCvDXb37",,,,,,,,,,,,,,,,,,,
"olp-louisville","Parish","Our Lady of the Pillar","fr-bitzer, fr-oconnor","38.19488914004571, -85.76819954230683","https://olpchapel.org/","https://maps.app.goo.gl/a582GueWVnxNak8B6",,,,,,,,,,,,,,,,,,,
"vendee-1","Home","Resistance Vendee","fr-bruno",,,,,,,,,,,,,,,,,,,,,,
"st-athanasius-usa","Parish","Saint Athanasius Traditional Church","fr-ringrose, fr-da-damio","38.94979434012304, -77.26276890537048",,"https://maps.app.goo.gl/FRbhQYw44SJ2y4hj8",,,,,,,,,,,,,,,,,,,
"donauwoerth","Home","Resistance Donauwörth","fr-failer","48.717321761144945, 10.773400829313672",,"https://maps.app.goo.gl/p76ZVtAxMMdppMnr8",,,,,,,,,,,,,,,,,,,
"sajm-alsace","Parish","Paroisse St. Jean-Baptiste","fr-picot","48.9096022335556, 7.1448285153542805",,"https://maps.app.goo.gl/k4dZNvqEwVpbzTCF9",,,,,,,,,,,,,,,,,,,
"aigen-1","Parish","Resistance Österreich","fr-fuchs","48.64700146067714, 13.972704230677788",,"https://maps.app.goo.gl/UV32KC1tvGPVzmLt9",,,,,,,,,,,,,,,,,,,
"aldergrove-canada","Home","Coghlan Community Hall","fr-girouard","49.12586082924718, -122.51550652713061",,,,,,,,,,,,,,,,,,,,,
"stella-maris-houston","Parish","Miraculous Medal Church","fr-garcia, bp-zendejas","29.371624376970676, -95.02020323208488",,"https://maps.app.goo.gl/zqhKwAYjySdiZsL57",,,,,,,,,,,,,,,,,,,`;

const defaultReligiousData = `"ReligiousID bp-zendejas","Type Bishop","Name Gerardo Zendejas","BornYear ","AssociatesWith Resistance","UsualLocationID ","Beliefs NonSede","Country USA","Website https://thebluepaper.org/","OrdainedInRite OldRite","OrdainedBy Lefebvre","ConsecratedInRite OldRite","ConsecratedBy Williamson","BishopLine Lefebvre","ContactEmail ","ContactPhone ","Notes Consecrated bishop on May 11, 2017",,,,,,,,,,,,
"bp-faure","Bishop","Jean-Michel Faure","1941","Resistance",,"NonSede","France","https://dominicansavrille.us/","OldRite","Lefebvre","OldRite","Williamson","Lefebvre",,,"Consecrated bishop on March 19, 2015",,,,,,,,,,,,
"bp-aquino","Bishop","Tomas de Aquino","1954","Resistance",,"NonSede","Brazil","https://www.mosteirodasantacruz.org/","OldRite","Lefebvre","OldRite","Williamson","Lefebvre",,,"Consecrated bishop in 2015 in Brazil",,,,,,,,,,,,
"bp-stobnicki","Bishop","Michał Stobnicki","1987","Resistance",,"NonSede","Poland","https://archive.is/V8x4h","OldRite","Williamson","OldRite","Williamson","Lefebvre",,,"Consecrated bishop on August 15, 2022",,,,,,,,,,,,
"bp-morgan","Bishop","Paul Morgan","1963","Resistance",,"NonSede","UK","https://archive.is/iKBL5",,,,"Williamson","Lefebvre",,,,,,,,,,,,,,,
"bp-ballini","Bishop","Giacomo Ballini",,"Resistance",,"NonSede","Ireland","https://archive.is/YiiNJ","OldRite",,"OldRite","Williamson","Lefebvre",,,,,,,,,,,,,,,
"bp-vigano","Bishop","Carlo Maria Viganò","1941","Resistance",,"Benevacantism","Italy","https://exsurgedomine.it/","NewRite","Allorio","NewRite","Wojtyła","Wojtyła",,,"Rumored to be re-consecrated by +Williamson",,,,,,,,,,,,
"fr-ndong","Priest","Pierre Célestin Ndong Ondo Ondzaghe",,"Resistance",,"NonSede","Gabon",,"OldRite","Fellay?",,,"Lefebvre",,,,,,,,,,,,,,,
"fr-chigbata","Priest","Michael Chigbata",,"Resistance",,"NonSede","Nigeria",,"ReordainedOldRite","de Aquino",,,"Lefebvre",,,"Conditionally reordained",,,,,,,,,,,,
"fr-onourah","Priest","Onourah",,"Resistance",,"NonSede","Kenia",,"ReordainedOldRite","de Aquino",,,"Lefebvre",,,"Conditionally reordained",,,,,,,,,,,,
"mother-irene","Mother","Irene Gibson",,"Resistance","carmelites-hf-ireland","NonSede","Ireland","https://carmelitesholyface.com/",,,,,,,,,,,,,,,,,,,,
"sr-anne-marie","Sister","Anne-Marie",,"Resistance","carmelites-hf-ireland","NonSede","Ireland","https://carmelitesholyface.com/",,,,,,,,,,,,,,,,,,,,
"fr-hewko","Priest","David Hewko",,"SSPX-MC","oratory-sfheart-mary","NonSede","USA","https://thecatacombs.org/","OldRite","Williamson",,,"Lefebvre",,,"Runs seminary in NY area",,,,,,,,,,,,
"fr-chazal","Priest","François Chazal",,"SAJM","hjm-seminary","NonSede","Phillipines","https://www.facebook.com/mariancorpsofst.piusx","OldRite","de Mallerais?",,,"Lefebvre",,,,,,,,,,,,,,,
"fr-lang","Priest","Peter Lang",,"SSPX",,"NonSede","Germany","https://archive.is/wip/aEagQ","OldRite","Fellay?",,,"Lefebvre",,,"Still formally in SSPX",,,,,,,,,,,,
"fr-rousseau","Priest","Dominque Rousseau","1955","Resistance",,"NonSede","France","https://archive.is/XVRQQ#selection-2629.0-2670.0","OldRite","Fellay?",,,"Lefebvre",,,,,,,,,,,,,,,
"fr-brocard","Priest","Jean-Baptiste Brocard",,"Resistance","st-dominics-texas","NonSede","USA","https://archive.is/t019H","OldRite","Fellay?",,,"Lefebvre",,,"Resistance Texas / CathInfo.com",,,,,,,,,,,,
"fr-de-amerode","Priest","Roland de Mérode",,"Resistance",,"NonSede","France","https://notredamegardiennedelafoi.fr/author/admin9234/","OldRite","Fellay?",,,"Lefebvre",,,,,,,,,,,,,,,
"fr-pivert","Priest","François Pivert",,"Resistance",,"NonSede","France","https://abbe-pivert.com/","OldRite","Fellay?",,,"Lefebvre",,,"La Fidélité Catholique",,,,,,,,,,,,
"fr-picot","Priest","Rémi Picot",,"SAJM","sajm-alsace-1","NonSede","France",,"OldRite","Williamson",,,"Lefebvre",,,"Fr. Picot serves Alsace & region: ",,,,,,,,,,,,
"fr-carton","Priest","Francis Carton",,"Resistance",,"NonSede","France","https://archive.is/wip/VAi3J","OldRite","Fellay?",,,"Lefebvre",,,,,,,,,,,,,,,
"fr-bruhwiler","Priest","Alois Brühwiler",,"Resistance","bruehwiler-st-gallen-ch","NonSede","Switzerland","https://archive.is/wip/kawk6","OldRite","Fellay?",,,"Lefebvre",,,,,,,,,,,,,,,`;

const defaultEventsData = `"EventID","EventType","LocationID?","GoogleMaps?","PriestID","DateStart","TimeStart?","DateEnd?","TimeEnd?","Repeats","OrganizerEMail","OrganizerPhone","","","","","","","","","","","","","","","","",""
"mass-sajm-alsace","Mass","sajm-alsace","","fr-picot","21.04.2025","","30.04.2025","","Daily","","","","","","","","","","","","","","","","","","",""`;

const defaultCancelledEventsData = `"AffectsEventID","DateStart","TimeStart?","DateEnd?","TimeEnd?","Reason","","","","","","","","","","","","","","","","","","","",""
"mass-sajm-alsace","25.04.2025","23:00:00","26.04.2025","16:00:00","Mass cancelled because Fr. XXX is sick","","","","","","","","","","","","","","","","","","","",""`;

const defaultFundingData = `"CampaignID","ReligiousOrLocationOrEventID","FundingType","FundingGoal","FundingCurrency","CurrentAmount","DonationLinksMulti","Notes","","","","","","","","","","","","","","","","","","","",""
"discalced-carm-ongoing","","BuildParish","5177","USD","","paypal.me/StJosephCarmel","","","","","","","","","","","","","","","","","","","","",""
"fr-hewko-ongoing","fr-hewko","FundAPriest","","","","paypal.me/frhewko","","","","","","","","","","","","","","","","","","","","",""
"chapelle-pontmain","","BuildParish","","","","","https://archive.is/wip/HJCQh","","","","","","","","","","","","","","","","","","","",""
"fr-ruiz-ongoing","fr-ruiz","FundAPriest","","","","paypal.me/hugoruizv","","","","","","","","","","","","","","","","","","","","",""`;

// Initialize map when DOM is loaded
document.addEventListener('DOMContentLoaded', init);

// Initialize function
async function init() {
  // Create map
  map = L.map('mapContainer', {
    minZoom: CONFIG.minZoom,
    maxZoom: CONFIG.maxZoom,
    zoomControl: true,
  }).setView([CONFIG.defaultLat, CONFIG.defaultLng], CONFIG.defaultZoom);
  
  // Add OpenFreeMap
  L.maplibreGL({
    style: 'https://tiles.openfreemap.org/styles/liberty',
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 16
  }).addTo(map);

  // Add layer groups to map
  connectionLines.addTo(map);
  parishMarkers.addTo(map);
  priestMarkers.addTo(map);
  
  // Set up event listeners
  setupEventListeners();
  
  // Load data (first from fallback, then from Google Sheets)
  await loadData();
        
  // Try to get user's location
  getUserLocation();
}

// Set up event listeners
function setupEventListeners() {
  // Search input
  const searchInput = document.getElementById('searchInput');
  const searchResults = document.getElementById('searchResults');
  
  searchInput.addEventListener('input', handleSearch);
  
  searchInput.addEventListener('focus', () => {
    if (searchResults.children.length > 0) {
      searchResults.style.display = 'flex';
    }
  });
  
  // Close button
  document.getElementById('closeBtn').addEventListener('click', () => {
    document.getElementById('infoPanel').style.display = 'none';
    closeCalendarPopup();
    resetAllMarkers();
  });
  
  // Close search results when clicking outside
  document.addEventListener('click', (e) => {
    if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
      searchResults.style.display = 'none';
    }
  });
  
  // Handle light/dark mode
  const prefersDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  if (prefersDarkMode) {
    map.getContainer().classList.add('dark-map');
  }
  
  // Listen for theme changes
  window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
    if (e.matches) {
      map.getContainer().classList.add('dark-map');
    } else {
      map.getContainer().classList.remove('dark-map');
    }
  });
}

// Load data from fallback and Google Sheets
async function loadData() {
  // First load default data
  await parseLocationsData(defaultLocationsData);
  parseReligiousData(defaultReligiousData);
  parseEventsData(defaultEventsData);
  parseCancelledEventsData(defaultCancelledEventsData);
  parseFundingData(defaultFundingData);

  handleUrlHash();

  // Then try to fetch from the live DB
  await fetchSheetData();
}

// Parse URL hash when page loads and focus on entity
function handleUrlHash() {
  const hash = window.location.hash;
  if (!hash || hash === '#') return;
  
  let entityId = hash.substring(1);
  let openCalendar = false;
  
  // Check if we need to open calendar
  if (entityId.endsWith(':cal')) {
    openCalendar = true;
    entityId = entityId.replace(':cal', '');
  }
  
  // Wait for data to be loaded before focusing
  const checkDataAndFocus = setInterval(() => {
    if (window.locations.length > 0 && window.religious.length > 0) {
      clearInterval(checkDataAndFocus);
      
      // Look for entity in locations first
      const location = window.locationMap.get(entityId);
      if (location) {
        showLocationInfo(location);
        if (openCalendar) {
          showLocationCalendar(location);
        }
        return;
      }
      
      // Then check religious people
      const person = window.religiousMap.get(entityId);
      if (person) {
        showPriestInfo(person);
        if (openCalendar) {
          showPriestCalendar(person);
        }
        return;
      }
      
      console.warn(`Entity with ID "${entityId}" not found.`);
    }
  }, 500);
}

// Update URL hash when an entity is selected
function updateUrlHash(entityId, isCalendar = false) {
  const newHash = isCalendar ? `#${entityId}:cal` : `#${entityId}`;
  
  // Use history.replaceState to update URL without page reload
  if (history.replaceState) {
    history.replaceState(null, null, newHash);
  } else {
    // Fallback for older browsers
    window.location.hash = newHash;
  }
}

// Copy current URL to clipboard
function copyCurrentUrlToClipboard() {
  try {
    navigator.clipboard.writeText(window.location.href).then(() => {
      // Show a temporary success message
      const message = document.createElement('div');
      message.textContent = '✓ Link copied!';
      message.style.position = 'fixed';
      message.style.top = '20px';
      message.style.left = '50%';
      message.style.transform = 'translateX(-50%)';
      message.style.backgroundColor = '#4CAF50';
      message.style.color = 'white';
      message.style.padding = '10px 20px';
      message.style.borderRadius = '4px';
      message.style.zIndex = '10000';
      document.body.appendChild(message);
      
      // Remove the message after 2 seconds
      setTimeout(() => {
        message.style.opacity = '0';
        message.style.transition = 'opacity 0.5s';
        setTimeout(() => document.body.removeChild(message), 500);
      }, 2000);
    });
  } catch (err) {
    console.error('Failed to copy URL: ', err);
    alert('Could not copy the link. Please copy it manually from the address bar.');
  }
}

// Generate PDF for calendar
function generateCalendarPDF(entityId, isLocation = true) {
  // Get entity data
  const entity = isLocation ? window.locationMap.get(entityId) : window.religiousMap.get(entityId);
  if (!entity) {
    console.error(`Entity with ID "${entityId}" not found.`);
    return;
  }
  
  // Get current month and year from the calendar
  const grid = document.getElementById('calendarGrid');
  let currentMonth = new Date().getMonth();
  let currentYear = new Date().getFullYear();
  
  if (grid && grid.dataset.month && grid.dataset.year) {
    currentMonth = parseInt(grid.dataset.month, 10);
    currentYear = parseInt(grid.dataset.year, 10);
  }
  
  // Get all events for the month plus next month to ensure we have enough upcoming events
  const currentMonthEvents = getEventsForMonth(currentMonth, currentYear, entityId, isLocation);
  const nextMonthEvents = getEventsForMonth((currentMonth + 1) % 12, 
                                           currentMonth === 11 ? currentYear + 1 : currentYear, 
                                           entityId, isLocation);
  
  // Combine events and filter for future events
  const now = new Date();
  const allEvents = [...currentMonthEvents, ...nextMonthEvents].filter(event => 
    event.StartDate && event.StartDate > now
  );
  
  // Sort by date
  allEvents.sort((a, b) => a.StartDate - b.StartDate);
  
  // Get month name for header
  const monthNames = [
    '$month-january$', '$month-february$', '$month-march$', '$month-april$', 
    '$month-may$', '$month-june$', '$month-july$', '$month-august$', 
    '$month-september$', '$month-october$', '$month-november$', '$month-december$'
  ];
  
  // Get contact information
  let contactInfo = '';
  
  // Create a list of priests for this entity
  const priestsList = [];
  if (isLocation) {
    // Use associated priests
    if (entity.ReligiousIdArray && entity.ReligiousIdArray.length > 0) {
      entity.ReligiousIdArray.forEach(religiousId => {
        const priest = window.religiousMap.get(religiousId);
        if (priest) {
          priestsList.push({
            name: `${priest.Type || 'Fr.'} ${priest.Name}`,
            phone: priest.ContactPhone || '',
            email: priest.ContactEmail || ''
          });
        }
      });
    }
  } else {
    // Use priest's info directly
    priestsList.push({
      name: `${entity.Type || 'Fr.'} ${entity.Name}`,
      phone: entity.ContactPhone || '',
      email: entity.ContactEmail || ''
    });
  }
  
  // Create contact info string
  if (priestsList.length > 0) {
    contactInfo = priestsList.map(priest => {
      let info = priest.name;
      if (priest.phone) info += ` - ${priest.phone}`;
      if (priest.email) info += ` - ${priest.email}`;
      return info;
    }).join('<br>');
  }
  
  // Create Google Maps URL for location
  let mapUrl = '';
  if (isLocation) {
    if (entity.GoogleMaps) {
      mapUrl = entity.GoogleMaps;
    } else if (entity.Latitude && entity.Longitude) {
      mapUrl = `https://www.google.com/maps?q=${entity.Latitude},${entity.Longitude}`;
    }
  } else {
    // For priests, use their first associated location
    const priestLocations = window.locations.filter(location => 
      location.ReligiousIdArray && location.ReligiousIdArray.includes(entity.ReligiousID)
    );
    
    if (priestLocations.length > 0) {
      const location = priestLocations[0];
      if (location.GoogleMaps) {
        mapUrl = location.GoogleMaps;
      } else if (location.Latitude && location.Longitude) {
        mapUrl = `https://www.google.com/maps?q=${location.Latitude},${location.Longitude}`;
      }
    }
  }
  
  // Calculate pages needed (max 8 events per page, 2 columns of 4 events each)
  const eventsPerPage = 8;
  const totalPages = Math.min(4, Math.ceil(allEvents.length / eventsPerPage));
  
  // Create QR code for entity link
  const entityUrl = `ghttdubia.cc/${CONFIG.currentLanguage}/resistance#${entityId}`;
  
  // Generate HTML content for PDF using array of strings instead of multiline template literals
  const htmlParts = [];
  
  // HTML header
  htmlParts.push(`<html>`);
  htmlParts.push(`<head>`);
  htmlParts.push(`  <title>${entity.Name} - ${monthNames[currentMonth]} ${currentYear}</title>`);
  htmlParts.push(`  <style>`);
  htmlParts.push(`    @media print {`);
  htmlParts.push(`      @page {`);
  htmlParts.push(`        size: A4;`);
  htmlParts.push(`        margin: 1cm;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      body {`);
  htmlParts.push(`        font-family: Arial, sans-serif;`);
  htmlParts.push(`        margin: 0;`);
  htmlParts.push(`        padding: 0;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .page-break {`);
  htmlParts.push(`        page-break-after: always;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .parish-header {`);
  htmlParts.push(`        text-align: center;`);
  htmlParts.push(`        background-color: #000000;`);
  htmlParts.push(`        color: white;`);
  htmlParts.push(`        padding: 15px 0;`);
  htmlParts.push(`        margin-bottom: 20px;`);
  htmlParts.push(`        font-size: 18pt;`);
  htmlParts.push(`        font-weight: bold;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event-columns {`);
  htmlParts.push(`        display: flex;`);
  htmlParts.push(`        flex-direction: row;`);
  htmlParts.push(`        justify-content: space-between;`);
  htmlParts.push(`        margin-bottom: 20px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event-column {`);
  htmlParts.push(`        width: 48%;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event {`);
  htmlParts.push(`        margin-bottom: 15px;`);
  htmlParts.push(`        padding: 8px;`);
  htmlParts.push(`        border-left: 3px solid #700000;`);
  htmlParts.push(`        background-color: #f9f9f9;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event-cancelled {`);
  htmlParts.push(`        text-decoration: line-through;`);
  htmlParts.push(`        color: #999;`);
  htmlParts.push(`        border-left-color: #999;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event-title {`);
  htmlParts.push(`        font-weight: bold;`);
  htmlParts.push(`        font-size: 12pt;`);
  htmlParts.push(`        margin-bottom: 5px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event-date {`);
  htmlParts.push(`        font-size: 10pt;`);
  htmlParts.push(`        margin-bottom: 5px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .event-priest {`);
  htmlParts.push(`        font-style: italic;`);
  htmlParts.push(`        font-size: 10pt;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .notes-section {`);
  htmlParts.push(`        border-top: 1px solid #ddd;`);
  htmlParts.push(`        padding-top: 15px;`);
  htmlParts.push(`        margin-top: 20px;`);
  htmlParts.push(`        margin-bottom: 20px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .notes-section h3 {`);
  htmlParts.push(`        margin-top: 0;`);
  htmlParts.push(`        margin-bottom: 10px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .notes-lines {`);
  htmlParts.push(`        height: 150px;`);
  htmlParts.push(`        background-image: linear-gradient(#ddd 1px, transparent 1px);`);
  htmlParts.push(`        background-size: 100% 25px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .footer {`);
  htmlParts.push(`        display: flex;`);
  htmlParts.push(`        border-top: 1px solid #ddd;`);
  htmlParts.push(`        padding-top: 15px;`);
  htmlParts.push(`        font-size: 10pt;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .qr-code {`);
  htmlParts.push(`        margin-right: 20px;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .footer-info {`);
  htmlParts.push(`        flex-grow: 1;`);
  htmlParts.push(`      }`);
  htmlParts.push(`      .link-text {`);
  htmlParts.push(`        margin-top: 5px;`);
  htmlParts.push(`        font-size: 9pt;`);
  htmlParts.push(`      }`);
  htmlParts.push(`    }`);
  htmlParts.push(`  </style>`);
  htmlParts.push(`</head>`);
  htmlParts.push(`<body>`);
  
  // Generate pages
  for (let page = 0; page < totalPages; page++) {
    const startIdx = page * eventsPerPage;
    const pageEvents = allEvents.slice(startIdx, startIdx + eventsPerPage);
    
    // Split into two columns
    const midpoint = Math.ceil(pageEvents.length / 2);
    const leftColumnEvents = pageEvents.slice(0, midpoint);
    const rightColumnEvents = pageEvents.slice(midpoint);
    
    htmlParts.push(`<div class="page">`);
    htmlParts.push(`  <div class="parish-header">`);
    htmlParts.push(`    ${entity.Name}`);
    htmlParts.push(`  </div>`);
    
    htmlParts.push(`  <div class="event-columns">`);
    htmlParts.push(`    <div class="event-column">`);
    
    // Left column events
    leftColumnEvents.forEach(event => {
      const dateStr = event.StartDate ? formatDate(event.StartDate, { 
        weekday: 'long', 
        month: 'long', 
        day: 'numeric' 
      }) : '';
      
      const timeStr = event.StartDate ? formatTime(event.StartDate, event.Timezone) : '';
      
      const eventClass = event.isCancelled ? 'event event-cancelled' : 'event';
      
      // Priest info
      let priestInfo = '';
      if (event.PriestID) {
        const priest = window.religiousMap.get(event.PriestID);
        if (priest) {
          priestInfo = `<div class="event-priest">${priest.Type || 'Fr.'} ${priest.Name}</div>`;
        }
      }
      
      htmlParts.push(`      <div class="${eventClass}">`);
      htmlParts.push(`        <div class="event-title">${event.EventType || 'Event'}</div>`);
      htmlParts.push(`        <div class="event-date">${dateStr} - ${timeStr}</div>`);
      if (priestInfo) {
        htmlParts.push(`        ${priestInfo}`);
      }
      htmlParts.push(`      </div>`);
    });
    
    htmlParts.push(`    </div><div class="event-column">`);
    
    // Right column events
    rightColumnEvents.forEach(event => {
      const dateStr = event.StartDate ? formatDate(event.StartDate, { 
        weekday: 'long', 
        month: 'long', 
        day: 'numeric' 
      }) : '';
      
      const timeStr = event.StartDate ? formatTime(event.StartDate, event.Timezone) : '';
      
      const eventClass = event.isCancelled ? 'event event-cancelled' : 'event';
      
      // Priest info
      let priestInfo = '';
      if (event.PriestID) {
        const priest = window.religiousMap.get(event.PriestID);
        if (priest) {
          priestInfo = `<div class="event-priest">${priest.Type || 'Fr.'} ${priest.Name}</div>`;
        }
      }
      
      htmlParts.push(`      <div class="${eventClass}">`);
      htmlParts.push(`        <div class="event-title">${event.EventType || 'Event'}</div>`);
      htmlParts.push(`        <div class="event-date">${dateStr} - ${timeStr}</div>`);
      if (priestInfo) {
        htmlParts.push(`        ${priestInfo}`);
      }
      htmlParts.push(`      </div>`);
    });
    
    htmlParts.push(`    </div>`);
    htmlParts.push(`  </div>`);
    
    htmlParts.push(`  <div class="notes-section">`);
    htmlParts.push(`    <h3>$notes-title$</h3>`);
    htmlParts.push(`    <div class="notes-lines"></div>`);
    htmlParts.push(`  </div>`);
    
    htmlParts.push(`  <div class="footer">`);
    htmlParts.push(`    <div class="qr-code">`);
    htmlParts.push(`      <div class="qr-container" id="qrcode-${page}"></div>`);
    htmlParts.push(`      <div class="link-text">${entityUrl}</div>`);
    htmlParts.push(`    </div>`);
    htmlParts.push(`    <div class="footer-info">`);
    if (contactInfo) {
      htmlParts.push(`      <div>${contactInfo}</div>`);
    }
    if (mapUrl) {
      htmlParts.push(`      <div><a href="${mapUrl}" target="_blank">$view-on-maps$</a></div>`);
    }
    htmlParts.push(`      <div>dubia.cc/${CONFIG.currentLanguage}/resistance</div>`);
    htmlParts.push(`    </div>`);
    htmlParts.push(`  </div>`);
    
    // Add page break except for last page
    if (page < totalPages - 1) {
      htmlParts.push('  <div class="page-break"></div>');
    }
    
    htmlParts.push('</div>');
  }
  
  htmlParts.push('</body></html>');
  
  // Join all HTML parts into a single string
  const pdfHtml = htmlParts.join('\n');
  
  // Create a new window for printing
  const printWindow = window.open('', '_blank');
  printWindow.document.write(pdfHtml);
  printWindow.document.close();
  
  // Wait for content to load before generating QR codes
  printWindow.onload = function() {
    // Generate QR codes
    for (let page = 0; page < totalPages; page++) {
      const qrContainer = printWindow.document.getElementById(`qrcode-${page}`);
      if (qrContainer) {
        new QRCode(qrContainer, {
          text: `https://${entityUrl}`,
          width: 100,
          height: 100,
          colorDark: "#000000",
          colorLight: "#ffffff",
          correctLevel: QRCode.CorrectLevel.M
        });
      }
    }
    
    // Trigger print after short delay to ensure QR codes are rendered
    setTimeout(() => {
      printWindow.print();
      // Don't close the window after print to allow user to save as PDF manually if needed
    }, 500);
  };
}

// Format date
function formatDate(date, options = {}) {
  const defaultOptions = {
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  };
  
  return date.toLocaleDateString(CONFIG.currentLanguage || 'en', { ...defaultOptions, ...options });
}

// Format time
function formatTime(date, timezone) {
  if (!date) return '';
  
  try {
    return date.toLocaleTimeString(CONFIG.currentLanguage || 'en', {
      timeZone: timezone || 'UTC',
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  } catch (e) {
    return date.toLocaleTimeString(CONFIG.currentLanguage || 'en', {
      hour: '2-digit',
      minute: '2-digit',
      hour12: false
    });
  }
}

// Function to generate and download iCal file
function generateICalFile(entityId, isLocation = true) {
  // Get entity data
  const entity = isLocation ? window.locationMap.get(entityId) : window.religiousMap.get(entityId);
  if (!entity) {
    console.error(`Entity with ID "${entityId}" not found.`);
    return;
  }
  
  // Get current month and year from the calendar
  const grid = document.getElementById('calendarGrid');
  let currentMonth = new Date().getMonth();
  let currentYear = new Date().getFullYear();
  
  if (grid && grid.dataset.month && grid.dataset.year) {
    currentMonth = parseInt(grid.dataset.month, 10);
    currentYear = parseInt(grid.dataset.year, 10);
  }
  
  // Get all events for the month
  const monthEvents = getEventsForMonth(currentMonth, currentYear, entityId, isLocation);
  
  // Check if there are events
  if (monthEvents.length === 0) {
    alert('No events to export for this month.');
    return;
  }
  
  // Generate iCal content
  let iCalContent = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'PRODID:-//DubiaCC//Resistance Calendar//EN',
    'CALSCALE:GREGORIAN',
    'METHOD:PUBLISH',
    `X-WR-CALNAME:${entity.Name || 'Calendar'}`
  ];
  
  // Process each event
  monthEvents.forEach(event => {
    // Skip if no start date
    if (!event.StartDate) return;
    
    // Format dates for iCal (YYYYMMDDTHHMMSSZ)
    const startDate = formatDateForICal(event.StartDate);
    const endDate = event.EndDate ? formatDateForICal(event.EndDate) : startDate;
    
    // Get unique ID for event
    const eventUid = `${event.EventID || 'event'}-${startDate}@dubia.cc`;
    
    // Start event
    iCalContent.push('BEGIN:VEVENT');
    iCalContent.push(`UID:${eventUid}`);
    iCalContent.push(`DTSTAMP:${formatDateForICal(new Date())}`);
    iCalContent.push(`DTSTART:${startDate}`);
    iCalContent.push(`DTEND:${endDate}`);
    
    // Add summary
    const summary = event.EventType || 'Event';
    iCalContent.push(`SUMMARY:${summary}`);
    
    // Add location if available
    if (isLocation) {
      const location = window.locationMap.get(event.LocationID);
      if (location) {
        iCalContent.push(`LOCATION:${location.Name}`);
        
        // Add geo if coordinates available
        if (location.Latitude && location.Longitude) {
          iCalContent.push(`GEO:${location.Latitude};${location.Longitude}`);
        }
      }
    } else if (event.LocationID) {
      const location = window.locationMap.get(event.LocationID);
      if (location) {
        iCalContent.push(`LOCATION:${location.Name}`);
        
        if (location.Latitude && location.Longitude) {
          iCalContent.push(`GEO:${location.Latitude};${location.Longitude}`);
        }
      }
    }
    
    // Add description including notes
    let description = '';
    if (event.Notes) {
      description += event.Notes;
    }
    
    // Add priest info to description if available
    if (event.PriestID) {
      const priest = window.religiousMap.get(event.PriestID);
      if (priest) {
        if (description) description += '\n\n';
        description += `Celebrant: ${priest.Type || 'Fr.'} ${priest.Name || ''}`;
      }
    }
    
    if (description) {
      // Format description for iCal (escape special chars and wrap lines)
      description = description.replace(/\n/g, '\\n');
      description = description.replace(/,/g, '\\,');
      description = description.replace(/;/g, '\\;');
      iCalContent.push(`DESCRIPTION:${description}`);
    }
    
    // Add organizer if available
    if (event.PriestID) {
      const priest = window.religiousMap.get(event.PriestID);
      if (priest && priest.ContactEmail) {
        const email = priest.ContactEmail.replace('mailto:', '').trim();
        if (email) {
          iCalContent.push(`ORGANIZER;CN=${priest.Name}:mailto:${email}`);
        }
      }
    }
    
    // Add status (cancelled or confirmed)
    const { isCancelled } = checkEventCancellation(event, event.StartDate);
    iCalContent.push(isCancelled ? 'STATUS:CANCELLED' : 'STATUS:CONFIRMED');
    
    // Add recurrence rule if needed
    if (event.Repeats) {
      const rrule = generateRRule(event.Repeats);
      if (rrule) {
        iCalContent.push(rrule);
      }
    }
    
    // End event
    iCalContent.push('END:VEVENT');
  });
  
  // End calendar
  iCalContent.push('END:VCALENDAR');
  
  // Join lines and download
  const iCalData = iCalContent.join('\r\n');
  downloadFile(iCalData, `${entity.Name || 'calendar'}.ics`, 'text/calendar');
}

// Format date for iCal
function formatDateForICal(date) {
  return date.toISOString().replace(/[-:]/g, '').replace(/\.\d{3}/, '');
}

// Generate RRULE from repeat pattern
function generateRRule(repeatPattern) {
  let freq = '';
  
  switch (repeatPattern.toLowerCase()) {
    case 'daily':
      freq = 'FREQ=DAILY';
      break;
    case 'weekly':
      freq = 'FREQ=WEEKLY';
      break;
    case 'every2weeks':
      freq = 'FREQ=WEEKLY;INTERVAL=2';
      break;
    case 'monthly':
    case 'everymonth':
      freq = 'FREQ=MONTHLY';
      break;
    case 'every2months':
      freq = 'FREQ=MONTHLY;INTERVAL=2';
      break;
    case 'yearly':
    case 'everyyear':
      freq = 'FREQ=YEARLY';
      break;
    default:
      return null;
  }
  
  return `RRULE:${freq}`;
}

// Download a file
function downloadFile(content, filename, contentType) {
  const blob = new Blob([content], { type: contentType });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  a.click();
  URL.revokeObjectURL(url);
}

// Run validation checks on data
function validateData() {
  const warnings = [];
  
  // Check for invalid location IDs in religious people
  window.religious.forEach(person => {
    if (person.UsualLocationID && !window.locationMap.has(person.UsualLocationID)) {
      warnings.push(`Warning: Religious person "${person.Name}" has invalid UsualLocationID "${person.UsualLocationID}"`);
    }
  });
  
  // Check for priests without a parish
  window.religious.forEach(person => {
    if (person.Type?.toLowerCase() === 'priest' || person.Type?.toLowerCase() === 'bishop') {
      const hasParish = window.locations.some(location => 
        location.ReligiousIdArray && location.ReligiousIdArray.includes(person.ReligiousID)
      );
      
      if (!hasParish) {
        warnings.push(`Warning: ${person.Type} "${person.Name}" has no associated parish`);
      }
    }
  });
  
  // Check for events with invalid LocationID
  window.events.forEach(event => {
    if (event.LocationID && !window.locationMap.has(event.LocationID)) {
      warnings.push(`Warning: Event "${event.EventID}" has invalid LocationID "${event.LocationID}"`);
    }
  });
  
  // Check for events with invalid PriestID
  window.events.forEach(event => {
    if (event.PriestID && !window.religiousMap.has(event.PriestID)) {
      warnings.push(`Warning: Event "${event.EventID}" has invalid PriestID "${event.PriestID}"`);
    }
  });
  
  // Check for locations without coordinates
  window.locations.forEach(location => {
    if (isNaN(location.Latitude) || isNaN(location.Longitude)) {
      warnings.push(`Warning: Location "${location.Name}" has invalid coordinates`);
    }
  });
  
  // Check for locations without contact info
  window.locations.forEach(location => {
    if (!location.ContactEmail && !location.ContactPhone && 
        !location.Website && !location.GoogleMaps) {
      warnings.push(`Warning: Location "${location.Name}" has no contact information`);
    }
  });
  
  // Check for ReligiousIdArray referencing non-existent religious people
  window.locations.forEach(location => {
    if (location.ReligiousIdArray && location.ReligiousIdArray.length > 0) {
      location.ReligiousIdArray.forEach(id => {
        if (!window.religiousMap.has(id)) {
          warnings.push(`Warning: Location "${location.Name}" references non-existent religious ID "${id}"`);
        }
      });
    }
  });
  
  // Check for cancelled events referencing non-existent events
  window.cancelledEvents.forEach(cancelled => {
    if (!window.events.some(event => event.EventID === cancelled.AffectsEventID)) {
      warnings.push(`Warning: Cancelled event entry references non-existent event ID "${cancelled.AffectsEventID}"`);
    }
  });
  
  // Output all warnings to console
  if (warnings.length > 0) {
    console.warn('Data validation warnings:');
    warnings.forEach(warning => console.warn(warning));
  } else {
    console.log('Data validation completed with no warnings.');
  }
  
  return warnings;
}

async function getTimezoneForLocation(lat, lng) {
  try {
    // geoTz returns an array, we usually want the first one
    const timezones = await GeoTZ.find(lat, lng);
    if (timezones && timezones.length > 0) {
      return timezones[0]; // e.g., "Europe/Berlin", "America/New_York"
    } else {
      console.warn(`Could not find timezone for ${lat}, ${lng}. Falling back to UTC.`);
      return 'UTC'; // Fallback
    }
  } catch (error) {
    console.error(`Error finding timezone for ${lat}, ${lng}:`, error);
    return 'UTC'; // Fallback on error
  }
}

// Function taken from https://github.com/freshp86/achilles-csv-parser 
// and minified to the essentials
// 
// Copyright 2020 Achilles CSV Parser Project Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
function parseCsv(csvData, transformer = null) {
  const rows = [];
  const headers = [];
  
  let isHeaderRow = false;
  let columnIndex = 0;
  let currentRow = {};
  let fieldStartIndex = -1;
  let currentIndex = 0;
  let inQuotes = false;
  let hasEscapedQuote = false;
  
  function processField() {
    const quoteAdjustment = csvData[currentIndex - 1] === '"' ? 1 : 0;
    let fieldValue = csvData.substring(fieldStartIndex + 1 + quoteAdjustment, currentIndex - quoteAdjustment);
    
    if (hasEscapedQuote) {
      fieldValue = fieldValue.replace(/""/g, '"');
    }
    
    if (isHeaderRow) {
      if (transformer) {
        const transformedValue = transformer(headers[columnIndex], fieldValue);
        if (transformedValue !== undefined) {
          currentRow[headers[columnIndex]] = transformedValue;
        }
      } else {
        currentRow[headers[columnIndex]] = fieldValue;
      }
      columnIndex++;
    } else {
      headers.push(fieldValue);
    }
    
    hasEscapedQuote = false;
    fieldStartIndex = currentIndex;
  }
  
  function finishRow() {
    processField();
    
    if (isHeaderRow) {
      rows.push(currentRow);
      currentRow = {};
      columnIndex = 0;
    } else {
      isHeaderRow = true;
    }
  }
  
  while (currentIndex < csvData.length) {
    const currentChar = csvData[currentIndex];
    
    if (inQuotes) {
      if (currentChar === '"') {
        if (csvData[currentIndex + 1] === '"') {
          currentIndex += 2;
          hasEscapedQuote = true;
        } else {
          inQuotes = false;
          currentIndex++;
          
          if (currentIndex === csvData.length) {
            finishRow();
          }
        }
      } else {
        currentIndex++;
      }
    } else {
      if (currentChar === ',') {
        processField();
      } else if (currentChar === '"') {
        inQuotes = true;
      } else if (currentChar === '\r') {
        finishRow();
        currentIndex++;
        fieldStartIndex = currentIndex;
      } else if (currentChar === '\n') {
        finishRow();
      } else if (currentIndex === csvData.length - 1) {
        currentIndex++;
        finishRow();
      }
      
      currentIndex++;
    }
  }
  
  return fixMangledJson(rows);
}

// Fix mangled JSON data where column headers are mixed with first row values in keys
function fixMangledJson(data) {
  if (!data || !data.length) return [];

  const extractHeaderAndFirstRowValue = (key) => {
    if (!key) return null;
    
    const parts = key.trim().split(' ');
    if (!parts.length) return null;
    
    const header = parts[0].replace(/\?$/, '');
    const firstRowValue = parts.slice(1).join(' ').trim();
    
    return { header, firstRowValue };
  };

  const processRow = (row) => {
    const normalizedRow = {};
    
    Object.keys(row).forEach(key => {
      const extracted = extractHeaderAndFirstRowValue(key);
      if (extracted && extracted.header) {
        normalizedRow[extracted.header] = row[key];
      }
    });
    
    return normalizedRow;
  };

  const headers = {};
  const firstRow = {};

  Object.keys(data[0]).forEach(key => {
    const extracted = extractHeaderAndFirstRowValue(key);
    if (extracted && extracted.header) {
      headers[extracted.header] = true;
      firstRow[extracted.header] = extracted.firstRowValue;
    }
  });

  const fixedData = [firstRow];
  data.forEach(row => {
    fixedData.push(processRow(row));
  });

  return fixedData;
};

// Parse locations CSV data
/**
 * Parse locations CSV data
 * @param {string} csvData Raw CSV string
 * @returns {Promise} Promise that resolves when parsing is complete
 */
 async function parseLocationsData(csvData) {
  const parsedData = parseCsv(csvData);
  
  // Process locations
  let newLocations = [];
  for (const location of parsedData) {
    // Fix location parsing (handling both comma and space separated coordinates)
    let lat = NaN, lng = NaN;
    if (location.Location) {
      // Use a robust regex for various separators and optional spaces
      const coordMatch = location.Location.match(/(-?\d+(?:\.\d+)?)\s*[,\s]\s*(-?\d+(?:\.\d+)?)/);
      if (coordMatch) {
        lat = parseFloat(coordMatch[1]);
        lng = parseFloat(coordMatch[2]);
      } else if (!isNaN(parseFloat(location.Location))) {
        // Maybe it's just Lat? Or Lon?
        console.warn(`Could only parse one coordinate for ${location.Name}: ${location.Location}`);
      }
    }
    
    // Fallback if Lat/Lon fields exist directly
    if (isNaN(lat) && location.Latitude) lat = parseFloat(location.Latitude);
    if (isNaN(lng) && location.Longitude) lng = parseFloat(location.Longitude);

    // Get timezone if coordinates are valid
    let timezone = 'UTC';
    
    if (!isNaN(lat) && !isNaN(lng)) { 
      timezone = await getTimezoneForLocation(lat, lng); 
    }

    // Create a new location object with all properties
    const newLocation = {
      ...location,
      Latitude: lat,
      Longitude: lng,
      ReligiousIdArray: location.ReligiousIdMulti ?
        location.ReligiousIdMulti.split(/[,\s]+/).filter(id => id.trim() !== "") : [],
      Timezone: timezone
    };

    newLocations.push(newLocation);
  }

  window.locations = newLocations.filter(loc => !isNaN(loc.Latitude) && !isNaN(loc.Longitude));
  
  // Update location map
  window.locationMap.clear();
  window.locations.forEach(location => {
    window.locationMap.set(location.LocationID, location);
  });
  
  // Update markers
  updateMapMarkers();
}

/**
 * Parse religious CSV data
 * @param {string} csvData Raw CSV string
 */
 function parseReligiousData(csvData) {
  const parsedData = parseCsv(csvData);
  
  // Process religious data
  window.religious = parsedData.map(person => {
    // Create a clean new object
    return { ...person };
  });
  
  // Update religious map
  window.religiousMap.clear();
  window.religious.forEach(person => {
    window.religiousMap.set(person.ReligiousID, person);
  });
  
  // Update markers
  updateMapMarkers();
}

/**
 * Parse events CSV data
 * @param {string} csvData Raw CSV string
 */
 function parseEventsData(csvData) {
  const parsedData = parseCsv(csvData);
  
  // Process events data
  window.events = parsedData.map(event => {
    return { ...event };
  });
  
  // Update markers
  updateMapMarkers();
}

/**
 * Parse cancelled events CSV data
 * @param {string} csvData Raw CSV string
 */
 function parseCancelledEventsData(csvData) {
  const parsedData = parseCsv(csvData);
  
  // Process cancelled events data
  window.cancelledEvents = parsedData;
  
  // Create lookup map for faster access
  window.cancelledEventsMap.clear();
  window.cancelledEvents.forEach(cancelled => {
    // Use eventID as key
    const key = cancelled.AffectsEventID;
    if (!window.cancelledEventsMap.has(key)) {
      window.cancelledEventsMap.set(key, []);
    }
    window.cancelledEventsMap.get(key).push({ ...cancelled });
  });
}

/**
 * Parse funding CSV data
 * @param {string} csvData Raw CSV string
 */
 function parseFundingData(csvData) {
  const parsedData = parseCsv(csvData);
  
  // Process funding data
  window.fundingData = parsedData;
  
  // Create lookup map for faster access
  window.fundingMap.clear();
  window.fundingData.forEach(funding => {
    window.fundingMap.set(funding.ReligiousOrLocationOrEventID, { ...funding });
  });
}

// Fetch data from Google Sheets
async function fetchSheetData() {
  const sheetId = CONFIG.sheetId;
  const sheets = ["locations", "religious", "events", "cancelled-events", "funding"];
  
  for(const sheet of sheets) {

    const encodedSheetName = encodeURIComponent(sheet);
    const googleSheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodedSheetName}&query=rows`;
    const proxyUrl = 'https://api.codetabs.com/v1/proxy/?quest=';
    const corsProxyUrl = `${proxyUrl}${encodeURIComponent(googleSheetUrl)}`;
    try {
      const response = await fetch(corsProxyUrl);
      if (!response.ok) {
        throw new Error(`Failed to fetch ${sheet} data: ${response.status}`);
      }
      const csvText = await response.text();

      // Parse CSV based on sheet type
      if (sheet === "locations") {
        await parseLocationsData(csvText);
      } else if (sheet === "religious") {
        parseReligiousData(csvText);
      } else if (sheet === "events") {
        parseEventsData(csvText);
      } else if (sheet === "cancelled-events") {
        parseCancelledEventsData(csvText);
      } else if (sheet === "funding") {
        parseFundingData(csvText);
      }
    } catch (e) {
      console.error(`Error loading ${sheet} data:`, error);
      console.log(`Using fallback data for ${sheet}`);
    }
  }

  handleUrlHash();
  validateData();
}

// Update map markers
function updateMapMarkers() {
  // Clear existing markers and lines
  priestMarkers.clearLayers();
  parishMarkers.clearLayers();
  connectionLines.clearLayers();
  
  // Process locations
  window.locations.forEach(location => {
    // Create parish marker
    createParishMarker(location);
    
    // Create connection lines between religious and their locations
    createConnectionLines(location);
  });
  
  // Process religious who don't have an assigned location
  window.religious.forEach(person => {
    const hasLocation = window.locations.some(location => 
      location.ReligiousIdArray.includes(person.ReligiousID)
    );
    
    if (!hasLocation && person['Location/Area']) {
      // Extract coordinates from Location field if available
      const geoMatch = person['Location/Area']?.match(/(-?\d+\.\d+)[,\s]+(-?\d+\.\d+)/);
      if (geoMatch) {
        const lat = parseFloat(geoMatch[1]);
        const lng = parseFloat(geoMatch[2]);
        
        if (!isNaN(lat) && !isNaN(lng)) {
          createPriestMarker(person, lat, lng);
        }
      } else {
        // Use location approximation based on country/area
        const coords = approximateLocationFromName(person['Location/Area']);
        if (coords) {
          createPriestMarker(person, coords.lat, coords.lng);
        }
      }
    }
  });
}

// Create parish marker
function createParishMarker(location) {
  if (!location.Latitude || !location.Longitude || 
      isNaN(location.Latitude) || isNaN(location.Longitude)) {
    // console.warn(`Invalid coordinates for location: ${location.Name}`);
    return;
  }
  
  // Create marker
  const markerSize = CONFIG.parishMarkerSize;
  const icon = L.divIcon({
    className: 'parish-marker',
    html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
    iconSize: [markerSize, markerSize],
    iconAnchor: [markerSize/2, markerSize/2]
  });
  
  const marker = L.marker([location.Latitude, location.Longitude], { icon })
    .addTo(parishMarkers);
  
  // Store location data with marker
  marker.locationData = location;
  
  // Add click handler (no popup)
  marker.on('click', function() {
    showLocationInfo(location);
  });
  
  return marker;
}

// Create priest marker
function createPriestMarker(priest, lat, lng) {
  // Create marker
  const markerSize = CONFIG.priestMarkerSize;
  const icon = L.divIcon({
    className: 'priest-marker pulse',
    html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
    iconSize: [markerSize, markerSize],
    iconAnchor: [markerSize/2, markerSize/2]
  });
  
  const marker = L.marker([lat, lng], { icon })
    .addTo(priestMarkers);
  
  // Store priest data with marker
  marker.priestData = priest;
  
  // Add click handler (no popup)
  marker.on('click', function() {
    // Get containing parish (if any)
    const containingParish = findParishAtCoordinates(lat, lng);
    
    // If there's a parish at these exact coordinates, prioritize showing it
    if (containingParish) {
      showLocationInfo(containingParish);
    } else {
      showPriestInfo(priest);
    }
  });
  
  return marker;
}

// Create connection lines between religious and their locations
function createConnectionLines(location) {
  if (!location.ReligiousIdArray || !location.Latitude || !location.Longitude) {
    return;
  }
  
  // For each religious person associated with this location
  location.ReligiousIdArray.forEach(religiousId => {
    const person = window.religiousMap.get(religiousId);
    if (!person) return;
    
    // Find all other locations for this religious person
    window.locations.forEach(otherLocation => {
      if (otherLocation.LocationID === location.LocationID) return; // Skip self
      
      if (otherLocation.ReligiousIdArray.includes(religiousId)) {
        // Create a line between locations
        const latlngs = [
          [location.Latitude, location.Longitude],
          [otherLocation.Latitude, otherLocation.Longitude]
        ];
        
        const line = L.polyline(latlngs, {
          color: CONFIG.lineColor,
          weight: CONFIG.lineWeight,
          opacity: CONFIG.lineOpacity
        }).addTo(connectionLines);
        
        // Store data with the line
        line.religiousId = religiousId;
        line.fromLocation = location.LocationID;
        line.toLocation = otherLocation.LocationID;
      }
    });
    
    // Create priest marker at this location
    createPriestMarker(person, location.Latitude, location.Longitude);
  });
}

function findParishAtCoordinates(lat, lng) {
  let foundParish = null;
  
  parishMarkers.eachLayer(marker => {
    if (marker.locationData && 
        marker.getLatLng().lat === lat && 
        marker.getLatLng().lng === lng) {
      foundParish = marker.locationData;
    }
  });
  
  return foundParish;
}

// Approximate location from country or region name
function approximateLocationFromName(locationName) {
  if (!locationName) return null;
  
  const locationMap = {
    'England': { lat: 51.5074, lng: -0.1278 },
    'UK': { lat: 51.5074, lng: -0.1278 },
    'USA': { lat: 39.8283, lng: -98.5795 },
    'France': { lat: 46.2276, lng: 2.2137 },
    'Germany': { lat: 51.1657, lng: 10.4515 },
    'Italy': { lat: 41.8719, lng: 12.5674 },
    'Spain': { lat: 40.4637, lng: -3.7492 },
    'Poland': { lat: 51.9194, lng: 19.1451 },
    'Ireland': { lat: 53.1424, lng: -7.6921 },
    'Brazil': { lat: -14.2350, lng: -51.9253 },
    'Argentina': { lat: -38.4161, lng: -63.6167 },
    'Mexico': { lat: 23.6345, lng: -102.5528 },
    'Canada': { lat: 56.1304, lng: -106.3468 },
    'Australia': { lat: -25.2744, lng: 133.7751 },
    'New Zealand': { lat: -40.9006, lng: 174.8860 },
    'Philippines': { lat: 12.8797, lng: 121.7740 },
    'Austria': { lat: 47.5162, lng: 14.5501 },
    'Switzerland': { lat: 46.8182, lng: 8.2275 },
    'Belgium': { lat: 50.5039, lng: 4.4699 },
    'Netherlands': { lat: 52.1326, lng: 5.2913 },
    'Portugal': { lat: 39.3999, lng: -8.2245 },
    'Europe': { lat: 48.8566, lng: 9.3522 }
  };
  
  // Check for direct match
  for (const [key, coords] of Object.entries(locationMap)) {
    if (locationName.includes(key)) {
      return coords;
    }
  }
  
  // Add small random offset to default location to prevent markers from stacking
  return { 
    lat: CONFIG.defaultLat + (Math.random() * 2 - 1), 
    lng: CONFIG.defaultLng + (Math.random() * 2 - 1) 
  };
}

function closeCalendarPopup() {
  const calendarPopup = document.getElementById('calendarPopup');
  if (calendarPopup) {
    calendarPopup.style.display = 'none';
    
    // Get the current hash and remove the :cal suffix if present
    const currentHash = window.location.hash;
    if (currentHash && currentHash.endsWith(':cal')) {
      const entityId = currentHash.substring(1).replace(':cal', '');
      updateUrlHash(entityId, false); // Update URL to entity ID without calendar
    }
  }
}

// Returns a standard JS Date (which is UTC-based) correctly representing that instant,
// AND the timezone string for formatting later.
function createZonedDateTime(dateStr, timeStr, timezone) {
  if (!dateStr || !timezone) {
      console.warn("Cannot create zoned date time without date string or timezone.");
      return null;
  }

  // 1. Parse date components (robustly)
  let day, month, year;
  const datePartsMatch = dateStr.match(/(\d{1,2})[.\/-](\d{1,2})[.\/-](\d{4})/); // Handles DD.MM.YYYY, MM/DD/YYYY
  if (datePartsMatch) {
    // Try DD.MM.YYYY first (common European)
    if (dateStr.includes('.')) {
        day = parseInt(datePartsMatch[1], 10);
        month = parseInt(datePartsMatch[2], 10) - 1; // JS month index
        year = parseInt(datePartsMatch[3], 10);
    }
    // Try MM/DD/YYYY (common US)
    else if (dateStr.includes('/')) {
        month = parseInt(datePartsMatch[1], 10) - 1; // JS month index
        day = parseInt(datePartsMatch[2], 10);
        year = parseInt(datePartsMatch[3], 10);
    } else {
        // Default assumption or fallback (e.g. assume DD.MM if no separator info?) - Risky
        day = parseInt(datePartsMatch[1], 10);
        month = parseInt(datePartsMatch[2], 10) - 1;
        year = parseInt(datePartsMatch[3], 10);
    }
  } else {
      // Try YYYY-MM-DD
       const isoMatch = dateStr.match(/(\d{4})-(\d{1,2})-(\d{1,2})/);
       if (isoMatch) {
           year = parseInt(isoMatch[1], 10);
           month = parseInt(isoMatch[2], 10) - 1;
           day = parseInt(isoMatch[3], 10);
       } else {
            console.warn(`Could not parse date format: ${dateStr}`);
            return null; // Cannot proceed
       }
  }


  // Validate basic date components
  if (isNaN(day) || isNaN(month) || isNaN(year) || month < 0 || month > 11 || day < 1 || day > 31) {
      console.warn(`Invalid date components parsed from ${dateStr}: D=${day}, M=${month + 1}, Y=${year}`);
      return null;
  }

  // 2. Parse time components (or default to 00:00:00)
  let hour = 0, minute = 0, second = 0;
  if (timeStr) {
    const timeMatch = String(timeStr).match(/(\d{1,2}):(\d{1,2})(?::(\d{1,2}))?/);
    if (timeMatch) {
      hour = parseInt(timeMatch[1], 10);
      minute = parseInt(timeMatch[2], 10);
      second = timeMatch[3] ? parseInt(timeMatch[3], 10) : 0;

       // Validate time components
        if (isNaN(hour) || isNaN(minute) || isNaN(second) || hour < 0 || hour > 23 || minute < 0 || minute > 59 || second < 0 || second > 59) {
             console.warn(`Invalid time components parsed from ${timeStr}. Using 00:00:00.`);
             hour = 0; minute = 0; second = 0;
        }

    } else {
         console.warn(`Could not parse time format: ${timeStr}. Using 00:00:00.`);
    }
  }

  // 3. Construct an ISO-like string *without timezone suffix* representing the LOCAL time.
  // Pad month and day for ISO format compatibility (YYYY-MM-DDTHH:mm:ss)
   const localISO = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}T${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}:${String(second).padStart(2, '0')}`;

  // 4. Use Intl to correctly interpret this local time string *within the target timezone*
  // This is tricky. We need to find the UTC instant corresponding to this local time.
  // Strategy: Create a formatter for the target zone, format a known date (like Unix epoch)
  // in both target zone and UTC, calculate the offset *at that time*, then apply it.
  // Simpler strategy: Format the target local time to components in the *target* zone,
  // then use those components to construct a UTC date.

   try {
       // Create a formatter for the *target* timezone, requesting ALL components
       const formatter = new Intl.DateTimeFormat('en-CA', { // Use locale that gives YYYY-MM-DD
           timeZone: timezone,
           year: 'numeric', month: '2-digit', day: '2-digit',
           hour: '2-digit', minute: '2-digit', second: '2-digit',
           hour12: false // Use 24-hour clock for Date.UTC
       });

        // Construct a Date object TEMPORARILY assuming the components ARE UTC
        // This is just to get a Date object to pass to the formatter. The actual
        // time value might be wrong, but we only need it to calculate the correct offset.
       const tempUTCDateForOffsetCalc = new Date(Date.UTC(year, month, day, hour, minute, second));

       // Format this temporary date IN THE TARGET TIMEZONE to see what local time it corresponds to THERE.
       const parts = formatter.formatToParts(tempUTCDateForOffsetCalc);
       const zonedParts = {};
       parts.forEach(p => { if(p.type !== 'literal') zonedParts[p.type] = p.value; });

       // Now, construct the DEFINITIVE UTC timestamp using the components AS THEY APPEAR LOCALLY
       // in the target timezone. This essentially reverses the timezone offset correctly.
       // Note: `Intl` might give slightly different hour/day due to DST when formatting.
       // It's usually better to construct the local ISO string and find its offset.

       // --- More Reliable Method ---
       // Find the offset for the target timezone *at the approximate date*
       const roughDate = new Date(Date.UTC(year, month, day, 12)); // Midday avoids some DST edge cases
       const offsetMinutes = getOffsetMinutesAtDate(roughDate, timezone);

       // Construct the UTC time from components, THEN subtract the calculated offset
       // This gives the UTC instant that *corresponds* to the desired local time YYYY-MM-DD HH:MM:SS
       // in the target zone.
       const intendedUTCTime = Date.UTC(year, month, day, hour, minute, second);
       const actualInstantEpoch = intendedUTCTime - (offsetMinutes * 60 * 1000);

       const finalDate = new Date(actualInstantEpoch);

        // Sanity check: Format the result back using the target timezone
        // const checkFormatter = new Intl.DateTimeFormat('en-US', { timeZone: timezone, dateStyle: 'short', timeStyle: 'medium' });
        // console.log(`Created date for ${dateStr} ${timeStr || ''} [${timezone}]: ${finalDate.toISOString()}, checks as ${checkFormatter.format(finalDate)}`);

       return { date: finalDate, timezone: timezone }; // Return Date object and timezone string

   } catch (e) {
       console.error(`Error creating zoned date time for ${localISO} in ${timezone}:`, e);
       // Fallback: Try creating date assuming local components are UTC (likely wrong offset)
       try {
           const fallbackDate = new Date(Date.UTC(year, month, day, hour, minute, second));
           console.warn("Falling back to UTC interpretation.");
           return { date: fallbackDate, timezone: 'UTC'}; // Fallback timezone
       } catch (finalError) {
           console.error("Fallback date creation failed:", finalError);
           return null;
       }
   }
}

function getOffsetMinutesAtDate(date, timezone) {
  try {
      const formatter = new Intl.DateTimeFormat('en-US', {
          timeZone: timezone,
          timeZoneName: 'longOffset', // Request offset like GMT-05:00
      });
      const parts = formatter.formatToParts(date);
      const offsetPart = parts.find(p => p.type === 'timeZoneName');

      if (offsetPart) {
          const offsetMatch = offsetPart.value.match(/GMT([+-])(\d{1,2}):?(\d{2})?/);
          if (offsetMatch) {
              const sign = offsetMatch[1] === '+' ? 1 : -1;
              const hours = parseInt(offsetMatch[2], 10);
              const minutes = offsetMatch[3] ? parseInt(offsetMatch[3], 10) : 0;
              return sign * (hours * 60 + minutes);
          }
      }
      
      console.warn(`Could not parse offset from Intl: ${offsetPart?.value} for ${timezone}`);

  } catch (e) {
      console.error(`Error getting offset for ${timezone}:`, e);
  }
    // Fallback: estimate from current local offset (less accurate for past/future dates)
    console.warn(`Falling back to local offset estimation for ${timezone}`);
    return -(new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTimezoneOffset());
}

function formatZonedTime(date, timezone, options = {}) {
    if (!(date instanceof Date) || !timezone) return '';
    try {
        const defaultOptions = {
            timeZone: timezone,
            hour: 'numeric', // Use 'numeric' or '2-digit'
            minute: '2-digit',
             // Optionally show timezone name:
             // timeZoneName: 'short' // e.g., PST, CET, EST
        };
        return date.toLocaleTimeString(CONFIG.currentLanguage || 'en', { ...defaultOptions, ...options });
    } catch (e) {
        console.error(`Error formatting time for zone ${timezone}:`, e);
        // Fallback to UTC time display
        return date.toLocaleTimeString(CONFIG.currentLanguage || 'en', { timeZone: 'UTC', hour: 'numeric', minute: '2-digit', timeZoneName: 'short' }) + " (UTC Fallback)";
    }
}

// Refined Formatting Function (Example for Date)
function formatZonedDate(date, timezone, options = {}) {
     if (!(date instanceof Date) || !timezone) return '';
     try {
         const defaultOptions = {
             timeZone: timezone,
             year: 'numeric',
             month: 'long', // or 'short', 'numeric', '2-digit'
             day: 'numeric', // or '2-digit'
              // weekday: 'long' // optional
         };
         return date.toLocaleDateString(CONFIG.currentLanguage || 'en', { ...defaultOptions, ...options });
     } catch (e) {
         console.error(`Error formatting date for zone ${timezone}:`, e);
         return date.toLocaleDateString(CONFIG.currentLanguage || 'en', { timeZone: 'UTC' }) + " (UTC Fallback)";
     }
}

// Unified event cancellation checker
function checkEventCancellation(eventInstance, date) {
  if (!eventInstance.EventID || !window.cancelledEvents.some(c => c.AffectsEventID === eventInstance.EventID)) {
    return { isCancelled: false, reason: null };
  }

  // Get the date to check - either provided date or event's StartDate
  const eventTimezone = eventInstance.Timezone || 'UTC';
  const eventDate = date || eventInstance.StartDate || createZonedDateTime(eventInstance.DateStart, eventInstance.TimeStart, eventTimezone);
  
  // If there's no valid date to check, we can't determine if it's cancelled
  if (!eventDate || typeof eventDate.getTime !== 'function') {
    return { isCancelled: false, reason: null };
  }

  const cancellations = window.cancelledEvents.filter(c => c.AffectsEventID === eventInstance.EventID);

  for (const cancel of cancellations) {
    const cancelStartZdtResult = createZonedDateTime(cancel.DateStart, cancel.TimeStart, eventTimezone);
    const cancelEndZdtResult = createZonedDateTime(cancel.DateEnd || cancel.DateStart, cancel.TimeEnd, eventTimezone);

    if (!cancelStartZdtResult) {
        console.warn(`Could not parse cancellation start date for ${eventInstance.EventID}: ${cancel.DateStart}`);
        continue;
    }
    let cancelStart = cancelStartZdtResult.date;
    let cancelEnd = cancelEndZdtResult ? cancelEndZdtResult.date : null;
    if (!cancelEnd) {
         const endOfDayCancelZdt = createZonedDateTime(cancel.DateStart, '23:59:59', eventTimezone);
         if(endOfDayCancelZdt) cancelEnd = endOfDayCancelZdt.date;
    }
    if (!cancelEnd) {
       console.warn(`Could not determine cancellation end time for ${eventInstance.EventID} starting ${cancel.DateStart}`);
       cancelEnd = new Date(cancelStart.getTime() + 60000); // cancel for 1 minute
    }

    // Compare UTC epoch milliseconds
    if (eventDate.getTime() >= cancelStart.getTime() && eventDate.getTime() <= cancelEnd.getTime()) {
      return { isCancelled: true, reason: cancel.Reason };
    }
  }

  return { isCancelled: false, reason: null };
}

// Apply cancellations to events
function applyCancellationsToEvents(events) {
  
  // Process each event and check for cancellations
  events.forEach(event => {
    // Only check events with an ID that might have cancellations
    if (event.EventID) {
      const { isCancelled, reason } = checkEventCancellation(event, event.StartDate);
      if (isCancelled) {
        event.isCancelled = true;
        event.cancellationReason = reason;
      }
    }
  });
  
  // Return events with cancellation flags set
  return events.filter(event => !event.isCancelled);
}

// Get events for current month
function getEventsForMonth(month, year, entityId, isLocation = true) {
    // --- FIND THE TARGET TIMEZONE ---
    let targetTimezone = 'UTC'; // Default
    let associatedLocation = null;
    if (isLocation) {
        associatedLocation = window.locationMap.get(entityId);
    } else {
        // Find the *primary* location for the priest to determine timezone context
        const priestLocations = window.locations.filter(location =>
            location.ReligiousIdArray && location.ReligiousIdArray.includes(entityId)
        );
        if (priestLocations.length > 0) {
             // Use the first location found, or could add logic for 'primary' location later
             associatedLocation = priestLocations[0];
        }
    }
    if (associatedLocation && associatedLocation.Timezone) {
        targetTimezone = associatedLocation.Timezone;
    } else if (associatedLocation) {
        console.warn(`Location ${associatedLocation.LocationID} missing timezone property. Using UTC.`);
    } else {
         console.warn(`Could not find associated location for ${entityId}. Using UTC.`);
    }
    // -------------------------------

    const potentiallyRelevantEvents = window.events.filter(event => {

        const entityMatches = isLocation ? (event.LocationID === entityId) : (event.PriestID === entityId);
        if (!entityMatches) return false;

        // --- Look up event's specific location and timezone ---
        const eventLocationId = event.LocationID;
        const eventLocation = window.locationMap.get(eventLocationId);
        const eventTimezone = eventLocation?.Timezone || 'UTC'; // Timezone of the EVENT ITSELF
        //-----------------------------------------------------

        // Use createZonedDateTime for event start date
        const startZdtResult = createZonedDateTime(event.DateStart, event.TimeStart, eventTimezone);
        if (!startZdtResult) return false; // Skip if start date invalid
        const eventStartDate = startZdtResult.date;

        const repeats = event.Repeats || '';

        // Determine the range of the current view IN THE TARGET TIMEZONE
        // Use start/end of month based on the *context timezone* (usually the primary location's zone)
         const startOfMonthZdtResult = createZonedDateTime(`${year}-${month + 1}-01`, '00:00:00', targetTimezone);
         if (!startOfMonthZdtResult) return false; // Cannot determine month range
         const startOfMonth = startOfMonthZdtResult.date;

         // Last day of month requires careful construction
         const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0)); // Last day in UTC
         const endOfMonthZdtResult = createZonedDateTime(
             `${lastDayOfMonth.getUTCFullYear()}-${String(lastDayOfMonth.getUTCMonth() + 1).padStart(2, '0')}-${String(lastDayOfMonth.getUTCDate()).padStart(2, '0')}`,
             '23:59:59', // End of day
             targetTimezone
         );
        if (!endOfMonthZdtResult) return false;
        const endOfMonth = endOfMonthZdtResult.date;
         // --- End Month Range Calculation ---


        if (!repeats) {
            // One-time event
            const endZdtResult = createZonedDateTime(event.DateEnd || event.DateStart, event.TimeEnd, eventTimezone);
            const actualEndDate = endZdtResult ? endZdtResult.date : null;

            if (actualEndDate) {
                return eventStartDate.getTime() <= endOfMonth.getTime() && actualEndDate.getTime() >= startOfMonth.getTime();
            } else {
                // If end date invalid, just check if start is within month
                return eventStartDate.getTime() >= startOfMonth.getTime() && eventStartDate.getTime() <= endOfMonth.getTime();
            }
        } else {
            // Repeating event: Check if the first occurrence starts before the end of the view window
            return eventStartDate.getTime() <= endOfMonth.getTime();
        }
    });

    // --- Month range calculation (repeat for main logic) ---
     const startOfMonthZdtResult = createZonedDateTime(`${year}-${month + 1}-01`, '00:00:00', targetTimezone);
     const startOfMonth = startOfMonthZdtResult ? startOfMonthZdtResult.date : new Date(Date.UTC(year, month, 1)); // Fallback to UTC start

     const lastDayOfMonth = new Date(Date.UTC(year, month + 1, 0));
     const endOfMonthZdtResult = createZonedDateTime(
        `${lastDayOfMonth.getUTCFullYear()}-${String(lastDayOfMonth.getUTCMonth() + 1).padStart(2, '0')}-${String(lastDayOfMonth.getUTCDate()).padStart(2, '0')}`,
        '23:59:59',
        targetTimezone
     );
    const endOfMonth = endOfMonthZdtResult ? endOfMonthZdtResult.date : new Date(Date.UTC(year, month + 1, 0, 23, 59, 59)); // Fallback
    // --- End Month Range ---


    let expandedEvents = [];

    potentiallyRelevantEvents.forEach(event => {
        const eventLocationId = event.LocationID;
        const eventLocation = window.locationMap.get(eventLocationId);
        const eventTimezone = eventLocation?.Timezone || 'UTC'; // USE EVENT'S ZONE

        const seriesStartZdtResult = createZonedDateTime(event.DateStart, event.TimeStart, eventTimezone);
        if (!seriesStartZdtResult) return;
        let seriesStartDate = seriesStartZdtResult.date;

        const seriesEndZdtResult = event.DateEnd ? createZonedDateTime(event.DateEnd, event.TimeEnd, eventTimezone) : null;
        let seriesEndDate = seriesEndZdtResult ? seriesEndZdtResult.date : null;

        // --- Calculate duration based on *zoned* start/end ---
        let durationMs = 2 * 60 * 60 * 1000; // Default 2 hours
        if (seriesEndDate && event.TimeEnd) {
            // Duration between explicitly zoned start and end
            durationMs = seriesEndDate.getTime() - seriesStartDate.getTime();
        } else if (!seriesEndDate && event.TimeStart) {
             // Ends same day (no explicit end date, but has start time)
             // Calculate end time relative to start date
             const endOfDayZdtResult = createZonedDateTime(event.DateStart, '23:59:59', eventTimezone);
             if (endOfDayZdtResult) {
                  durationMs = endOfDayZdtResult.date.getTime() - seriesStartDate.getTime();
             }
        } // Else use default
        if (durationMs <= 0) durationMs = 2 * 60 * 60 * 1000; // Ensure positive duration
        // ----------------------------------------------------


        const repeats = event.Repeats || '';
        let currentDate = new Date(seriesStartDate); // Start iteration from the zoned start date

        const loopUntilDate = seriesEndDate ?
             new Date(Math.min(seriesEndDate.getTime(), endOfMonth.getTime()))
             : endOfMonth;


        while (currentDate.getTime() <= loopUntilDate.getTime()) {
             // Check if this instance is within the view month range
             if (currentDate.getTime() >= startOfMonth.getTime() && currentDate.getTime() <= endOfMonth.getTime()) {
                  const instanceEndDate = new Date(currentDate.getTime() + durationMs);
                  const eventCopy = {
                      ...event,
                      StartDate: new Date(currentDate), // The Date object (UTC instant)
                      EndDate: instanceEndDate,
                      Timezone: eventTimezone, // Store the relevant timezone for display!
                      OriginalDateStart: event.DateStart,
                      OriginalDateEnd: event.DateEnd
                  };
                  expandedEvents.push(eventCopy);
             }

            if (!repeats) break;

             const previousLoopDate = new Date(currentDate);
            // --- Advance date logic (requires careful timezone handling for monthly/yearly) ---
            // This is complex to do perfectly without a library like Luxon.
            // For monthly/yearly, Date objects might jump DST incorrectly.
            // Simplification: Advance by days for simplicity, accept minor inaccuracy for M/Y repeats across DST.
            // Proper Solution: Use Luxon or date-fns-tz for advancement.
            switch (repeats.toLowerCase()) {
                case 'daily': currentDate.setUTCDate(currentDate.getUTCDate() + 1); break;
                case 'weekly': currentDate.setUTCDate(currentDate.getUTCDate() + 7); break;
                case 'every2weeks': currentDate.setUTCDate(currentDate.getUTCDate() + 14); break;
                case 'monthly':
                case 'everymonth':
                    currentDate.setUTCMonth(currentDate.getUTCMonth() + 1); break; // DST Warning!
                case 'every2months':
                     currentDate.setUTCMonth(currentDate.getUTCMonth() + 2); break; // DST Warning!
                case 'yearly':
                case 'everyyear':
                     currentDate.setUTCFullYear(currentDate.getUTCFullYear() + 1); break; // DST Warning!
                 default:
                    console.warn(`Unknown repeat type: ${repeats}`);
                    currentDate = new Date(loopUntilDate.getTime() + 1); // Force exit
                    break;
            }
            // --------------------------------------------------------------


             if (currentDate.getTime() <= previousLoopDate.getTime()) {
                 console.error(`Date didn't advance for event ${event.EventID}. Loop detected. Breaking.`);
                 break;
             }
             if (currentDate.getTime() > loopUntilDate.getTime() && repeats) {
                break;
            }
        } // end while
    }); // end forEach potentiallyRelevant

    const finalEvents = applyCancellationsToEvents(expandedEvents);
    return finalEvents;
}

// Get upcoming events
function getUpcomingEvents(entityId, isLocation = true, limit = 3) {
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();
  
  // Get events for current month and next month
  const events = [
    ...getEventsForMonth(currentMonth, currentYear, entityId, isLocation),
    ...getEventsForMonth((currentMonth + 1) % 12, currentMonth === 11 ? currentYear + 1 : currentYear, entityId, isLocation)
  ];
  
  // Filter for future events
  const futureEvents = events.filter(event => {
    return event.StartDate && event.StartDate > now;
  });
  
  // Sort by date
  futureEvents.sort((a, b) => a.StartDate - b.StartDate);
  
  // Return limited number of events
  return futureEvents.slice(0, limit);
}

function getEventsForDay(entityId, year, month, day, isLocation = true) {
  // --- Determine Context Timezone (for header/day range) ---
  let contextTimezone = 'UTC';
  const entityLocation = isLocation ? window.locationMap.get(entityId) : window.locations.find(l => l.ReligiousIdArray?.includes(entityId));
  if (entityLocation?.Timezone) {
    contextTimezone = entityLocation.Timezone;
  }
  
  // --- Determine Date Range for the selected day in Context Timezone ---
  const targetDayStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
  const startOfDayZdt = createZonedDateTime(targetDayStr, '00:00:00', contextTimezone);
  const endOfDayZdt = createZonedDateTime(targetDayStr, '23:59:59', contextTimezone);

  if (!startOfDayZdt || !endOfDayZdt) {
    console.error('Error calculating date range for this day.');
    return [];
  }
  
  const targetDayStart = startOfDayZdt.date; // The UTC instant representing start of day
  const targetDayEnd = endOfDayZdt.date;     // The UTC instant representing end of day

  // Get all expanded events for the month
  const allMonthEvents = getEventsForMonth(month, year, entityId, isLocation);

  // Filter for events whose *start time* (UTC instant) falls within the calculated day range
  const dayEvents = allMonthEvents.filter(eventInstance => {
    if (!eventInstance?.StartDate) return false;
    const eventStartMs = eventInstance.StartDate.getTime();
    return eventStartMs >= targetDayStart.getTime() && eventStartMs <= targetDayEnd.getTime();
  });

  // Sort events by their start time (epoch comparison is fine)
  return dayEvents.sort((a, b) => a.StartDate.getTime() - b.StartDate.getTime());
}

// Function to get translated religious type
function getTranslatedReligiousType(type) {
  if (!type) return 'Fr.'; // Default fallback
  
  // Fallbacks for common types if translations aren't available
  const fallbacks = {
    'bishop': '$$title-bishop$$',
    'priest': '$$title-priest$$',
    'father': '$$title-priest$$',
    'sister': '$$title-sister$$',
    'mother': '$$title-mother$$',
    'brother': '$$title-brother$$'
  };
  
  return fallbacks[type.toLowerCase()] || type;
}

// Function to validate URLs
function isValidUrl(urlString) {
  if (!urlString) return false;
  urlString = urlString.trim();
  if (urlString === '') return false;
  
  // Basic URL validation
  try {
    new URL(urlString);
    return true;
  } catch (e) {
    return false;
  }
}


//----------------------------------------------------
// Function: showUpcomingEvents
// Purpose: Displays a list of the next few upcoming events.
// Uses:    getUpcomingEvents, formatZonedDate, formatZonedTime,
//          locationMap, religiousMap
//----------------------------------------------------
function showUpcomingEvents(entityId, isLocation = true) {
  const eventsEl = document.getElementById('calendarEvents');
  if (!eventsEl) {
    console.error("Calendar events display element not found!");
    return;
  }
  eventsEl.innerHTML = ''; // Clear previous content

  const upcomingHeading = document.createElement('h3');
  upcomingHeading.textContent = 'Upcoming Events';
  eventsEl.appendChild(upcomingHeading);

  const upcomingEvents = getUpcomingEvents(entityId, isLocation);

  if (upcomingEvents.length === 0) {
    const noEventsEl = document.createElement('p');
    noEventsEl.textContent = 'No upcoming events scheduled.';
    eventsEl.appendChild(noEventsEl);
  } else {
    const clickMessage = document.createElement('p');
    clickMessage.textContent = 'Click a date on the calendar to see events for that day.';
    clickMessage.style.fontStyle = 'italic';
    clickMessage.style.fontSize = '0.9em';
    clickMessage.style.color = 'grey';
    eventsEl.appendChild(clickMessage);

    upcomingEvents.forEach(event => {
      const eventEl = document.createElement('div');
      eventEl.className = 'calendar-event';
      
      // Apply cancelled styling if needed
      if (event.isCancelled) {
        eventEl.classList.add('cancelled');
        eventEl.style.textDecoration = 'line-through';
        eventEl.style.color = 'grey';
      }

      // Event header - More compact format: "Fri Apr 25 - Mass @ 12:00 AM GMT+2"
      const headerEl = document.createElement('div');
      headerEl.className = 'calendar-event-header';
      headerEl.style.fontWeight = 'bold';
      
      let headerText = '';
      
      if (event.StartDate) {
        // Format day and date
        headerText += formatZonedDate(event.StartDate, event.Timezone, { 
          weekday: 'short', 
          month: 'short', 
          day: 'numeric' 
        });
      }
      
      // Add event type
      headerText += ` - ${event.EventType || 'Event'}`;
      
      // Add time with timezone
      if (event.StartDate) {
        headerText += ` - ${formatZonedTime(event.StartDate, event.Timezone, { timeZoneName: 'short' })}`;
      }
      
      headerEl.textContent = headerText;
      eventEl.appendChild(headerEl);

      // Person or Location details in simpler format
      if (isLocation && event.PriestID) {
        const priest = window.religiousMap.get(event.PriestID);
        if (priest) {
          const priestEl = document.createElement('div');
          priestEl.className = 'calendar-event-priest';
          // Use translated type
          const translatedType = getTranslatedReligiousType(priest.Type);
          priestEl.textContent = `${translatedType} ${priest.Name || ''}`;
          eventEl.appendChild(priestEl);
        }
      } else if (!isLocation && event.LocationID) {
        const location = window.locationMap.get(event.LocationID);
        if (location) {
          const locationEl = document.createElement('div');
          locationEl.className = 'calendar-event-location';
          locationEl.textContent = `@ ${location.Name || 'Unknown Location'}`;
          eventEl.appendChild(locationEl);
        }
      }

      // Display cancellation reason if applicable
      if (event.isCancelled && event.cancellationReason) {
        const cancelEl = document.createElement('div');
        cancelEl.className = 'calendar-event-cancelled';
        cancelEl.style.color = '#cc0000'; // Dark red
        cancelEl.style.fontWeight = 'bold';
        cancelEl.textContent = `Cancelled: ${event.cancellationReason}`;
        eventEl.appendChild(cancelEl);
      }

      // Add spacing between events
      eventEl.style.marginBottom = '10px';
      eventEl.style.paddingBottom = '5px';
      eventEl.style.borderBottom = '1px dashed #ccc';

      eventsEl.appendChild(eventEl);
    });
  }
}

function rerenderCalendarPopup(entityId, isLocation = true) {
  const popup = document.getElementById('calendarPopup');
  if (!popup) return;
  
  const entity = isLocation ? window.locationMap.get(entityId) : window.religiousMap.get(entityId);
  if (!entity) return;
  
  // Update title
  const entityName = isLocation ? entity.Name : `${getTranslatedReligiousType(entity.Type)} ${entity.Name}`;
  const titleElement = popup.querySelector('.calendar-title');
  if (titleElement) {
    titleElement.textContent = `${entityName} - $$calendar-title$$`;
  }
  
  // Get current view's month and year from the grid dataset
  const grid = document.getElementById('calendarGrid');
  let currentMonth = new Date().getMonth();
  let currentYear = new Date().getFullYear();
  
  if (grid && grid.dataset.month && grid.dataset.year) {
    currentMonth = parseInt(grid.dataset.month, 10);
    currentYear = parseInt(grid.dataset.year, 10);
  }
  
  // Regenerate calendar with the new entity and current view
  generateCalendar(entityId, currentMonth, currentYear, isLocation);
  
  // Show upcoming events
  showUpcomingEvents(entityId, isLocation);
}

// Generate HTML for buttons
function getHtmlForButtons(buttons) {
  const actionsContainer = document.createElement('div');
  actionsContainer.className = 'actions-container';
  actionsContainer.style.display = 'grid';
  actionsContainer.style.gridTemplateColumns = 'repeat(2, 1fr)';
  actionsContainer.style.gap = '8px';
  
  const buttonElements = [];
  
  buttons.forEach(button => {
    if (!button.content) return;
    
    let element;
    
    switch (button.type) {
      case 'link':
        element = document.createElement('a');
        element.href = button.content;
        if (button.external) {
          element.target = "_blank";
        }
        break;
      case 'email':
        element = document.createElement('a');
        element.href = `mailto:${button.content}`;
        break;
      case 'phone':
        element = document.createElement('a');
        element.href = `tel:${button.content}`;
        break;
      case 'calendar':
      case 'info':
      default:
        element = document.createElement('button');
        element.addEventListener('click', button.onClick || (() => {}));
        break;
    }
    
    element.className = button.class || 'action-btn';
    if (button.donate) {
      element.className += ' donate-btn';
    }
    
    element.textContent = button.text;
    buttonElements.push(element);
  });
  
  // If there's an odd number of buttons, make the first one span the full width
  if (buttonElements.length % 2 !== 0 && buttonElements.length > 0) {
    buttonElements[0].style.gridColumn = "1 / span 2";
  }
  
  // Add all buttons to container
  buttonElements.forEach(btn => {
    actionsContainer.appendChild(btn);
  });
  
  return actionsContainer;
}

// Generate calendar HTML
function getHtmlForCalendar(month, year, entityId, isLocation = true) {
  const container = document.createElement('div');
  container.className = 'calendar-container';
  
  // Month names
  const monthNames = [
    '$$month-january$$', '$$month-february$$', '$$month-march$$', '$$month-april$$', 
    '$$month-may$$', '$$month-june$$', '$$month-july$$', '$$month-august$$', 
    '$$month-september$$', '$$month-october$$', '$$month-november$$', '$$month-december$$'
  ];
  
  // Day names
  const dayNames = ['$$day-sun$$', '$$day-mon$$', '$$day-tue$$', '$$day-wed$$', '$$day-thu$$', '$$day-fri$$', '$$day-sat$$'];
  
  // Add month/year header with copy link button
  const headerContainer = document.createElement('div');
  headerContainer.style.display = 'flex';
  headerContainer.style.alignItems = 'center';
  headerContainer.style.justifyContent = 'space-between';
  headerContainer.style.marginBottom = '10px';
  
  const header = document.createElement('div');
  header.className = 'calendar-month-year';
  header.textContent = `${monthNames[month]} ${year}`;
  
  const copyButton = document.createElement('button');
  copyButton.className = 'copy-link-btn';
  copyButton.innerHTML = '<svg width="16" height="16" viewBox="0 0 16 16" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M6.5 5.5L9.5 8.5M9.5 5.5L6.5 8.5M4.5 3.5H11.5C12.0523 3.5 12.5 3.94772 12.5 4.5V11.5C12.5 12.0523 12.0523 12.5 11.5 12.5H4.5C3.94772 12.5 3.5 12.0523 3.5 11.5V4.5C3.5 3.94772 3.94772 3.5 4.5 3.5Z" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round"/></svg> Copy Link';
  copyButton.style.padding = '5px 10px';
  copyButton.style.background = '#eee';
  copyButton.style.border = 'none';
  copyButton.style.borderRadius = '4px';
  copyButton.style.cursor = 'pointer';
  copyButton.style.display = 'inline-flex';
  copyButton.style.alignItems = 'center';
  copyButton.style.gap = '5px';
  copyButton.style.fontSize = '0.9rem';
  
  copyButton.addEventListener('click', () => {
    // Update URL hash first to ensure we're copying the correct URL
    updateUrlHash(entityId, true);
    copyCurrentUrlToClipboard();
  });
  
  headerContainer.appendChild(header);
  headerContainer.appendChild(copyButton);
  container.appendChild(headerContainer);
  
  // Create grid
  const grid = document.createElement('div');
  grid.className = 'calendar-grid';
  
  // Add day headers
  dayNames.forEach(day => {
    const dayHeader = document.createElement('div');
    dayHeader.className = 'calendar-day-header';
    dayHeader.textContent = day;
    grid.appendChild(dayHeader);
  });
  
  // Get first day of the month and total days
  const firstDay = new Date(year, month, 1);
  const startingDay = firstDay.getDay();
  const lastDay = new Date(year, month + 1, 0);
  const totalDays = lastDay.getDate();
  
  // Get events for this month
  const monthEvents = getEventsForMonth(month, year, entityId, isLocation);
  
  // Create map of dates with events
  const datesWithEvents = new Map();
  monthEvents.forEach(event => {
    if (event.StartDate) {
      const eventDay = event.StartDate.getDate();
      if (!datesWithEvents.has(eventDay)) {
        datesWithEvents.set(eventDay, []);
      }
      datesWithEvents.get(eventDay).push(event);
    }
  });
  
  // Add days from previous month
  const prevMonth = month === 0 ? 11 : month - 1;
  const prevYear = month === 0 ? year - 1 : year;
  const prevMonthLastDay = new Date(prevYear, prevMonth + 1, 0).getDate();
  
  for (let i = 0; i < startingDay; i++) {
    const day = prevMonthLastDay - startingDay + i + 1;
    const dayEl = document.createElement('div');
    dayEl.className = 'calendar-day other-month';
    dayEl.textContent = day;
    grid.appendChild(dayEl);
  }
  
  // Add current month days
  for (let day = 1; day <= totalDays; day++) {
    let c = "";
    if (datesWithEvents.has(day)) {
      c = "has-events";
    }
    // NOTE: Don't change this
    let dayel_html = `<button class='calendar-day ${c}' onclick="showEventsForDay('${entityId}', ${year}, ${month}, ${day}, '${isLocation}')">${day}</button>`;
    grid.appendChild(createElementFromHTML(dayel_html));
  }
  
  // Add next month days
  const totalCells = Math.ceil((startingDay + totalDays) / 7) * 7;
  const nextMonthDays = totalCells - (startingDay + totalDays);
  
  for (let day = 1; day <= nextMonthDays; day++) {
    const dayEl = document.createElement('div');
    dayEl.className = 'calendar-day other-month';
    dayEl.textContent = day;
    grid.appendChild(dayEl);
  }
  
  container.appendChild(grid);
  
  // Add export buttons below the grid
  const exportButtonsContainer = document.createElement('div');
  exportButtonsContainer.className = 'calendar-export-buttons';
  exportButtonsContainer.style.display = 'flex';
  exportButtonsContainer.style.gap = '10px';
  exportButtonsContainer.style.marginTop = '15px';
  exportButtonsContainer.style.marginBottom = '10px';
  
  // Create PDF export button
  const pdfButton = document.createElement('button');
  pdfButton.className = 'action-btn';
  pdfButton.textContent = 'Export to PDF';
  pdfButton.addEventListener('click', () => {
    generateCalendarPDF(entityId, isLocation);
  });
  
  // Create iCal export button
  const iCalButton = document.createElement('button');
  iCalButton.className = 'action-btn';
  iCalButton.textContent = 'Export to iCal';
  iCalButton.addEventListener('click', () => {
    generateICalFile(entityId, isLocation);
  });
  
  // Add buttons to container
  exportButtonsContainer.appendChild(pdfButton);
  exportButtonsContainer.appendChild(iCalButton);
  
  // Add the export buttons container to the main container
  container.appendChild(exportButtonsContainer);
  
  return container;
}

function createElementFromHTML(htmlString) {
  var div = document.createElement('div');
  div.innerHTML = htmlString.trim();
  return div.firstElementChild;
}

// Show location info function
function showLocationInfo(location) {

  const infoPanel = document.getElementById('infoPanel');
  const priestName = document.getElementById('priestName');
  const priestInfo = document.getElementById('priestInfo');
  
  // Reset all markers before showing this one
  resetAllMarkers();
  
  // Close calendar if open
  closeCalendarPopup();
  
  // Set location name
  priestName.textContent = location.Name;
  
  // Clear previous info
  priestInfo.innerHTML = '';
  
  // Associated religious
  if (location.ReligiousIdArray && location.ReligiousIdArray.length > 0) {
    const religiousParagraph = document.createElement('p');
    religiousParagraph.className = 'info-paragraph';
    religiousParagraph.textContent = "$$served-by$$: ";
    
    // Add links for each religious person
    location.ReligiousIdArray.forEach((id, index) => {
      const person = window.religiousMap.get(id);
      if (person) {
        // Use proper translated title
        const translatedType = getTranslatedReligiousType(person.Type);
        
        const priestLink = document.createElement('a');
        priestLink.className = 'priest-link';
        priestLink.textContent = `${translatedType} ${person.Name}`;
        priestLink.href = '#';
        priestLink.addEventListener('click', (e) => {
          e.preventDefault();
          showPriestInfo(person);
        });
        
        religiousParagraph.appendChild(priestLink);
        
        // Add comma if not the last person
        if (index < location.ReligiousIdArray.length - 1) {
          religiousParagraph.appendChild(document.createTextNode(', '));
        }
      }
    });
    
    priestInfo.appendChild(religiousParagraph);
  }

  // Create buttons with validated website
  const buttons = [
    // Google Maps link
    (location.GoogleMaps || (location.Latitude && location.Longitude)) ? 
      { 
        type: 'link', 
        text: "$$view-on-maps$$", 
        content: location.GoogleMaps || `https://www.google.com/maps?q=${location.Latitude},${location.Longitude}`, 
        external: true 
      } : null,
    
    // Website link - only add if URL is valid
    (location.Website && isValidUrl(location.Website)) ? 
      { type: 'link', text: "$$website$$", content: location.Website, external: true } : null,
    
    // Email
    (location.ContactEmail && location.ContactEmail.replace("mailto:", "").replace("'", "").trim().length > 0) ? 
      { type: 'email', text: "$$email$$", content: location.ContactEmail } : null,
    
    // Phone
    (location.ContactPhone && location.ContactPhone.replace("tel:", "").replace("'", "").trim().length > 0) ? 
      { type: 'phone', text: "$$phone$$", content: location.ContactPhone } : null,
    
    // Notes
    (location.Notes && location.Notes.trim().length > 0) ? 
      { 
        type: 'info', 
        text: "$$show-more-info$$", 
        content: "info", 
        onClick: () => { 
          alert(`${location.Name} (${location.LocationType})\n\n$$notes$$: ${location.Notes}`); 
        } 
      } : null,
    
    // Calendar button
    { 
      type: 'calendar', 
      text: "$$view-calendar$$", 
      content: "calendar", 
      onClick: () => { showLocationCalendar(location); } 
    }
  ].filter(Boolean); // Remove null entries
  
  // Add donate button if available
  const fundingInfo = getFundingInfo(location.LocationID);
  if (fundingInfo) {
    let donateText = '$$donate$$';
    if (fundingInfo.FundingGoal && fundingInfo.CurrentAmount) {
      const percentage = Math.round((fundingInfo.CurrentAmount / fundingInfo.FundingGoal) * 100);
      donateText += ` (${percentage}% $$funded$$)`;
    }
    
    buttons.push({
      type: 'link',
      text: donateText,
      content: fundingInfo.DonationLinks,
      external: true,
      donate: true
    });
  }
  
  // Add buttons to info panel
  priestInfo.appendChild(getHtmlForButtons(buttons));

  // Show the info panel
  infoPanel.style.display = 'flex';
  
  // Adjust zoom based on current zoom for smoother transition
  const currentZoom = map.getZoom();
  const targetZoom = Math.max(currentZoom, 12); // Don't zoom out if already zoomed in
  
  // Fly to location
  map.flyTo([location.Latitude, location.Longitude], targetZoom, {
    animate: true,
    duration: 0.5
  });
  
  // Highlight this location and connected locations
  highlightLocation(location);

  // Update URL
  updateUrlHash(location.LocationID, false);
}

function formatBioText(person) {
  // Get proper translated title
  const translatedType = getTranslatedReligiousType(person.Type);
  
  let bioText = `${translatedType} ${person.Name}\n\n`;
  const details = [];
  
  // Ordination info
  if (person['OrdainedInRite'] || person['OrdainedBy']) {
    let ordinationText = `${translatedType} ${person.Name} was ordained`;
    
    if (person['OrdainedInRite']) {
      ordinationText += ` in the ${person['OrdainedInRite']}`;
    }
    
    if (person['OrdainedBy']) {
      const ordainedByTranslation = getTranslatedReligiousType('Bishop');
      ordinationText += ` by ${ordainedByTranslation} ${person['OrdainedBy']}`;
    }
    
    details.push(ordinationText);
  }
  
  // Bishop line
  if (person['BishopLine']) {
    details.push(`Bishop line: ${person['BishopLine']}`);
  }
  
  // Born year
  if (person['BornYear']) {
    details.push(`Born in ${person['BornYear']}`);
  }
  
  // Associates With
  if (person['AssociatesWith']) {
    details.push(`Associates with: ${person['AssociatesWith']}`);
  }
  
  // Beliefs
  if (person['Beliefs']) {
    details.push(`Holds ${person['Beliefs']} beliefs`);
  }
  
  // Location
  if (person['Location/Area']) {
    details.push(`Operates in: ${person['Location/Area']}`);
  }
  
  // Join all details
  bioText += details.join('. ') + '.';
  
  // Notes
  if (person['Notes']) {
    bioText += `\n\nNotes: ${person['Notes']}`;
  }
  
  return bioText;
}

// Show priest info function
function showPriestInfo(priest) {
  const infoPanel = document.getElementById('infoPanel');
  const priestName = document.getElementById('priestName');
  const priestInfo = document.getElementById('priestInfo');
  
  // Reset all markers before showing this one
  resetAllMarkers();
  
  // Close calendar if open
  closeCalendarPopup();
  
  // Get proper translated title
  const translatedType = getTranslatedReligiousType(priest.Type);
  
  // Set priest name with proper title
  priestName.textContent = `${translatedType} ${priest.Name || ''}`;
  
  // Clear previous info
  priestInfo.innerHTML = '';
  
  // Add locations served section first
  const priestLocations = window.locations.filter(location => 
    location.ReligiousIdArray && location.ReligiousIdArray.includes(priest.ReligiousID)
  );
  
  if (priestLocations.length > 0) {
    const locationsSection = document.createElement('div');
    locationsSection.className = 'parishes-section';
    
    // Add section title
    const locationsTitle = document.createElement('h3');
    locationsTitle.textContent = "$$parishes-served$$";
    locationsSection.appendChild(locationsTitle);
    
    const locationsList = document.createElement('ul');
    locationsList.className = 'parishes-list';
    
    // Sort locations alphabetically
    priestLocations.sort((a, b) => a.Name.localeCompare(b.Name));
    
    priestLocations.forEach(location => {
      const locationItem = document.createElement('li');
      locationItem.className = 'parish-item';
      
      locationItem.innerHTML = `<strong>${location.Name}</strong>`;
      
      // Add click handler to highlight this location
      locationItem.style.cursor = 'pointer';
      locationItem.addEventListener('click', () => {
        showLocationInfo(location);
      });
      
      locationsList.appendChild(locationItem);
    });
    
    locationsSection.appendChild(locationsList);
    priestInfo.appendChild(locationsSection);
  }

  // Create action buttons
  const buttons = [
    // Website link - validate URL
    (priest.Website && isValidUrl(priest.Website)) ? 
      { type: 'link', text: "$$website$$", content: priest.Website, external: true } : null,
    
    // Email
    (priest.ContactEmail && ("" + priest.ContactEmail).replace("mailto:", "").replace("'", "").trim().length > 0) ? 
      { type: 'email', text: "$$email$$", content: priest.ContactEmail } : null,
    
    // Phone
    (priest.ContactPhone && ("" + priest.ContactPhone).replace("tel:", "").replace("'", "").trim().length > 0) ? 
      { type: 'phone', text: "$$phone$$", content: priest.ContactPhone } : null,
    
    // More info button
    {
      type: 'info', 
      text: "$$show-more-info$$", 
      content: "info", 
      onClick: () => { alert(formatBioText(priest)); } 
    },
    
    // Calendar button
    { 
      type: 'calendar', 
      text: "$$view-calendar$$", 
      content: "calendar", 
      onClick: () => { showPriestCalendar(priest); } 
    }
  ].filter(Boolean);
  
  // Add donate button if available
  const fundingInfo = getFundingInfo(priest.ReligiousID);
  if (fundingInfo) {
    let donateText = '$$donate$$';
    if (fundingInfo.FundingGoal && fundingInfo.CurrentAmount) {
      const percentage = Math.round((fundingInfo.CurrentAmount / fundingInfo.FundingGoal) * 100);
      donateText += ` (${percentage}% $$funded$$)`;
    }
    
    buttons.push({
      type: 'link',
      text: donateText,
      content: fundingInfo.DonationLinks,
      external: true,
      donate: true
    });
  }
  
  // Add buttons to info panel
  priestInfo.appendChild(getHtmlForButtons(buttons));

  // Show the info panel
  infoPanel.style.display = 'flex';
  
  // Find primary location for this priest and adjust zoom based on current zoom
  if (priestLocations.length > 0) {
    let primaryLocation = priestLocations[0];
    // Get current zoom level for smoother transition
    const currentZoom = map.getZoom();
    const targetZoom = Math.max(currentZoom, 8); // Don't zoom out if already zoomed in
    
    map.flyTo([primaryLocation.Latitude, primaryLocation.Longitude], targetZoom, {
      animate: true,
      duration: 0.5
    });
  }
  
  // Highlight this priest's locations
  highlightPriest(priest);

  // Update URL hash
  updateUrlHash(priest.ReligiousID, false);
}

// Highlight location and its connections
function highlightLocation(location) {

  // Reset all markers
  resetAllMarkers();
  
  // Highlight this location's marker
  parishMarkers.eachLayer(marker => {
    if (marker.locationData && marker.locationData.LocationID === location.LocationID) {
      // Create highlighted marker
      const markerSize = CONFIG.parishMarkerSize * 1.5;
      const icon = L.divIcon({
        className: 'parish-marker',
        html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
        iconSize: [markerSize, markerSize],
        iconAnchor: [markerSize/2, markerSize/2]
      });
      marker.setIcon(icon);
    }
  });
  
  // Highlight associated religious
  if (location.ReligiousIdArray && location.ReligiousIdArray.length > 0) {
    location.ReligiousIdArray.forEach(religiousId => {
      priestMarkers.eachLayer(marker => {
        if (marker.priestData && marker.priestData.ReligiousID === religiousId) {
          // Create highlighted marker
          const markerSize = CONFIG.priestMarkerSize * 1.5;
          const icon = L.divIcon({
            className: 'priest-marker pulse',
            html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
            iconSize: [markerSize, markerSize],
            iconAnchor: [markerSize/2, markerSize/2]
          });
          marker.setIcon(icon);
        }
      });
    });
    
    // Highlight connection lines
    connectionLines.eachLayer(line => {
      if (line.fromLocation === location.LocationID || line.toLocation === location.LocationID) {
        line.setStyle({
          color: 'yellow',
          weight: CONFIG.lineWeight * 1.5,
          opacity: 1.0
        });
      }
    });
  }
}

// Highlight priest's locations
function highlightPriest(priest) {
  // Reset all markers
  resetAllMarkers();
  
  // Highlight priest's marker
  priestMarkers.eachLayer(marker => {
    if (marker.priestData && marker.priestData.ReligiousID === priest.ReligiousID) {
      // Create highlighted marker
      const markerSize = CONFIG.priestMarkerSize * 1.5;
      const icon = L.divIcon({
        className: 'priest-marker pulse',
        html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
        iconSize: [markerSize, markerSize],
        iconAnchor: [markerSize/2, markerSize/2]
      });
      marker.setIcon(icon);
    }
  });
  
  // Highlight priest's locations
  parishMarkers.eachLayer(marker => {
    if (marker.locationData && marker.locationData.ReligiousIdArray && 
        marker.locationData.ReligiousIdArray.includes(priest.ReligiousID)) {
      // Create highlighted marker
      const markerSize = CONFIG.parishMarkerSize * 1.5;
      const icon = L.divIcon({
        className: 'parish-marker',
        html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: #00cc00;"></div>`,
        iconSize: [markerSize, markerSize],
        iconAnchor: [markerSize/2, markerSize/2]
      });
      marker.setIcon(icon);
    }
  });
  
  // Highlight connection lines
  connectionLines.eachLayer(line => {
    if (line.religiousId === priest.ReligiousID) {
      line.setStyle({
        color: '#00cc00',
        weight: CONFIG.lineWeight * 1.5,
        opacity: 1.0
      });
    }
  });
}

// Get funding info for an entity
function getFundingInfo(entityId) {
  return window.fundingMap.get(entityId) || null;
}

// Create HTML for the calendar popup
function createCalendarHtml(entityId, isLocation = true) {
  const entity = isLocation ? window.locationMap.get(entityId) : window.religiousMap.get(entityId);
  const entityName = isLocation ? entity.Name : `${entity.Type} ${entity.Name}`;
  
  // Filter events for this entity
  const entityEvents = window.events.filter(event => {
    if (isLocation) {
      return event.LocationID === entityId;
    } else {
      return event.ReligiousID === entityId;
    }
  });
  
  // Get current month and year
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();
  
  // Create calendar HTML
  let html = `
  <div class="calendar-popup" id="calendarPopup">
    <div class="calendar-top">
      <div class="calendar-header">
        <div class="calendar-title">${entityName} - $$calendar-title$$</div>
        <button class="calendar-close" id="calendarClose">×</button>
      </div>
      <div class="calendar-nav">
        <button id="prevMonth">&#8249;</button>
        <div class="calendar-month-year" id="calendarMonthYear"></div>
        <button id="nextMonth">&#8250;</button>
      </div>
      <div class="calendar-grid" id="calendarGrid"></div>
    </div>
    <div class="calendar-bottom">
      <div class="calendar-events" id="calendarEvents"></div>
    </div>
  </div>
  `;
  
  return html;
}

function showEventsForDay(entityId, year, month, day, isLocation = true) {
  const eventsEl = document.getElementById('calendarEvents');
  if (!eventsEl) {
    console.error("Calendar events display element not found!");
    return;
  }
  
  eventsEl.innerHTML = ''; // Clear previous events

  // --- Get context timezone for formatting ---
  let contextTimezone = 'UTC';
  const entityLocation = isLocation ? window.locationMap.get(entityId) : window.locations.find(l => l.ReligiousIdArray?.includes(entityId));
  if (entityLocation?.Timezone) {
    contextTimezone = entityLocation.Timezone;
  }

  // Create the day header using the timezone
  const targetDayStr = `${year}-${String(month + 1).padStart(2, '0')}-${String(day).padStart(2, '0')}`;
  const dayDate = createZonedDateTime(targetDayStr, '12:00:00', contextTimezone);
  
  if (dayDate) {
    const dayHeading = document.createElement('h3');
    dayHeading.textContent = formatZonedDate(dayDate.date, contextTimezone, { 
      weekday: 'long', 
      year: 'numeric', 
      month: 'long', 
      day: 'numeric' 
    });
    eventsEl.appendChild(dayHeading);
  }

  // Get events data using the separated function
  const dayEvents = getEventsForDay(entityId, year, month, day, isLocation);

  // --- Display Events or "No Events" Message ---
  if (dayEvents.length === 0) {
    const noEventsEl = document.createElement('p');
    noEventsEl.textContent = '$$no-events$$';
    eventsEl.appendChild(noEventsEl);
  } else {
    dayEvents.forEach(event => {
      const eventEl = document.createElement('div');
      eventEl.className = 'calendar-event';

      // Apply cancelled styling if needed
      if (event.isCancelled) {
        eventEl.classList.add('cancelled');
        eventEl.style.textDecoration = 'line-through';
        eventEl.style.color = 'grey';
      }

      // Event title (e.g., "Mass", "Confession")
      const titleEl = document.createElement('div');
      titleEl.className = 'calendar-event-title';
      titleEl.textContent = event.EventType || 'Event';
      eventEl.appendChild(titleEl);

      // Event Time - Use zoned formatting!
      if (event.StartDate) {
        const timeEl = document.createElement('div');
        timeEl.className = 'calendar-event-time';
        let timeString = formatZonedTime(event.StartDate, event.Timezone);

        if (event.EndDate && event.EndDate.getTime() !== event.StartDate.getTime()) {
          // Add end time if different
          const durationMs = event.EndDate.getTime() - event.StartDate.getTime();
          if (durationMs > 1000) { // Only show end time if duration > 1 second
            timeString += ` - ${formatZonedTime(event.EndDate, event.Timezone)}`;
          }
        }
        // Add timezone identifier for clarity
        timeString += ` (${formatZonedTime(event.StartDate, event.Timezone, { timeZoneName: 'short' })})`;

        timeEl.textContent = `Time: ${timeString}`;
        eventEl.appendChild(timeEl);
      }

      // Priest or Location details (depending on context)
      if (isLocation && event.PriestID) {
        const priest = window.religiousMap.get(event.PriestID);
        if (priest) {
          const priestEl = document.createElement('div');
          priestEl.className = 'calendar-event-priest';
          priestEl.textContent = `With: ${priest.Type || 'Priest'} ${priest.Name || ''}`;
          eventEl.appendChild(priestEl);
        }
      } else if (!isLocation && event.LocationID) {
        const location = window.locationMap.get(event.LocationID);
        if (location) {
          const locationEl = document.createElement('div');
          locationEl.className = 'calendar-event-location';
          locationEl.textContent = `At: ${location.Name || 'Unknown Location'}`;
          eventEl.appendChild(locationEl);
        }
      }

      // Notes for the event
      if (event.Notes) {
        const notesEl = document.createElement('div');
        notesEl.className = 'calendar-event-notes';
        notesEl.style.fontStyle = 'italic';
        notesEl.textContent = event.Notes;
        eventEl.appendChild(notesEl);
      }

      // Display cancellation reason if applicable
      if (event.isCancelled && event.cancellationReason) {
        const cancelEl = document.createElement('div');
        cancelEl.className = 'calendar-event-cancelled';
        cancelEl.style.color = '#cc0000';
        cancelEl.style.fontWeight = 'bold';
        cancelEl.textContent = `Cancelled: ${event.cancellationReason}`;
        eventEl.appendChild(cancelEl);
      }

      // Append the fully constructed event element
      eventsEl.appendChild(eventEl);
    });
  }
}

// Show location calendar
function showLocationCalendar(location) {
  const result = showCalendar(location, true);
  // Setup calendar after it's displayed
  if (document.getElementById('calendarPopup').style.display === 'flex') {
    rerenderCalendarPopup(location.LocationID, true);
  }
  // Update URL
  updateUrlHash(location.LocationID, true);
  return result;
}

// Show priest calendar
function showPriestCalendar(priest) {
  const result = showCalendar(priest, false);
  // Setup calendar after it's displayed
  if (document.getElementById('calendarPopup').style.display === 'flex') {
    rerenderCalendarPopup(priest.ReligiousID, false);
  }
    // Update URL
    updateUrlHash(priest.ReligiousID, true);
  return result;
}

function showCalendar(entity, isLocation = true) {
  const entityId = isLocation ? entity.LocationID : entity.ReligiousID;
  
  // Add calendar popup to the DOM if it doesn't exist
  if (!document.getElementById('calendarPopup')) {
    const calendarHtml = createCalendarHtml(entityId, isLocation);
    document.body.insertAdjacentHTML('beforeend', calendarHtml);
    
    // Set up event listeners
    document.getElementById('calendarClose').addEventListener('click', () => {
      document.getElementById('calendarPopup').style.display = 'none';
    });
    
    // Previous and next month navigation
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    
    document.getElementById('prevMonth').addEventListener('click', () => {
      currentMonth--;
      if (currentMonth < 0) {
        currentMonth = 11;
        currentYear--;
      }
      generateCalendar(entityId, currentMonth, currentYear, isLocation);
    });
    
    document.getElementById('nextMonth').addEventListener('click', () => {
      currentMonth++;
      if (currentMonth > 11) {
        currentMonth = 0;
        currentYear++;
      }
      generateCalendar(entityId, currentMonth, currentYear, isLocation);
    });
  }
  
  // Show popup
  const popup = document.getElementById('calendarPopup');
  popup.style.display = 'flex';
  popup.style.minHeight = '100%';
  
  // Generate calendar for current month
  const now = new Date();
  generateCalendar(entityId, now.getMonth(), now.getFullYear(), isLocation);
  
  // Show upcoming events
  showUpcomingEvents(entityId, isLocation);
}

// Generate calendar
function generateCalendar(entityId, month, year, isLocation = true) {
  // Update month/year display
  const monthYearEl = document.getElementById('calendarMonthYear');
  const grid = document.getElementById('calendarGrid');
  
  // Clear previous content
  grid.innerHTML = '';
  
  // Get calendar HTML
  const calendarHTML = getHtmlForCalendar(month, year, entityId, isLocation);
  
  // Update display
  monthYearEl.innerHTML = calendarHTML.querySelector('.calendar-month-year').innerHTML;
  grid.innerHTML = calendarHTML.querySelector('.calendar-grid').innerHTML;
}

// Reset all markers to their default style
function resetAllMarkers() {
  // Reset parish markers
  parishMarkers.eachLayer(marker => {
    const markerSize = CONFIG.parishMarkerSize;
    const icon = L.divIcon({
      className: 'parish-marker',
      html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
      iconSize: [markerSize, markerSize],
      iconAnchor: [markerSize/2, markerSize/2]
    });
    marker.setIcon(icon);
  });
  
  // Reset priest markers
  priestMarkers.eachLayer(marker => {
    const markerSize = CONFIG.priestMarkerSize;
    const icon = L.divIcon({
      className: 'priest-marker pulse',
      html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
      iconSize: [markerSize, markerSize],
      iconAnchor: [markerSize/2, markerSize/2]
    });
    marker.setIcon(icon);
  });
  
  // Reset connection lines
  connectionLines.eachLayer(line => {
    line.setStyle({
      color: CONFIG.lineColor,
      weight: CONFIG.lineWeight,
      opacity: CONFIG.lineOpacity
    });
  });
}

function levenshteinDistance(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;

  const matrix = Array(a.length + 1).fill().map(() => Array(b.length + 1).fill(0));

  for (let i = 0; i <= a.length; i++) {
    matrix[i][0] = i;
  }
  for (let j = 0; j <= b.length; j++) {
    matrix[0][j] = j;
  }

  for (let i = 1; i <= a.length; i++) {
    for (let j = 1; j <= b.length; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      matrix[i][j] = Math.min(
        matrix[i - 1][j] + 1,      // deletion
        matrix[i][j - 1] + 1,      // insertion
        matrix[i - 1][j - 1] + cost // substitution
      );
    }
  }

  return matrix[a.length][b.length];
}

// Search results function
function getSearchResults(searchTerm) {
  if (!searchTerm || searchTerm.length < 2) {
    return [];
  }
  
  searchTerm = searchTerm.toLowerCase();
  const searchResults = [];
  
  // Search locations
  window.locations.forEach(location => {
    let bestScore = Infinity;
    let matchField = '';
    
    // Check various fields for matches
    const fieldsToCheck = [
      { field: 'Name', value: location.Name, weight: 1 },
      { field: 'LocationType', value: location.LocationType, weight: 1.2 },
      { field: 'Notes', value: location.Notes, weight: 1.5 },
      { field: 'Website', value: location.Website, weight: 1.3 },
      { field: 'ContactEmail', value: location.ContactEmail, weight: 1.3 },
      { field: 'ContactPhone', value: location.ContactPhone, weight: 1.3 }
    ];
    
    fieldsToCheck.forEach(({ field, value, weight }) => {
      if (value) {
        const valueStr = String(value).toLowerCase();
        
        // Exact match gets highest priority
        if (valueStr.includes(searchTerm)) {
          const score = 0 * weight; // Perfect match
          if (score < bestScore) {
            bestScore = score;
            matchField = field;
          }
        } else {
          // Fuzzy match
          const score = levenshteinDistance(searchTerm, valueStr) * weight;
          if (score < bestScore && score <= searchTerm.length * 2) { // Threshold for relevance
            bestScore = score;
            matchField = field;
          }
        }
      }
    });
    
    // Add to results if we found a match
    if (bestScore < Infinity && bestScore <= searchTerm.length * 2) {
      searchResults.push({
        type: 'location',
        data: location,
        score: bestScore,
        matchField: matchField
      });
    }
  });
  
  // Search religious people
  window.religious.forEach(person => {
    let bestScore = Infinity;
    let matchField = '';
    
    // Check various fields for matches
    const fieldsToCheck = [
      { field: 'Name', value: person.Name, weight: 1 },
      { field: 'Type', value: person.Type, weight: 1.2 },
      { field: 'Location/Area', value: person['Location/Area'], weight: 1.5 },
      { field: 'Notes', value: person.Notes, weight: 1.5 },
      { field: 'Website', value: person.Website, weight: 1.3 },
      { field: 'Email', value: person.Email, weight: 1.3 },
      { field: 'Phone', value: person.Phone, weight: 1.3 },
      { field: 'AssociatesWith', value: person.AssociatesWith, weight: 1.4 },
      { field: 'Beliefs', value: person.Beliefs, weight: 1.4 }
    ];
    
    fieldsToCheck.forEach(({ field, value, weight }) => {
      if (value) {
        const valueStr = String(value).toLowerCase();
        
        // Exact match gets highest priority
        if (valueStr.includes(searchTerm)) {
          const score = 0 * weight; // Perfect match
          if (score < bestScore) {
            bestScore = score;
            matchField = field;
          }
        } else {
          // Fuzzy match
          const score = levenshteinDistance(searchTerm, valueStr) * weight;
          if (score < bestScore && score <= searchTerm.length * 2) { // Threshold for relevance
            bestScore = score;
            matchField = field;
          }
        }
      }
    });
    
    // Add to results if we found a match
    if (bestScore < Infinity && bestScore <= searchTerm.length * 2) {
      searchResults.push({
        type: 'religious',
        data: person,
        score: bestScore,
        matchField: matchField
      });
    }
  });
  
  // Sort results by score
  searchResults.sort((a, b) => a.score - b.score);
  
  // Find connected entities
  const connectedResults = [];
  searchResults.forEach(result => {
    if (result.type === 'location') {
      // Find priests connected to this location
      const location = result.data;
      if (location.ReligiousIdArray && location.ReligiousIdArray.length > 0) {
        location.ReligiousIdArray.forEach(religiousId => {
          const person = window.religiousMap.get(religiousId);
          if (person && !searchResults.some(r => r.type === 'religious' && r.data.ReligiousID === religiousId)) {
            connectedResults.push({
              type: 'religious',
              data: person,
              score: result.score + 0.1,
              matchField: `Connected to ${location.Name}`,
              connected: true
            });
          }
        });
      }
    } else if (result.type === 'religious') {
      // Find locations connected to this priest
      const person = result.data;
      window.locations.forEach(location => {
        if (location.ReligiousIdArray && 
            location.ReligiousIdArray.includes(person.ReligiousID) &&
            !searchResults.some(r => r.type === 'location' && r.data.LocationID === location.LocationID)) {
          connectedResults.push({
            type: 'location',
            data: location,
            score: result.score + 0.1,
            matchField: `Connected to ${person.Name}`,
            connected: true
          });
        }
      });
    }
  });
  
  // Add connected results and re-sort
  return [...searchResults, ...connectedResults].sort((a, b) => a.score - b.score);
}


// Handle search input function
function handleSearch(event) {
  const searchTerm = event.target.value.toLowerCase();
  const searchResultsContainer = document.getElementById('searchResults');
  const outboundLinks = document.querySelector('.links');
  
  // Reset search results
  searchResultsContainer.innerHTML = '';
  
  // Always ensure only one is shown
  if (searchTerm.length < 2) {
    searchResultsContainer.style.display = 'none';
    outboundLinks.style.display = 'flex'; // Show links when no search
    resetAllMarkers();
    return;
  }
  
  // Hide outbound links when showing search results
  outboundLinks.style.display = 'none';
  
  // Get search results
  const searchResults = getSearchResults(searchTerm);
  
  // Display search results
  if (searchResults.length > 0) {
    // Create result items in the UI without highlighting markers during search
    searchResults.forEach(result => {
      const resultItem = document.createElement('div');
      resultItem.className = 'search-result-item';
      
      let label = '';
      if (result.type === 'religious') {
        const person = result.data;
        // Use proper translated title
        const translatedType = getTranslatedReligiousType(person.Type);
        label = `${translatedType} ${person.Name || ''}`;
      } else {
        label = result.data.Name || 'Location';
      }
      
      // Add matched field indicator for non-connected results
      if (!result.connected) {
        resultItem.innerHTML = `<strong>${label}</strong>`;
        if (result.matchField) {
          const fieldDisplay = result.matchField.startsWith('Connected to') 
            ? result.matchField 
            : `Match in: ${result.matchField}`;
          resultItem.innerHTML += `<br><small>${fieldDisplay}</small>`;
        }
      } else {
        // Connected items are shown differently
        resultItem.innerHTML = `<strong>${label}</strong><br><small>${result.matchField}</small>`;
        resultItem.classList.add('connected');
      }
      
      resultItem.tabIndex = 0;
      
      resultItem.addEventListener('click', () => {
        if (result.type === 'religious') {
          showPriestInfo(result.data);
        } else {
          showLocationInfo(result.data);
        }
        
        // Clear search
        document.getElementById('searchInput').value = '';
        searchResultsContainer.style.display = 'none';
        outboundLinks.style.display = 'flex'; // Show outbound links again
      });
      
      searchResultsContainer.appendChild(resultItem);
    });
    
    searchResultsContainer.style.display = 'flex';
  } else {
    searchResultsContainer.style.display = 'none';
    outboundLinks.style.display = 'flex'; // Show outbound links again
  }
}

    // Try to get user's location
    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          // Success
          (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            
            // Center map on user's location
            map.setView([lat, lng], 8);
            
            // Add a marker for user's location
            addUserLocationMarker(lat, lng);
          },
          // Error
          (error) => {
            console.warn(`Geolocation error: ${error.message}`);
            // Use approximate location
            getApproximateLocation();
          },
          // Options
          {
            timeout: 5000,  // Wait just 5 seconds for the geolocation
            maximumAge: 0   // Don't use a cached position
          }
        );
      } else {
        console.warn("Geolocation not supported by this browser");
        // Use approximate location
        getApproximateLocation();
      }
    }

    // Add a marker for the user's location
    function addUserLocationMarker(lat, lng) {
      // Remove existing marker if any
      if (userLocationMarker) {
        map.removeLayer(userLocationMarker);
      }
      
      // Create a blue user location marker
      const userIcon = L.divIcon({
        className: 'user-marker',
        html: `<div style="width:12px; height:12px; background-color: blue; border-radius: 50%; border: 2px solid white;"></div>`,
        iconSize: [12, 12],
        iconAnchor: [6, 6]
      });
      
      userLocationMarker = L.marker([lat, lng], { icon: userIcon })
        .addTo(map)
        .bindPopup("$$your-location$$");
      }

    // Get approximate location based on timezone and language
    function getApproximateLocation() {
      // Get timezone offset
      const timezoneOffsetMinutes = new Date().getTimezoneOffset();
      const timezoneOffsetHours = -timezoneOffsetMinutes / 60;
      
      // Approximate longitude based on timezone
      const approximateLongitude = timezoneOffsetHours * 15;
      
      // Approximate latitude based on language
      const approximateLatitude = estimateLatitude(approximateLongitude);
            
      // Center map and add marker
      map.setView([approximateLatitude, approximateLongitude], 5);
      addUserLocationMarker(approximateLatitude, approximateLongitude);
    }

    // Estimate latitude based on language and longitude
    function estimateLatitude(longitude) {
      // Language-based latitude map
      const languageLatitudeMap = {
        "de": 51.0, // Germany
        "en": 51.0, // UK
        "fr": 46.0, // France
        "es": 40.0, // Spain
        "it": 42.0, // Italy
        "pl": 52.0, // Poland
        "ro": 46.0, // Romania
        "ru": 55.0, // Russia
        "tr": 39.0, // Turkey
        "el": 38.0, // Greece
        "ar": 25.0, // Arabian Peninsula
        "tl": 14.0, // Philippines
        "zh": 35.0, // China
        "ko": 37.5, // Korea
        "ja": 36.0, // Japan
        "pt": -15.0 // Brazil
      };
      
      // Longitude ranges for adjusting latitude
      const longitudeRanges = {
        "en": [
          { min: -170, max: -30, lat: 40.0 },    // North America
          { min: -10, max: 2, lat: 51.0 },       // UK
          { min: 65, max: 90, lat: 20.0 },       // South Asia
          { min: 110, max: 155, lat: -25.0 }     // Australia/NZ
        ],
        "es": [
          { min: -120, max: -30, lat: 15.0 },    // Latin America
          { min: -10, max: 5, lat: 40.0 }        // Spain
        ],
        "pt": [
          { min: -75, max: -30, lat: -15.0 },    // Brazil
          { min: -10, max: 0, lat: 39.0 }        // Portugal
        ]
      };
      
      // If we have longitude range data for this language, check it
      if (longitudeRanges[CONFIG.currentLanguage]) {
        for (const range of longitudeRanges[CONFIG.currentLanguage]) {
          if (longitude >= range.min && longitude <= range.max) {
            return range.lat;
          }
        }
      }
      
      // Otherwise use the general language map
      if (languageLatitudeMap[CONFIG.currentLanguage]) {
        return languageLatitudeMap[CONFIG.currentLanguage];
      }
      
      // Regional fallback based on longitude
      if (longitude > 10 && longitude < 40) {
        return 50.0; // Eastern Europe
      } else if (longitude >= 40 && longitude < 60) {
        return 55.0; // Western Russia
      } else if (longitude >= 60 && longitude < 90) {
        return 45.0; // Central Asia
      } else if (longitude >= 90 && longitude < 120) {
        return 35.0; // East Asia
      } else if (longitude >= 120 && longitude < 150) {
        return 35.0; // Far East Asia
      } else if (longitude > -10 && longitude <= 10) {
        return 48.0; // Western Europe
      } else if (longitude > -60 && longitude <= -10) {
        return 45.0; // Atlantic/Western Europe
      } else if (longitude > -120 && longitude <= -60) {
        return 35.0; // Americas
      }
      
      // Default fallback
      return 20.0;
    }
  </script>
</body>
</html>