<!DOCTYPE html>
<html lang="$$LANG$$">
<head>
  <title>$$resistance-title$$</title>
  <meta name="description" content="$$resistance-desc$$">
  <link rel="alternate" hreflang="en" href="$$ROOT_HREF$$/en/resistance.html">
  <link rel="alternate" hreflang="de" href="$$ROOT_HREF$$/de/resistance.html">
  <link rel="alternate" hreflang="fr" href="$$ROOT_HREF$$/fr/resistance.html">
  <link rel="alternate" hreflang="es" href="$$ROOT_HREF$$/es/resistance.html">
  <link rel="alternate" hreflang="it" href="$$ROOT_HREF$$/it/resistance.html">
  <link rel="alternate" hreflang="pt" href="$$ROOT_HREF$$/pt/resistance.html">
  <link rel="alternate" hreflang="x-default" href="$$ROOT_HREF$$/en/resistance.html">
  <meta charset="UTF-8">
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <meta name="theme-color" content="#fff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#161616" media="(prefers-color-scheme: dark)">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-RegularItalic.woff2" as="font" type="font/woff2">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-Regular.woff2" as="font" type="font/woff2">
  <link crossorigin="anonymous" rel="preload" href="/static/font/ssfp/SourceSerifPro-BASIC-Semibold.woff2" as="font" type="font/woff2">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin=""/>
  
  <!-- FontAwesome for icons -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/all.min.css">
  
  <style>
    :root {
      --background-color: #f5f5f5;
      --text-color: #333;
      --panel-bg: rgba(255, 255, 255, 0.95);
      --panel-text: #333;
      --atmospheric-color: #ccc;
      --search-bg: white;
      --search-text: #333;
      --search-placeholder: #999;
      --search-results-bg: white;
      --search-results-hover: #f0f0f0;
      --link-color: #8b0000;
      --focus-col: rgb(61, 99, 170);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --background-color: #121212;
        --text-color: #f5f5f5;
        --panel-bg: rgba(33, 33, 33, 0.95);
        --panel-text: #f5f5f5;
        --atmospheric-color: #3a228a;
        --search-bg: #333;
        --search-text: #f5f5f5;
        --search-placeholder: #777;
        --search-results-bg: #333;
        --search-results-hover: #444;
        --link-color: #ff6b6b;
      }
    }
    
    * {
        margin: 0px;
        padding: 0px;
    }

    html {
        display: flex;
        justify-content: center;
        align-items: center;
        width: 100%;
        height: 100%;
    }

    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: var(--background-color);
      font-family: Arial, sans-serif;
      color: var(--text-color);
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      align-items: center;
      width: 100%;
      height: 100%;
    }
    
    #mapContainer {
        position: absolute;
        height: 100%;
        width: 100%;
        z-index: 1;
    }
    
    .search-container {
        display: flex;
        justify-content: space-between;
        flex-direction: column;
        z-index: 1000;
        flex-grow: 1;
        padding: 10px;
        padding-top: 0px;
        top: 80px;
        left: 10px;
    }

    #priestInfo {
        display: flex;
        flex-direction: column;
        margin-top: 10px;
    }

    .search-input {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        padding: 10px 5px;
        font-style: italic;
        border: none;
        background: var(--search-bg);
        color: var(--search-text);
        font-size: 1.2rem;
        outline: none;
        border: 3px solid var(--search-bg);
        pointer-events: all;
    }
    
    .search-input:focus {
        border: 3px solid var(--focus-col);
    }

    .search-input::placeholder {
      color: var(--search-placeholder);
    }
    
    .search-results {
        font-family: 'UnifrakturMaguntia';
        font-weight: bold;
        font-style: italic;
        overflow-y: scroll;
        background: var(--search-results-bg);
        border-radius: 0 0 5px 5px;
        z-index: 11;
        pointer-events: all;
        max-height: 200px;
        flex-direction: column;
        overflow-y: scroll;
    }
    
    .search-result-item {
      padding: 5px;
      cursor: pointer;
      transition: background-color 0.2s;
      border: 3px solid transparent;
      font-size: 1.2rem;
    }
    
    .search-result-item:focus {
        border: 3px solid var(--focus-col);
        background-color: var(--search-results-hover);
    }
    
    .search-result-item:hover {
      background-color: var(--search-results-hover);
    }

    .info-panel {
        margin-bottom: 10px;
        box-shadow: 2.5px 2.5px 5px black;
        pointer-events: all;
        position: relative;
        background: white;
        padding: 20px;
        max-height: 70vh;
        overflow-y: auto;
        z-index: 1000;
        display: none;
        flex-direction: column;
        flex-grow: 0;
        background: var(--panel-bg);
        color: var(--panel-text);
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        font-family: 'Times';
        font-style: italic;
        font-size: 1.2rem;
    }
    
    .info-panel h2 {
        margin-top: 0;
        font-size: 2rem;
        font-weight: bold;
    }
    
    .info-row {
        margin-bottom: 4px;
        display: flex;
        flex-direction: row;
        justify-content: space-between;
    }
    
    /* Add these styles to your existing CSS */
    .notes-section, .mass-times-section {
      padding-top: 8px;
    }

    .notes-section strong, .mass-times-section strong {
      display: inline;
      padding-right: 5px;
    }

    .notes-section p, .mass-times-section p {
      display: inline;
      margin-bottom: 8px;
      font-size: 1.1rem;
    }

    .mass-times-section {
      color: #8b0000;
      font-weight: 500;
    }

    @media (prefers-color-scheme: dark) {
      .notes-section, .mass-times-section {
        border-top: 1px solid rgba(255,255,255,0.1);
      }
      
      .mass-times-section {
        color: #ff6b6b;
      }
    }

    /* Make title more prominent */
    #priestName {
      font-family: 'UnifrakturMaguntia', serif;
      font-size: 2.5rem;
    }

    .close-btn {
        position: absolute;
        top: 20px;
        right: 20px;
        background: none;
        border: none;
        color: white;
        background: #cc0000;
        font-size: 2rem;
        width: 30px;
        height: 30px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }
    .info-link {
      background: #004970;
      color: white;
      font-weight: bold;
      text-decoration: underline;
    }
    .info-link.maps {
        background: #700000;
        color: white;
        padding: 10px;
        font-weight: bold;
        font-style: normal;
        font-family: sans-serif;
        margin-top: 1rem;
        text-decoration: none;
        display: block;
        text-align: center;
    }
    
    .info-link.maps:hover {
      text-decoration: underline;
    }

  .parishes-section h3 {
    margin-top: 0;
    font-size: 1.3rem;
  }

  .parishes-list {
    list-style-type: none;
    padding-left: 0;
    margin-top: 5px;
    max-height: 150px;
    overflow-y: scroll;
  }

  .parish-item {
    margin-bottom: 8px;
    line-height: 1.4;
  }

  @media (prefers-color-scheme: dark) {
    .parishes-section {
      border-top: 1px solid rgba(255,255,255,0.1);
    }
  }

  .priest-link {
      color: var(--link-color);
      text-decoration: underline;
      cursor: pointer;
      margin-top: 5px;
      display: inline-block;
    }
    
    .priest-link:hover {
      text-decoration: none;
    }
    
    .parish-item {
      cursor: pointer;
      transition: background-color 0.2s;
    }
    
    .parish-item strong {
      text-decoration: underline;
    }
    .parish-item:hover {
      background-color: rgba(128, 128, 128, 0.1);
      border-radius: 3px;
      padding-left: 5px;
    }

    .links {
      display: flex;
      flex-direction: row;
      z-index: 1000;
      padding: 10px 0px;
    }

    .outbound-link, .outbound-link:visited, .outbound-link:focus, .outbound-link:hover {
      color: white;
      font-size: 1rem;
      background-color: black;
      margin-right: 10px;
      padding: 5px;
      text-decoration: none;
      pointer-events: all;
    }

    @media (max-width: 800px) {
      .title {
        display: none;
      }
      
      .links {
        width: 100%;
        display: flex;
        flex-grow: 1;
      }
      .links > div {
        flex-direction: row;
        display: flex;
        flex-grow: 0;
      }
      .links > div > a {
        margin-top: 5px;
        flex-grow: 1;
        display: flex;
      }

      .info-panel {
        max-height: 60vh;
        font-size: 0.9rem;
      }
      #priestName {
        font-size: 1.4rem;
      }
      .search-input {
        font-size: 1.2rem;
      }
      .search-results, .search-result-item {
        font-size: 1.2rem;
      }
      .outbound-link, .outbound-link:visited, .outbound-link:focus, .outbound-link:hover {
        font-size: 1rem;
      }
      #priestInfo {
        font-size: 1rem;
      }
    }

    /* Import the same fonts as dubia.cc */
    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 400;
      font-style: normal;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-Regular.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 400;
      font-style: italic;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-RegularItalic.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Source Serif Pro';
      font-weight: 600;
      font-style: normal;
      src: url('/static/font/ssfp/SourceSerifPro-BASIC-Semibold.woff2') format('woff2');
      font-display: swap;
      unicode-range: U+0020-007E, U+00A0-00FF, U+2010, U+2013-2014, U+2018-2019, U+201C-201D, U+2212;
    }

    @font-face {
      font-family: 'Kanzlei Initialen';
      src: url('/static/font/kanzlei/Kanzlei-Initialen-D.ttf') format('truetype');
      font-display: swap;
      unicode-range: U+0044;
    }

    :root {
      --GW-serif-font-stack: "Source Serif Pro", "Apple Garamond", "Baskerville", "Libre Baskerville", "Droid Serif", "Times New Roman", "Times", serif;
      --GW-sans-serif-font-stack: "Lucida Sans Unicode", "Helvetica", "Trebuchet MS", sans-serif;
      --GW-monospaced-font-stack: "IBM Plex Mono", "Liberation Mono", "Consolas", "Courier", monospace;
    }

    /* Compact header styles */
    #header {
      display: flex;
      flex-direction: column;
      flex-grow: 1;
      justify-content: space-between;
      padding: 10px 0;
      max-width: 500px;
      min-width: 500px;
      z-index: 1000;
      height: 100%;
      position: absolute;
      pointer-events: none;
    }

    .title {
      font-family: 'UnifrakturMaguntia', serif;
      font-size: 2.5rem;
      color: var(--background-color);
      text-align: center;
      background: var(--text-color);
      mix-blend-mode: difference;
      width: 100%;
      text-align: center;
      font-family: 'UnifrakturMaguntia', serif;
      z-index: 1000;
      padding: 10px 0px;
      margin-bottom: 10px;
    }

    #sidebar {
      display: flex;
      justify-content: center;
      flex-direction: column;
      padding: 10px;
    }

    #sidebar a {
      display: block;
      border: 1px dotted currentColor;
      text-align: center;
      margin: 0 2px;
      color: var(--text-color);
      text-decoration: none;
      font-family: var(--GW-serif-font-stack);
    }

    #sidebar a.logo {
      display: flex;
      align-items: center;
      margin: 1px 0;
      background-color: var(--background-color);
    }

    #sidebar .sidebar-links {
      flex: 1 1 100%;
      display: flex;
      flex-flow: row wrap;
      pointer-events: initial;
    }

    #sidebar .sidebar-links > a {
        pointer-events: initial;
    }

    #sidebar .sidebar-links > * {
      font-variant-caps: small-caps;
      background: var(--background-color);
      align-content: center;
      justify-content: center;
      flex: 1;
      padding: 5px;
      pointer-events: initial;
      cursor: pointer;
    }

    /* Make the header more compact on mobile */
    @media all and (max-width: 649px) {
      .title {
        font-size: 1.8rem;
      }
      
      #sidebar .sidebar-links a {
        padding: 3px 5px;
        font-size: 0.9rem;
      }
    }

    /* Map-specific styles */
    .leaflet-popup-content {
      font-family: 'Source Serif Pro', serif;
      font-size: 1rem;
    }
    
    .priest-marker {
      background-color: #cc0000;
      border-radius: 50%;
      border: 2px solid white;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    
    .parish-marker {
      background-color: #003399;
      border-radius: 50%;
      border: 2px solid white;
      text-align: center;
      box-shadow: 0 0 10px rgba(0,0,0,0.5);
    }
    
    /* For the pulsing effect */
    .pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% {
        box-shadow: 0 0 0 0 rgba(204, 0, 0, 0.7);
      }
      70% {
        box-shadow: 0 0 0 10px rgba(204, 0, 0, 0);
      }
      100% {
        box-shadow: 0 0 0 0 rgba(204, 0, 0, 0);
      }
    }

    /* For dark mode maps */
    .dark-map .leaflet-tile {
      filter: brightness(0.6) invert(1) contrast(3) hue-rotate(200deg) saturate(0.3) brightness(0.7);
    }
    
    .dark-map .leaflet-container {
      background: #303030;
    }
    
    @font-face {
      font-family: 'UnifrakturMaguntia';
      font-style: normal;
      font-weight: 400;
      src: url('/static/font/unifraktur/UnifrakturMaguntia-Regular.ttf') format('ttf');
      unicode-range: U+0000-00FF, U+0131, U+0152-0153, U+02BB-02BC, U+02C6, U+02DA, U+02DC, U+0304, U+0308, U+0329, U+2000-206F, U+2074, U+20AC, U+2122, U+2191, U+2193, U+2212, U+2215, U+FEFF, U+FFFD;
      font-display: swap;
    }

        .calendar-btn {
      background: #437700;
      color: white;
      padding: 10px;
      font-weight: bold;
      font-style: normal;
      font-family: sans-serif;
      margin-top: 0.5rem;
      text-decoration: none;
      display: block;
      text-align: center;
      cursor: pointer;
    }

    .calendar-btn:hover {
      background: #5a9900;
    }

    .calendar-popup {
      position: absolute;
      flex-grow: 1;
      max-width: 440px;
      justify-content: center;
      background: var(--panel-bg);
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.5);
      z-index: 1000;
      padding: 20px;
      overflow-y: auto;
      flex-direction: column;
      display: none;
    }

    .calendar-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 15px;
    }

    .calendar-title {
      font-size: 1.5rem;
      font-weight: bold;
    }

    .calendar-close {
      background: #cc0000;
      color: var(--text-color);
      font-weight: bold;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
    }

    .calendar-nav {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
    }

    .calendar-nav button {
      background: none;
      border: none;
      font-size: 1.5rem;
      cursor: pointer;
      color: var(--text-color);
    }

    .calendar-month-year {
      font-size: 1.2rem;
      font-weight: bold;
    }

    .calendar-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 5px;
      margin-bottom: 15px;
    }

    .calendar-day-header {
      text-align: center;
      font-weight: bold;
      padding: 5px 0;
    }

    .calendar-day {
      text-align: center;
      padding: 10px 5px;
      border: 1px solid rgba(0, 0, 0, 0.1);
      position: relative;
      cursor: pointer;
    }

    .calendar-day:hover {
      background-color: rgba(0, 0, 0, 0.05);
    }

    .calendar-day.has-events::after {
      content: "";
      position: absolute;
      bottom: 5px;
      left: 50%;
      transform: translateX(-50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #1e88e5;
    }

    .calendar-day.other-month {
      color: rgba(128, 128, 128, 0.5);
    }

    .calendar-events {
      margin-top: 15px;
    }

    .calendar-event {
      margin-bottom: 10px;
      padding: 10px;
      border-radius: 5px;
      background-color: rgba(0, 0, 0, 0.05);
    }

    .calendar-event.cancelled {
      text-decoration: line-through;
      color: gray;
    }

    .calendar-event-title {
      font-weight: bold;
      margin-bottom: 5px;
    }

    .calendar-event-time {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .calendar-event-location {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .calendar-event-priest {
      font-size: 0.9rem;
      margin-bottom: 5px;
    }

    .calendar-event-notes {
      font-style: italic;
      font-size: 0.9rem;
    }

    .calendar-event-cancelled {
      color: #cc0000;
      font-weight: bold;
      font-size: 0.9rem;
      margin-top: 5px;
    }

    .donate-link {
      background: #cc7700;
      color: white;
      padding: 5px 10px;
      border-radius: 5px;
      text-decoration: none;
      font-size: 0.9rem;
      display: inline-block;
      margin-top: 5px;
    }

    .donate-link:hover {
      background: #ff9900;
    }

    .show-more-btn {
      background: #004970;
      color: white;
      padding: 10px;
      font-weight: bold;
      font-style: normal;
      font-family: sans-serif;
      margin-top: 0.5rem;
      text-decoration: none;
      display: block;
      text-align: center;
      cursor: pointer;
    }

    .show-more-btn:hover {
      background: #006699;
    }

  </style>
</head>
<body>

  <header id="header">
    <nav id="sidebar">
      <h1 class="title">$$resistance-title$$</h1>
      <div class="sidebar-links">
        <a href="/$$LANG$$">$$nav-home$$</a>
        <a href="/$$LANG$$/$$special-topics-path$$">$$nav-articles$$</a>
        <a href="/$$LANG$$/$$special-tools-path$$">$$nav-tools$$</a>
        <a href="/$$LANG$$/$$special-about-path$$">$$nav-contact$$</a>
      </div>
    </nav>

    <div class="search-container">
      <div style="display: flex; flex-direction: column;">
        <input autofocus="true" type="text" class="search-input" placeholder="$$search-placeholder$$" id="searchInput">
        <div class="links">
          <a class="outbound-link" href="https://github.com/fschutt/dubiacc/issues">$$report-error$$</a>
          <a class="outbound-link" href="https://github.com/fschutt/dubiacc/issues">$$request-mass$$</a>
          <a style="color:white;" class="outbound-link" href="https://dubia.cc">$$back-to-site$$</a>
        </div>
        <div class="search-results" id="searchResults">
        </div>
      </div>

      <div class="info-panel" id="infoPanel">
          <button class="close-btn" id="closeBtn">×</button>
          <h2 id="priestName"></h2>
          <div id="priestInfo"></div>
        </div>
    </div>
  </header>
  
  <div id="mapContainer"></div>

  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>
  
  <!-- PapaParse for CSV processing -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
  
  <script>
    // Configuration
    const CONFIG = {
      // Default center of the map (will be overridden by geolocation if available)
      defaultLat: 48.8566,
      defaultLng: 2.3522,
      defaultZoom: 4,
      
      // Styling
      priestMarkerColor: '#cc0000',
      parishMarkerColor: '#003399',
      lineColor: '#8b0000',
      lineWeight: 2,
      lineOpacity: 0.7,
      
      // Marker sizes
      priestMarkerSize: 10,
      parishMarkerSize: 7,
      
      // Google Sheet ID
      sheetId: "16wO1gTdilEcdqsWfJ0mZn-hgYD2MRJ1SCKSAHzcDj18",
      
      // Current language
      currentLanguage: "$$LANG$$",
      
      // Min/max zoom for map controls
      minZoom: 2,
      maxZoom: 18,
    };
    
    // Data storage
    let locations = [];
    let religious = [];
    let events = [];
    let fundingData = [];
    let cancelledEvents = [];

    // Maps for quick lookup
    let locationMap = new Map();
    let religiousMap = new Map();
    let fundingMap = new Map();
    let cancelledEventsMap = new Map();

    // Map and layers
    let map;
    let priestMarkers = L.layerGroup();
    let parishMarkers = L.layerGroup();
    let connectionLines = L.layerGroup();
    let userLocationMarker = null;
    
    // Default data (fallback)
    const defaultLocationsData = `LocationID,LocationType,Name,ReligiousIdMulti,Location,Website,GoogleMaps,ContactEmail,ContactPhone,Notes
carmelites-hf-ireland,Convent,Carmelites of the Holy Face of Jesus,mother-irene sister-anne-marie,51.79025633971586 -9.112158704807591,https://carmelitesholyface.com/,https://maps.app.goo.gl/WaokWwYAmujka5Sr7,,,
hjm-seminary,Seminary,Hearts of Jesus and Mary Seminary,fr-chazal,10.342421706935285 123.83294807185935,https://www.facebook.com/mariancorpsofst.piusx,https://maps.app.goo.gl/o8xmm2b5eQgNXDpy6,mariancorpsinformation@gmail.com,639991680637,
discalced-carm-ph,Mission,Our Lady of Mt. Carmel Oratory,,14.185634883816563 121.23247682974647,https://discalcedcarmelites.org.ph/,https://maps.app.goo.gl/tXxyMGo6smjHdLW1A,,,"https://www.facebook.com/ScapularConfraternityPH/"
carmel-stjosef-ger,Convent,Karmel St. Josef,,48.1881613609616 12.668123403146767,https://archive.is/FOkbD,https://maps.app.goo.gl/6uYEqhqvvmJskU2q9,,4986719289190,"mittwochs und donnerstags von 10.45 Uhr – 11.15 Uhr"
mosteiro-santa-cruz,Convent,Mosteiro da Santa Cruz,bp-aquino,-22.188609036471846 -42.54923387378506,https://www.mosteirodasantacruz.org/,https://maps.app.goo.gl/fctDJNpysKvZGV7r9,mostsantacruz@gmail.com,552225401136,
sajm-seminary,Seminary,Séminaire Saint Louis Marie Grignion de Montfort,fr-picot,47.74520085682513 -0.41836116956105057,https://apotresdejesusetdemarie.fr/,https://maps.app.goo.gl/VEEQd6oNFp81vAa57,sajm.secretariat@gmail.com,330983597578,`;

const defaultReligiousData = `ReligiousID,Type,Name,BornYear,AssociatesWith,UsualLocationID,Beliefs,Country,Website,OrdainedInRite,OrdainedBy,ConsecratedInRite,ConsecratedBy,BishopLine,Notes
bp-williamson,Bishop,Richard Williamson,1940,SSPX (originally),,Resistance,England,,Old Rite,Archbishop Lefebvre,Old Rite,Archbishop Lefebvre,Lefebvre,"Consecrated in 1988 by Archbishop Lefebvre; leads \"SSPX Resistance\""
bp-zendejas,Bishop,Gerardo Zendejas,1961,Resistance,,Non-sede,USA,https://thebluepaper.org/,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated bishop on May 11 2017 by Bp. Williamson
bp-faure,Bishop,Jean-Michel Faure,1941,Resistance,,Non-sede,France,,Old Rite,Archbishop Lefebvre,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2015 by Bp. Williamson in Brazil
bp-aquino,Bishop,Tomas de Aquino,1954,Resistance,mosteiro-santa-cruz,Non-sede,Brazil,,Old Rite,,Old Rite,Bp. R. Williamson,Lefebvre,Consecrated in 2016 by Bp. Williamson
mother-irene,Mother,Mother Irene,1983,Carmelites of the Holy Face,carmelites-hf-ireland,Non-sede,Ireland,,,,,,,
fr-chazal,Father,François Chazal,1968,Marian Corps,hjm-seminary,Non-sede,Philippines,,,,,,,
fr-picot,Priest,Rémi Picot,,SAJM,sajm-seminary,NonSede,France,,OldRite,Williamson,,,Lefebvre,"Fr. Picot serves Alsace & region"`;

const defaultEventsData = `EventID,LocationID,ReligiousID,EventType,StartDate,EndDate,Notes
mass-1,carmelites-hf-ireland,mother-irene,Mass,2023-11-26T07:30:00,2023-11-26T08:30:00,Sunday Mass
mass-2,hjm-seminary,fr-chazal,Mass,2023-11-26T10:00:00,2023-11-26T11:30:00,Sunday High Mass
sajm-alsace-1,sajm-seminary,fr-picot,Mass,2023-11-26T09:30:00,2023-11-26T10:30:00,Regular Mass in Alsace`;

const defaultCancelledEventsData = `AffectsEventID,DateStart,TimeStart,DateEnd,TimeEnd,Reason
sajm-alsace-1,2023-11-05,10:00:00,2023-11-05,11:00:00,Mass cancelled because Fr. Picot is sick`;

const defaultFundingData = `CampaignID,ReligiousOrLocationOrEventID,FundingType,FundingGoal,FundingCurrency,CurrentAmount,DonationLinks,Notes
discalced-carm-ongoing,discalced-carm-ph,BuildParish,5177,USD,750,paypal.me/StJosephCarmel,
fr-hewko-ongoing,fr-hewko,FundAPriest,2000,EUR,200,paypal.me/frhewko,
fr-picot-ongoing,fr-picot,FundAPriest,1000,EUR,500,paypal.me/remi-picot,
sajm-building-fund,sajm-seminary,BuildParish,50000,EUR,12500,paypal.me/sajmseminary,Seminary building renovation`;

    // Initialize map when DOM is loaded
    document.addEventListener('DOMContentLoaded', init);

    // Initialize the application
    function init() {
      // Create map
      map = L.map('mapContainer', {
        minZoom: CONFIG.minZoom,
        maxZoom: CONFIG.maxZoom,
        zoomControl: 'bottom-right' // Disable default zoom control to use custom ones
      }).setView([CONFIG.defaultLat, CONFIG.defaultLng], CONFIG.defaultZoom);
      
      // Add OSM tile layer
      L.tileLayer('https://tiles.stadiamaps.com/tiles/osm_bright/{z}/{x}/{y}{r}.png', {
        attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        maxZoom: 19
      }).addTo(map);
      
      // Add layer groups to map
      connectionLines.addTo(map);
      parishMarkers.addTo(map);
      priestMarkers.addTo(map);
      
      // Set up event listeners
      setupEventListeners();
      
      // Load data (first from fallback, then from Google Sheets)
      loadData();
      
      // Try to get user's location
      getUserLocation();
    }

    // Set up event listeners
    function setupEventListeners() {
      // Search input
      const searchInput = document.getElementById('searchInput');
      const searchResults = document.getElementById('searchResults');
      
      searchInput.addEventListener('input', handleSearch);
      
      searchInput.addEventListener('focus', () => {
        if (searchResults.children.length > 0) {
          searchResults.style.display = 'flex';
        }
      });
      
      // Close button
      document.getElementById('closeBtn').addEventListener('click', () => {
        document.getElementById('infoPanel').style.display = 'none';
      });
      
      // Close search results when clicking outside
      document.addEventListener('click', (e) => {
        if (!searchInput.contains(e.target) && !searchResults.contains(e.target)) {
          searchResults.style.display = 'none';
        }
      });
      
      // Handle light/dark mode
      const prefersDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
      if (prefersDarkMode) {
        map.getContainer().classList.add('dark-map');
      }
      
      // Listen for theme changes
      window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
        if (e.matches) {
          map.getContainer().classList.add('dark-map');
        } else {
          map.getContainer().classList.remove('dark-map');
        }
      });
    }

    // Load data from fallback and Google Sheets
    function loadData() {
      // First load default data
      console.log("Loading default data...");
      parseLocationsData(defaultLocationsData);
      parseReligiousData(defaultReligiousData);
      parseEventsData(defaultEventsData);
      parseCancelledEventsData(defaultCancelledEventsData);
      parseFundingData(defaultFundingData);

      // Then try to fetch from the live DB
      fetchSheetData();
    }

    // Parse locations CSV data
    function parseLocationsData(csvData) {
  Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true,
    transformHeader: function(header) {
      // Extract column name from headers that might contain values
      return header.split(" ")[0].replace(/"/g, '');
    },
    complete: function(results) {
      // Process locations
      locations = results.data.map(location => {
        // First, fix any mangled values in the first row
        Object.keys(location).forEach(key => {
          // If the original header had value in it (like "LocationID carmelites-hf-ireland")
          // Extract and properly set the value
          const originalHeader = csvData.split('\n')[0].split(',').find(h => h.startsWith('"' + key));
          if (originalHeader && originalHeader.includes(' ')) {
            const headerParts = originalHeader.split(' ');
            headerParts.shift(); // Remove the first part (column name)
            const value = headerParts.join(' ').replace(/"/g, '');
            if (value && location[key] === "") {
              location[key] = value;
            }
          }
        });
        
        // Fix location parsing (handling both comma and space separated coordinates)
        let lat = 0, lng = 0;
        if (location.Location) {
          const coordMatch = location.Location.match(/(-?\d+\.?\d*)[,\s]+(-?\d+\.?\d*)/);
          if (coordMatch) {
            lat = parseFloat(coordMatch[1]);
            lng = parseFloat(coordMatch[2]);
          }
        }
        
        return {
          ...location,
          Latitude: lat,
          Longitude: lng,
          // Convert ReligiousIdMulti to array (handling both comma and space separated values)
          ReligiousIdArray: location.ReligiousIdMulti ? 
            location.ReligiousIdMulti.split(/[,\s]+/).filter(id => id.trim() !== "") : []
        };
      });
      
      // Update location map
      locationMap.clear();
      locations.forEach(location => {
        locationMap.set(location.LocationID, location);
      });
      
      // Update markers
      updateMapMarkers();
    }
  });
}

    // Parse religious CSV data
    function parseReligiousData(csvData) {
  Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true,
    transformHeader: function(header) {
      // Extract column name from headers that might contain values
      return header.split(" ")[0].replace(/"/g, '');
    },
    complete: function(results) {
      // Process religious data
      religious = results.data.map(person => {
        // Fix any mangled values in the first row
        Object.keys(person).forEach(key => {
          const originalHeader = csvData.split('\n')[0].split(',').find(h => h.startsWith('"' + key));
          if (originalHeader && originalHeader.includes(' ')) {
            const headerParts = originalHeader.split(' ');
            headerParts.shift(); // Remove column name
            const value = headerParts.join(' ').replace(/"/g, '');
            if (value && person[key] === "") {
              person[key] = value;
            }
          }
        });
        
        return person;
      });
      
      // Update religious map
      religiousMap.clear();
      religious.forEach(person => {
        religiousMap.set(person.ReligiousID, person);
      });
      
      // Update markers
      updateMapMarkers();
    }
  });
}


    // Parse events CSV data
    function parseEventsData(csvData) {
  Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true,
    transformHeader: function(header) {
      return header.split(" ")[0].replace(/"/g, '');
    },
    complete: function(results) {
      // Process events data
      events = results.data;
      
      // Update markers
      updateMapMarkers();
    }
  });
}

function parseCancelledEventsData(csvData) {
  Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true,
    transformHeader: function(header) {
      return header.split(" ")[0].replace(/"/g, '');
    },
    complete: function(results) {
      // Process cancelled events data
      cancelledEvents = results.data;
      
      // Create lookup map for faster access
      cancelledEventsMap.clear();
      cancelledEvents.forEach(cancelled => {
        // Use eventID as key
        const key = cancelled.AffectsEventID;
        if (!cancelledEventsMap.has(key)) {
          cancelledEventsMap.set(key, []);
        }
        cancelledEventsMap.get(key).push(cancelled);
      });
    }
  });
}

function parseFundingData(csvData) {
  Papa.parse(csvData, {
    header: true,
    skipEmptyLines: true,
    transformHeader: function(header) {
      return header.split(" ")[0].replace(/"/g, '');
    },
    complete: function(results) {
      // Process funding data
      fundingData = results.data;
      
      // Create lookup map for faster access
      fundingMap.clear();
      fundingData.forEach(funding => {
        fundingMap.set(funding.ReligiousOrLocationOrEventID, funding);
      });
    }
  });
}

    // Fetch data from Google Sheets
    function fetchSheetData() {
      const sheetId = CONFIG.sheetId;
      const sheets = ["locations", "religious", "events", "cancelled-events", "funding"];
      
      sheets.forEach(sheet => {
        const encodedSheetName = encodeURIComponent(sheet);
        const googleSheetUrl = `https://docs.google.com/spreadsheets/d/${sheetId}/gviz/tq?tqx=out:csv&sheet=${encodedSheetName}&query=rows`;
        const corsProxyUrl = `https://corsproxy.io/?${encodeURIComponent(googleSheetUrl)}`;
        
        fetch(corsProxyUrl)
          .then(response => {
            if (!response.ok) {
              throw new Error(`Failed to fetch ${sheet} data: ${response.status}`);
            }
            return response.text();
          })
          .then(csvText => {
            // Parse CSV based on sheet type
            if (sheet === "locations") {
              parseLocationsData(csvText);
            } else if (sheet === "religious") {
              parseReligiousData(csvText);
            } else if (sheet === "events") {
              parseEventsData(csvText);
            } else if (sheet === "cancelled-events") {
              parseCancelledEventsData(csvText);
            } else if (sheet === "funding") {
              parseFundingData(csvText);
            }
          })
          .catch(error => {
            console.error(`Error loading ${sheet} data:`, error);
            console.log(`Using fallback data for ${sheet}`);
          });
      });
    }

    // Update map markers
    function updateMapMarkers() {
      // Clear existing markers and lines
      priestMarkers.clearLayers();
      parishMarkers.clearLayers();
      connectionLines.clearLayers();
      
      // Process locations
      locations.forEach(location => {
        // Create parish marker
        createParishMarker(location);
        
        // Create connection lines between religious and their locations
        createConnectionLines(location);
      });
      
      // Process religious who don't have an assigned location
      religious.forEach(person => {
        const hasLocation = locations.some(location => 
          location.ReligiousIdArray.includes(person.ReligiousID)
        );
        
        if (!hasLocation && person['Location/Area']) {
          // Extract coordinates from Location field if available
          const geoMatch = person['Location/Area']?.match(/(-?\d+\.\d+)[,\s]+(-?\d+\.\d+)/);
          if (geoMatch) {
            const lat = parseFloat(geoMatch[1]);
            const lng = parseFloat(geoMatch[2]);
            
            if (!isNaN(lat) && !isNaN(lng)) {
              createPriestMarker(person, lat, lng);
            }
          } else {
            // Use location approximation based on country/area
            const coords = approximateLocationFromName(person['Location/Area']);
            if (coords) {
              createPriestMarker(person, coords.lat, coords.lng);
            }
          }
        }
      });
    }

    // Create parish marker
    function createParishMarker(location) {
      if (!location.Latitude || !location.Longitude || 
          isNaN(location.Latitude) || isNaN(location.Longitude)) {
        console.warn(`Invalid coordinates for location: ${location.Name}`);
        return;
      }
      
      // Create marker
      const markerSize = CONFIG.parishMarkerSize;
      const icon = L.divIcon({
        className: 'parish-marker',
        html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
        iconSize: [markerSize, markerSize],
        iconAnchor: [markerSize/2, markerSize/2]
      });
      
      const marker = L.marker([location.Latitude, location.Longitude], { icon })
        .addTo(parishMarkers);
      
      // Store location data with marker
      marker.locationData = location;
      
      // Add popup with basic info
      marker.bindPopup(`<strong>${location.Name}</strong><br>${location.LocationType}`);
      
      // Add click handler
      marker.on('click', function() {
        showLocationInfo(location);
      });
      
      return marker;
    }

    // Create priest marker
    function createPriestMarker(priest, lat, lng) {
      // Create marker
      const markerSize = CONFIG.priestMarkerSize;
      const icon = L.divIcon({
        className: 'priest-marker pulse',
        html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
        iconSize: [markerSize, markerSize],
        iconAnchor: [markerSize/2, markerSize/2]
      });
      
      const marker = L.marker([lat, lng], { icon })
        .addTo(priestMarkers);
      
      // Store priest data with marker
      marker.priestData = priest;
      
      // Add popup with basic info
      marker.bindPopup(`<strong>${priest.Type} ${priest.Name}</strong>`);
      
      // Add click handler
      marker.on('click', function() {
        showPriestInfo(priest);
      });
      
      return marker;
    }

    // Create connection lines between religious and their locations
    function createConnectionLines(location) {
      if (!location.ReligiousIdArray || !location.Latitude || !location.Longitude) {
        return;
      }
      
      // For each religious person associated with this location
      location.ReligiousIdArray.forEach(religiousId => {
        const person = religiousMap.get(religiousId);
        if (!person) return;
        
        // Find all other locations for this religious person
        locations.forEach(otherLocation => {
          if (otherLocation.LocationID === location.LocationID) return; // Skip self
          
          if (otherLocation.ReligiousIdArray.includes(religiousId)) {
            // Create a line between locations
            const latlngs = [
              [location.Latitude, location.Longitude],
              [otherLocation.Latitude, otherLocation.Longitude]
            ];
            
            const line = L.polyline(latlngs, {
              color: CONFIG.lineColor,
              weight: CONFIG.lineWeight,
              opacity: CONFIG.lineOpacity
            }).addTo(connectionLines);
            
            // Store data with the line
            line.religiousId = religiousId;
            line.fromLocation = location.LocationID;
            line.toLocation = otherLocation.LocationID;
          }
        });
        
        // Create priest marker at this location
        createPriestMarker(person, location.Latitude, location.Longitude);
      });
    }

    // Approximate location from country or region name
    function approximateLocationFromName(locationName) {
      if (!locationName) return null;
      
      const locationMap = {
        'England': { lat: 51.5074, lng: -0.1278 },
        'UK': { lat: 51.5074, lng: -0.1278 },
        'USA': { lat: 39.8283, lng: -98.5795 },
        'France': { lat: 46.2276, lng: 2.2137 },
        'Germany': { lat: 51.1657, lng: 10.4515 },
        'Italy': { lat: 41.8719, lng: 12.5674 },
        'Spain': { lat: 40.4637, lng: -3.7492 },
        'Poland': { lat: 51.9194, lng: 19.1451 },
        'Ireland': { lat: 53.1424, lng: -7.6921 },
        'Brazil': { lat: -14.2350, lng: -51.9253 },
        'Argentina': { lat: -38.4161, lng: -63.6167 },
        'Mexico': { lat: 23.6345, lng: -102.5528 },
        'Canada': { lat: 56.1304, lng: -106.3468 },
        'Australia': { lat: -25.2744, lng: 133.7751 },
        'New Zealand': { lat: -40.9006, lng: 174.8860 },
        'Philippines': { lat: 12.8797, lng: 121.7740 },
        'Austria': { lat: 47.5162, lng: 14.5501 },
        'Switzerland': { lat: 46.8182, lng: 8.2275 },
        'Belgium': { lat: 50.5039, lng: 4.4699 },
        'Netherlands': { lat: 52.1326, lng: 5.2913 },
        'Portugal': { lat: 39.3999, lng: -8.2245 },
        'Europe': { lat: 48.8566, lng: 9.3522 }
      };
      
      // Check for direct match
      for (const [key, coords] of Object.entries(locationMap)) {
        if (locationName.includes(key)) {
          return coords;
        }
      }
      
      // Add small random offset to default location to prevent markers from stacking
      return { 
        lat: CONFIG.defaultLat + (Math.random() * 2 - 1), 
        lng: CONFIG.defaultLng + (Math.random() * 2 - 1) 
      };
    }

    // Show location info in the panel
    function showLocationInfo(location) {
  const infoPanel = document.getElementById('infoPanel');
  const priestName = document.getElementById('priestName');
  const priestInfo = document.getElementById('priestInfo');
  
  // Set location name
  priestName.textContent = location.Name;
  
  // Clear previous info
  priestInfo.innerHTML = '';
  
  // Location type
  const typeParagraph = document.createElement('p');
  typeParagraph.className = 'info-paragraph';
  typeParagraph.textContent = `${location.LocationType}`;
  priestInfo.appendChild(typeParagraph);
  
  // Associated religious
  if (location.ReligiousIdArray && location.ReligiousIdArray.length > 0) {
    const religiousParagraph = document.createElement('p');
    religiousParagraph.className = 'info-paragraph';
    religiousParagraph.textContent = "$$served-by$$: ";
    
    // Add links for each religious person
    location.ReligiousIdArray.forEach((id, index) => {
      const person = religiousMap.get(id);
      if (person) {
        const priestLink = document.createElement('a');
        priestLink.className = 'priest-link';
        priestLink.textContent = `${person.Type} ${person.Name}`;
        priestLink.href = '#';
        priestLink.addEventListener('click', (e) => {
          e.preventDefault();
          showPriestInfo(person);
        });
        
        religiousParagraph.appendChild(priestLink);
        
        // Add comma if not the last person
        if (index < location.ReligiousIdArray.length - 1) {
          religiousParagraph.appendChild(document.createTextNode(', '));
        }
      }
    });
    
    priestInfo.appendChild(religiousParagraph);
  }
  
  // Notes
  if (location.Notes) {
    const notesSection = document.createElement('div');
    notesSection.className = 'notes-section';
    
    const notesTitle = document.createElement('strong');
    notesTitle.textContent = "$$notes$$";
    notesSection.appendChild(notesTitle);
    
    const notesContent = document.createElement('p');
    notesContent.textContent = location.Notes;
    notesSection.appendChild(notesContent);
    
    priestInfo.appendChild(notesSection);
  }
  
  // Contact information
  if (location.ContactEmail || location.ContactPhone) {
    const contactParagraph = document.createElement('p');
    contactParagraph.className = 'info-paragraph';
    
    if (location.ContactEmail) {
      contactParagraph.innerHTML += `Email: <a href="mailto:${location.ContactEmail}">${location.ContactEmail}</a><br>`;
    }
    
    if (location.ContactPhone) {
      contactParagraph.innerHTML += `Phone: ${location.ContactPhone}<br>`;
    }
    
    priestInfo.appendChild(contactParagraph);
  }
  
  // Website link
  if (location.Website) {
    const websiteParagraph = document.createElement('p');
    websiteParagraph.className = 'info-paragraph';
    
    // Format website URL for display
    let displayUrl = location.Website.replace(/^https?:\/\//, '');
    displayUrl = displayUrl.split('/')[0]; // Just show the domain
    
    websiteParagraph.innerHTML = `$$website$$: <a href="${location.Website}" target="_blank" class="info-link">${displayUrl}</a>`;
    priestInfo.appendChild(websiteParagraph);
  }
  
  // Upcoming events at this location
  const locationEvents = events.filter(event => event.LocationID === location.LocationID);
  if (locationEvents.length > 0) {
    const eventsSection = document.createElement('div');
    eventsSection.className = 'mass-times-section';
    
    const eventsTitle = document.createElement('strong');
    eventsTitle.textContent = "$$mass-times$$";
    eventsSection.appendChild(eventsTitle);
    
    const eventsList = document.createElement('ul');
    eventsList.className = 'events-list';
    
    // Sort events by date
    locationEvents.sort((a, b) => {
      return new Date(a.StartDate) - new Date(b.StartDate);
    });
    
    // Only show up to 3 upcoming events
    let upcomingCount = 0;
    const now = new Date();
    
    locationEvents.forEach(event => {
      if (upcomingCount >= 3) return;
      
      const startDate = new Date(event.StartDate);
      if (startDate < now) return; // Skip past events
      
      upcomingCount++;
      
      const eventItem = document.createElement('li');
      eventItem.className = 'event-item';
      
      // Check if event is cancelled
      const cancelled = isEventCancelled(event, startDate);
      if (cancelled) {
        eventItem.style.textDecoration = 'line-through';
        eventItem.style.color = 'gray';
      }
      
      // Format date and time
      const formattedDate = startDate.toLocaleDateString(CONFIG.currentLanguage);
      const formattedTime = startDate.toLocaleTimeString(CONFIG.currentLanguage, { hour: '2-digit', minute: '2-digit' });
      
      // Get priest name
      const priest = religiousMap.get(event.ReligiousID);
      const priestName = priest ? `${priest.Type} ${priest.Name}` : 'Unknown';
      
      eventItem.innerHTML = `<strong>${event.EventType}</strong>: ${formattedDate} ${formattedTime} - ${priestName}`;
      if (event.Notes) {
        eventItem.innerHTML += `<br><em>${event.Notes}</em>`;
      }
      
      // Add cancellation reason if cancelled
      if (cancelled) {
        const reason = getCancellationReason(event, startDate);
        if (reason) {
          eventItem.innerHTML += `<br><strong style="color: #cc0000;">${reason}</strong>`;
        }
      }
      
      eventsList.appendChild(eventItem);
    });
    
    eventsSection.appendChild(eventsList);
    priestInfo.appendChild(eventsSection);
    
    // Add "See All Events" button if there are more than 3 events
    if (locationEvents.length > 3) {
      const seeAllBtn = document.createElement('button');
      seeAllBtn.className = 'calendar-btn';
      seeAllBtn.textContent = "$$see-all-events$$";
      seeAllBtn.addEventListener('click', () => {
        showLocationCalendar(location);
      });
      eventsSection.appendChild(seeAllBtn);
    }
  }
  
  // Add Calendar button regardless of whether there are events now
  const calendarBtn = document.createElement('button');
  calendarBtn.className = 'calendar-btn';
  calendarBtn.textContent = "$$view-calendar$$";
  calendarBtn.addEventListener('click', () => {
    showLocationCalendar(location);
  });
  priestInfo.appendChild(calendarBtn);
  
  // Add Donate button if funding available
  const fundingInfo = getFundingInfo(location.LocationID);
  if (fundingInfo) {
    const donateBtn = document.createElement('a');
    donateBtn.className = 'calendar-btn';
    donateBtn.style.background = '#cc7700';
    donateBtn.href = fundingInfo.DonationLinks;
    donateBtn.target = '_blank';
    
    // Calculate funding percentage if available
    let donateText = '$$donate$$';
    if (fundingInfo.FundingGoal && fundingInfo.CurrentAmount) {
      const percentage = Math.round((fundingInfo.CurrentAmount / fundingInfo.FundingGoal) * 100);
      donateText += ` [${percentage}% $$funded$$]`;
    }
    
    donateBtn.textContent = donateText;
    priestInfo.appendChild(donateBtn);
  }
  
  // Add Google Maps link
  if (location.GoogleMaps) {
    const mapsRow = document.createElement('div');
    mapsRow.className = 'info-row';
    mapsRow.innerHTML = `<a href="${location.GoogleMaps}" target="_blank" class="info-link maps">$$view-on-maps$$</a>`;
    priestInfo.appendChild(mapsRow);
  } else if (location.Latitude && location.Longitude) {
    const mapsRow = document.createElement('div');
    mapsRow.className = 'info-row';
    const mapLink = `https://www.google.com/maps?q=${location.Latitude},${location.Longitude}`;
    mapsRow.innerHTML = `<a href="${mapLink}" target="_blank" class="info-link maps">$$view-on-maps$$</a>`;
    priestInfo.appendChild(mapsRow);
  }
  
  // Show the info panel
  infoPanel.style.display = 'flex';
  
  // Fly to location
  map.flyTo([location.Latitude, location.Longitude], 12, {
    animate: true,
    duration: 1.5
  });
  
  // Highlight this location and connected locations
  highlightLocation(location);
}

    // Show priest info in the panel
    function showPriestInfo(priest) {
  const infoPanel = document.getElementById('infoPanel');
  const priestName = document.getElementById('priestName');
  const priestInfo = document.getElementById('priestInfo');
  
  // Set priest name with title
  priestName.textContent = `${priest.Type} ${priest.Name}`;
  
  // Clear previous info
  priestInfo.innerHTML = '';
  
  // Create condensed info paragraph with essential info
  const essentialParagraph = document.createElement('p');
  essentialParagraph.className = 'info-paragraph';
  let essentialText = '';
  
  // Location and Association
  if (priest['Location/Area']) {
    essentialText += `$$operates-in$$ ${priest['Location/Area']}`;
  }
  
  // Associates With
  if (priest['AssociatesWith']) {
    if (essentialText) essentialText += ', ';
    essentialText += `$$associates-with$$ ${priest['AssociatesWith']}`;
  }
  
  // Beliefs
  if (priest['Beliefs']) {
    if (essentialText) essentialText += ', ';
    essentialText += `${priest['Beliefs']}`;
  }
  
  // Only add the paragraph if we have essential info
  if (essentialText) {
    essentialText += '.';
    essentialParagraph.textContent = essentialText;
    priestInfo.appendChild(essentialParagraph);
  }
  
  // Contact/Website as a clickable link if present
  if (priest['Website']) {
    const contactRow = document.createElement('p');
    contactRow.className = 'info-paragraph';
    
    let niceurl = priest['Website'].replace(/^https?:\/\//, "");
    contactRow.innerHTML = `$$website$$: <a href="${priest['Website']}" target="_blank" class="info-link">${niceurl}</a>`;
    
    priestInfo.appendChild(contactRow);
  }
  
  // "Show More" button to display detailed info
  const showMoreBtn = document.createElement('button');
  showMoreBtn.className = 'show-more-btn';
  showMoreBtn.textContent = "$$show-more-info$$";
  showMoreBtn.addEventListener('click', () => {
    // Create detailed bio text
    let bioText = `${priest.Type} ${priest.Name}\n\n`;
    
    // Born year
    if (priest['BornYear']) {
      bioText += `$$born$$ ${priest['BornYear']}\n`;
    }
    
    // Ordination info
    if (priest['OrdainedInRite'] || priest['OrdainedBy']) {
      bioText += `$$ordained-priest-in$$ `;
      if (priest['OrdainedInRite']) {
        bioText += priest['OrdainedInRite'] + ' ';
      }
      if (priest['OrdainedBy']) {
        bioText += `$$by$$ ${priest['OrdainedBy']}\n`;
      } else {
        bioText += '\n';
      }
    }
    
    // Consecration info (for bishops)
    if (priest.Type === "Bishop" && (priest['ConsecratedInRite'] || priest['ConsecratedBy'])) {
      bioText += `$$consecrated-bishop-in$$ `;
      if (priest['ConsecratedInRite']) {
        bioText += priest['ConsecratedInRite'] + ' ';
      }
      if (priest['ConsecratedBy']) {
        bioText += `$$by$$ ${priest['ConsecratedBy']} `;
      }
      
      // Bishop line
      if (priest['BishopLine']) {
        bioText += `($$bishop-line$$: ${priest['BishopLine']})\n`;
      } else {
        bioText += '\n';
      }
    }
    
    // Location
    if (priest['Location/Area']) {
      bioText += `$$operates-in$$ ${priest['Location/Area']}\n`;
    }
    
    // Associates With
    if (priest['AssociatesWith']) {
      bioText += `$$associates-with$$ ${priest['AssociatesWith']}\n`;
    }
    
    // Beliefs
    if (priest['Beliefs']) {
      bioText += `$$beliefs$$: ${priest['Beliefs']}\n`;
    }
    
    // Notes
    if (priest['Notes']) {
      bioText += `\n$$notes$$: ${priest['Notes']}\n`;
    }
    
    // Show in alert
    alert(bioText);
  });
  priestInfo.appendChild(showMoreBtn);
  
  // Add Calendar button
  const calendarBtn = document.createElement('button');
  calendarBtn.className = 'calendar-btn';
  calendarBtn.textContent = "$$view-calendar$$";
  calendarBtn.addEventListener('click', () => {
    showPriestCalendar(priest);
  });
  priestInfo.appendChild(calendarBtn);
  
  // Add Donate button if funding available
  const fundingInfo = getFundingInfo(priest.ReligiousID);
  if (fundingInfo) {
    const donateBtn = document.createElement('a');
    donateBtn.className = 'calendar-btn';
    donateBtn.style.background = '#cc7700';
    donateBtn.href = fundingInfo.DonationLinks;
    donateBtn.target = '_blank';
    
    // Calculate funding percentage if available
    let donateText = '$$donate$$';
    if (fundingInfo.FundingGoal && fundingInfo.CurrentAmount) {
      const percentage = Math.round((fundingInfo.CurrentAmount / fundingInfo.FundingGoal) * 100);
      donateText += ` [${percentage}% $$funded$$]`;
    }
    
    donateBtn.textContent = donateText;
    priestInfo.appendChild(donateBtn);
  }
  
  // Add locations served section
  const priestLocations = locations.filter(location => 
    location.ReligiousIdArray && location.ReligiousIdArray.includes(priest.ReligiousID)
  );
  
  if (priestLocations.length > 0) {
    const locationsSection = document.createElement('div');
    locationsSection.className = 'parishes-section';
    
    // Add section title
    const locationsTitle = document.createElement('h3');
    locationsTitle.textContent = "$$parishes-served$$";
    locationsSection.appendChild(locationsTitle);
    
    const locationsList = document.createElement('ul');
    locationsList.className = 'parishes-list';
    
    // Sort locations alphabetically
    priestLocations.sort((a, b) => a.Name.localeCompare(b.Name));
    
    priestLocations.forEach(location => {
      const locationItem = document.createElement('li');
      locationItem.className = 'parish-item';
      
      locationItem.innerHTML = `<strong>${location.Name}:</strong> ${location.LocationType}`;
      
      // Add click handler to highlight this location
      locationItem.style.cursor = 'pointer';
      locationItem.addEventListener('click', () => {
        showLocationInfo(location);
      });
      
      locationsList.appendChild(locationItem);
    });
    
    locationsSection.appendChild(locationsList);
    priestInfo.appendChild(locationsSection);
  }
  
  // Show the info panel
  infoPanel.style.display = 'flex';
  
  // Find primary location for this priest
  let primaryLocation = priestLocations[0];
  if (priestLocations.length > 0) {
    // Fly to location
    map.flyTo([primaryLocation.Latitude, primaryLocation.Longitude], 8, {
      animate: true,
      duration: 1.5
    });
  }
  
  // Highlight this priest's locations
  highlightPriest(priest);
}

    // Highlight location and its connections
    function highlightLocation(location) {
      // Reset all markers
      resetAllMarkers();
      
      // Highlight this location's marker
      parishMarkers.eachLayer(marker => {
        if (marker.locationData && marker.locationData.LocationID === location.LocationID) {
          // Create highlighted marker
          const markerSize = CONFIG.parishMarkerSize * 1.5;
          const icon = L.divIcon({
            className: 'parish-marker',
            html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
            iconSize: [markerSize, markerSize],
            iconAnchor: [markerSize/2, markerSize/2]
          });
          marker.setIcon(icon);
        }
      });
      
      // Highlight associated religious
      if (location.ReligiousIdArray && location.ReligiousIdArray.length > 0) {
        location.ReligiousIdArray.forEach(religiousId => {
          priestMarkers.eachLayer(marker => {
            if (marker.priestData && marker.priestData.ReligiousID === religiousId) {
              // Create highlighted marker
              const markerSize = CONFIG.priestMarkerSize * 1.5;
              const icon = L.divIcon({
                className: 'priest-marker pulse',
                html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
                iconSize: [markerSize, markerSize],
                iconAnchor: [markerSize/2, markerSize/2]
              });
              marker.setIcon(icon);
            }
          });
        });
        
        // Highlight connection lines
        connectionLines.eachLayer(line => {
          if (line.fromLocation === location.LocationID || line.toLocation === location.LocationID) {
            line.setStyle({
              color: 'yellow',
              weight: CONFIG.lineWeight * 1.5,
              opacity: 1.0
            });
          }
        });
      }
    }
    
    // Highlight priest's locations
    function highlightPriest(priest) {
      // Reset all markers
      resetAllMarkers();
      
      // Highlight priest's marker
      priestMarkers.eachLayer(marker => {
        if (marker.priestData && marker.priestData.ReligiousID === priest.ReligiousID) {
          // Create highlighted marker
          const markerSize = CONFIG.priestMarkerSize * 1.5;
          const icon = L.divIcon({
            className: 'priest-marker pulse',
            html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
            iconSize: [markerSize, markerSize],
            iconAnchor: [markerSize/2, markerSize/2]
          });
          marker.setIcon(icon);
        }
      });
      
      // Highlight priest's locations
      parishMarkers.eachLayer(marker => {
        if (marker.locationData && marker.locationData.ReligiousIdArray && 
            marker.locationData.ReligiousIdArray.includes(priest.ReligiousID)) {
          // Create highlighted marker
          const markerSize = CONFIG.parishMarkerSize * 1.5;
          const icon = L.divIcon({
            className: 'parish-marker',
            html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: #00cc00;"></div>`,
            iconSize: [markerSize, markerSize],
            iconAnchor: [markerSize/2, markerSize/2]
          });
          marker.setIcon(icon);
        }
      });
      
      // Highlight connection lines
      connectionLines.eachLayer(line => {
        if (line.religiousId === priest.ReligiousID) {
          line.setStyle({
            color: '#00cc00',
            weight: CONFIG.lineWeight * 1.5,
            opacity: 1.0
          });
        }
      });
    }
    
    // Function to format date
function formatDate(dateStr) {
  const date = new Date(dateStr);
  return date.toLocaleDateString(CONFIG.currentLanguage, {
    weekday: 'long',
    year: 'numeric',
    month: 'long',
    day: 'numeric'
  });
}

// Function to format time
function formatTime(dateStr) {
  const date = new Date(dateStr);
  return date.toLocaleTimeString(CONFIG.currentLanguage, {
    hour: '2-digit',
    minute: '2-digit'
  });
}

// Check if an event is cancelled
function isEventCancelled(event, date) {
  if (!cancelledEventsMap.has(event.EventID)) return false;
  
  const cancelled = cancelledEventsMap.get(event.EventID);
  const eventDate = new Date(date);
  
  return cancelled.some(cancel => {
    // Format may vary, handle different date formats
    const cancelStartDate = new Date(cancel.DateStart);
    
    // If cancelStartDate is invalid, try different format (DD.MM.YYYY)
    if (isNaN(cancelStartDate.getTime()) && cancel.DateStart) {
      const parts = cancel.DateStart.split('.');
      if (parts.length === 3) {
        const formattedDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
        return new Date(formattedDate).toDateString() === eventDate.toDateString();
      }
    }
    
    return cancelStartDate.toDateString() === eventDate.toDateString();
  });
}

// Get cancellation reason for an event
function getCancellationReason(event, date) {
  if (!cancelledEventsMap.has(event.EventID)) return null;
  
  const cancelled = cancelledEventsMap.get(event.EventID);
  const eventDate = new Date(date);
  
  const cancelEntry = cancelled.find(cancel => {
    const cancelStartDate = new Date(cancel.DateStart);
    
    // If cancelStartDate is invalid, try different format (DD.MM.YYYY)
    if (isNaN(cancelStartDate.getTime()) && cancel.DateStart) {
      const parts = cancel.DateStart.split('.');
      if (parts.length === 3) {
        const formattedDate = `${parts[2]}-${parts[1]}-${parts[0]}`;
        return new Date(formattedDate).toDateString() === eventDate.toDateString();
      }
    }
    
    return cancelStartDate.toDateString() === eventDate.toDateString();
  });
  
  return cancelEntry ? cancelEntry.Reason : null;
}

// Get funding info for an entity
function getFundingInfo(entityId) {
  return fundingMap.get(entityId) || null;
}

// Create HTML for the calendar popup
function createCalendarHtml(entityId, isLocation = true) {
  const entity = isLocation ? locationMap.get(entityId) : religiousMap.get(entityId);
  const entityName = isLocation ? entity.Name : `${entity.Type} ${entity.Name}`;
  
  // Filter events for this entity
  const entityEvents = events.filter(event => {
    if (isLocation) {
      return event.LocationID === entityId;
    } else {
      return event.ReligiousID === entityId;
    }
  });
  
  // Get current month and year
  const now = new Date();
  const currentMonth = now.getMonth();
  const currentYear = now.getFullYear();
  
  // Create calendar HTML
  let html = `
  <div class="calendar-popup" id="calendarPopup">
    <div class="calendar-header">
      <div class="calendar-title">${entityName} - $$calendar-title$$</div>
      <button class="calendar-close" id="calendarClose">×</button>
    </div>
    <div class="calendar-nav">
      <button id="prevMonth">&#8249;</button>
      <div class="calendar-month-year" id="calendarMonthYear"></div>
      <button id="nextMonth">&#8250;</button>
    </div>
    <div class="calendar-grid" id="calendarGrid"></div>
    <div class="calendar-events" id="calendarEvents"></div>
  </div>
  `;
  
  return html;
}

// Generate calendar for a specific month
function generateCalendar(entityId, month, year, isLocation = true) {
  const grid = document.getElementById('calendarGrid');
  const monthYearEl = document.getElementById('calendarMonthYear');
  const eventsEl = document.getElementById('calendarEvents');
  
  // Clear previous content
  grid.innerHTML = '';
  eventsEl.innerHTML = '';
  
  // Set month and year display
  const monthNames = [
    '$$month-january$$', '$$month-february$$', '$$month-march$$', '$$month-april$$', 
    '$$month-may$$', '$$month-june$$', '$$month-july$$', '$$month-august$$', 
    '$$month-september$$', '$$month-october$$', '$$month-november$$', '$$month-december$$'
  ];
  monthYearEl.textContent = `${monthNames[month]} ${year}`;
  
  // Add day headers
  const dayNames = ['$$day-sun$$', '$$day-mon$$', '$$day-tue$$', '$$day-wed$$', '$$day-thu$$', '$$day-fri$$', '$$day-sat$$'];
  dayNames.forEach(day => {
    const dayHeader = document.createElement('div');
    dayHeader.className = 'calendar-day-header';
    dayHeader.textContent = day;
    grid.appendChild(dayHeader);
  });
  
  // Get first day of the month
  const firstDay = new Date(year, month, 1);
  const startingDay = firstDay.getDay(); // 0 = Sunday
  
  // Get number of days in the month
  const lastDay = new Date(year, month + 1, 0);
  const totalDays = lastDay.getDate();
  
  // Get previous month days to display
  const prevMonth = month === 0 ? 11 : month - 1;
  const prevYear = month === 0 ? year - 1 : year;
  const prevMonthLastDay = new Date(prevYear, prevMonth + 1, 0).getDate();
  
  // Filter events for this entity and month
  const entityEvents = events.filter(event => {
    if (!event.StartDate) return false;
    
    const eventDate = new Date(event.StartDate);
    if (isNaN(eventDate.getTime())) return false;
    
    if (isLocation) {
      return event.LocationID === entityId && 
             eventDate.getMonth() === month && 
             eventDate.getFullYear() === year;
    } else {
      return event.ReligiousID === entityId && 
             eventDate.getMonth() === month && 
             eventDate.getFullYear() === year;
    }
  });
  
  // Create map of dates with events
  const datesWithEvents = new Map();
  entityEvents.forEach(event => {
    const eventDate = new Date(event.StartDate);
    const dayKey = eventDate.getDate();
    
    if (!datesWithEvents.has(dayKey)) {
      datesWithEvents.set(dayKey, []);
    }
    datesWithEvents.get(dayKey).push(event);
  });
  
  // Add days from previous month
  for (let i = 0; i < startingDay; i++) {
    const day = prevMonthLastDay - startingDay + i + 1;
    const dayEl = document.createElement('div');
    dayEl.className = 'calendar-day other-month';
    dayEl.textContent = day;
    grid.appendChild(dayEl);
  }
  
  // Add days of current month
  for (let day = 1; day <= totalDays; day++) {
    const dayEl = document.createElement('div');
    dayEl.className = 'calendar-day';
    dayEl.textContent = day;
    
    // Check if this day has events
    if (datesWithEvents.has(day)) {
      dayEl.classList.add('has-events');
      
      // Add click handler to show events for this day
      dayEl.addEventListener('click', () => {
        showEventsForDay(entityId, year, month, day, isLocation);
      });
    }
    
    grid.appendChild(dayEl);
  }
  
  // Add days from next month to fill the grid
  const totalCells = Math.ceil((startingDay + totalDays) / 7) * 7;
  const nextMonthDays = totalCells - (startingDay + totalDays);
  
  for (let day = 1; day <= nextMonthDays; day++) {
    const dayEl = document.createElement('div');
    dayEl.className = 'calendar-day other-month';
    dayEl.textContent = day;
    grid.appendChild(dayEl);
  }
}

// Show events for a specific day
function showEventsForDay(entityId, year, month, day, isLocation = true) {
  const eventsEl = document.getElementById('calendarEvents');
  eventsEl.innerHTML = '';
  
  // Create date for this day
  const date = new Date(year, month, day);
  
  // Add heading for this day
  const dayHeading = document.createElement('h3');
  dayHeading.textContent = formatDate(date);
  eventsEl.appendChild(dayHeading);
  
  // Filter events for this entity and day
  const dayEvents = events.filter(event => {
    if (!event.StartDate) return false;
    
    const eventDate = new Date(event.StartDate);
    if (isNaN(eventDate.getTime())) return false;
    
    const isSameDay = 
      eventDate.getDate() === day && 
      eventDate.getMonth() === month && 
      eventDate.getFullYear() === year;
    
    if (isLocation) {
      return event.LocationID === entityId && isSameDay;
    } else {
      return event.ReligiousID === entityId && isSameDay;
    }
  });
  
  // Sort events by time
  dayEvents.sort((a, b) => {
    return new Date(a.StartDate) - new Date(b.StartDate);
  });
  
  // Add events
  dayEvents.forEach(event => {
    const eventEl = document.createElement('div');
    eventEl.className = 'calendar-event';
    
    // Check if event is cancelled
    const cancelled = isEventCancelled(event, date);
    if (cancelled) {
      eventEl.classList.add('cancelled');
    }
    
    // Event title
    const titleEl = document.createElement('div');
    titleEl.className = 'calendar-event-title';
    titleEl.textContent = event.EventType || 'Event';
    eventEl.appendChild(titleEl);
    
    // Event time
    if (event.StartDate) {
      const timeEl = document.createElement('div');
      timeEl.className = 'calendar-event-time';
      timeEl.textContent = `$$event-time$$: ${formatTime(event.StartDate)}`;
      if (event.EndDate) {
        timeEl.textContent += ` - ${formatTime(event.EndDate)}`;
      }
      eventEl.appendChild(timeEl);
    }
    
    // Location or Priest (depending on view)
    if (isLocation) {
      if (event.ReligiousID) {
        const priest = religiousMap.get(event.ReligiousID);
        if (priest) {
          const priestEl = document.createElement('div');
          priestEl.className = 'calendar-event-priest';
          priestEl.textContent = `$$event-priest$$: ${priest.Type || ''} ${priest.Name || ''}`;
          eventEl.appendChild(priestEl);
        }
      }
    } else {
      if (event.LocationID) {
        const location = locationMap.get(event.LocationID);
        if (location) {
          const locationEl = document.createElement('div');
          locationEl.className = 'calendar-event-location';
          locationEl.textContent = `$$event-location$$: ${location.Name || ''}`;
          eventEl.appendChild(locationEl);
        }
      }
    }
    
    // Notes
    if (event.Notes) {
      const notesEl = document.createElement('div');
      notesEl.className = 'calendar-event-notes';
      notesEl.textContent = event.Notes;
      eventEl.appendChild(notesEl);
    }
    
    // Cancellation reason
    if (cancelled) {
      const reason = getCancellationReason(event, date);
      if (reason) {
        const cancelEl = document.createElement('div');
        cancelEl.className = 'calendar-event-cancelled';
        cancelEl.textContent = reason;
        eventEl.appendChild(cancelEl);
      }
    }
    
    // Donation link
    const fundingInfo = getFundingInfo(event.EventID);
    if (fundingInfo) {
      const donateEl = document.createElement('a');
      donateEl.className = 'donate-link';
      donateEl.href = fundingInfo.DonationLinks;
      donateEl.target = '_blank';
      
      // Calculate funding percentage if available
      let donateText = '$$donate$$';
      if (fundingInfo.FundingGoal && fundingInfo.CurrentAmount) {
        const percentage = Math.round((fundingInfo.CurrentAmount / fundingInfo.FundingGoal) * 100);
        donateText += ` [${percentage}% $$funded$$]`;
      }
      
      donateEl.textContent = donateText;
      eventEl.appendChild(donateEl);
    }
    
    eventsEl.appendChild(eventEl);
  });
  
  // No events message
  if (dayEvents.length === 0) {
    const noEventsEl = document.createElement('p');
    noEventsEl.textContent = '$$no-events$$';
    eventsEl.appendChild(noEventsEl);
  }
}

// Show calendar popup for a location
function showLocationCalendar(location) {
  // Add calendar popup to the DOM if it doesn't exist
  if (!document.getElementById('calendarPopup')) {
    const calendarHtml = createCalendarHtml(location.LocationID, true);
    document.body.insertAdjacentHTML('beforeend', calendarHtml);
    
    // Set up event listeners
    document.getElementById('calendarClose').addEventListener('click', () => {
      document.getElementById('calendarPopup').style.display = 'none';
    });
    
    // Previous and next month navigation
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    
    document.getElementById('prevMonth').addEventListener('click', () => {
      currentMonth--;
      if (currentMonth < 0) {
        currentMonth = 11;
        currentYear--;
      }
      generateCalendar(location.LocationID, currentMonth, currentYear, true);
    });
    
    document.getElementById('nextMonth').addEventListener('click', () => {
      currentMonth++;
      if (currentMonth > 11) {
        currentMonth = 0;
        currentYear++;
      }
      generateCalendar(location.LocationID, currentMonth, currentYear, true);
    });
  }
  
  // Show popup
  const popup = document.getElementById('calendarPopup');
  popup.style.display = 'flex';
  
  // Generate calendar
  const now = new Date();
  generateCalendar(location.LocationID, now.getMonth(), now.getFullYear(), true);
}

// Show calendar popup for a priest
function showPriestCalendar(priest) {
  // Add calendar popup to the DOM if it doesn't exist
  if (!document.getElementById('calendarPopup')) {
    const calendarHtml = createCalendarHtml(priest.ReligiousID, false);
    document.body.insertAdjacentHTML('beforeend', calendarHtml);
    
    // Set up event listeners
    document.getElementById('calendarClose').addEventListener('click', () => {
      document.getElementById('calendarPopup').style.display = 'none';
    });
    
    // Previous and next month navigation
    let currentMonth = new Date().getMonth();
    let currentYear = new Date().getFullYear();
    
    document.getElementById('prevMonth').addEventListener('click', () => {
      currentMonth--;
      if (currentMonth < 0) {
        currentMonth = 11;
        currentYear--;
      }
      generateCalendar(priest.ReligiousID, currentMonth, currentYear, false);
    });
    
    document.getElementById('nextMonth').addEventListener('click', () => {
      currentMonth++;
      if (currentMonth > 11) {
        currentMonth = 0;
        currentYear++;
      }
      generateCalendar(priest.ReligiousID, currentMonth, currentYear, false);
    });
  }
  
  // Show popup
  const popup = document.getElementById('calendarPopup');
  popup.style.display = 'flex';
  
  // Generate calendar
  const now = new Date();
  generateCalendar(priest.ReligiousID, now.getMonth(), now.getFullYear(), false);
}

    // Reset all markers to their default style
    function resetAllMarkers() {
      // Reset parish markers
      parishMarkers.eachLayer(marker => {
        const markerSize = CONFIG.parishMarkerSize;
        const icon = L.divIcon({
          className: 'parish-marker',
          html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
          iconSize: [markerSize, markerSize],
          iconAnchor: [markerSize/2, markerSize/2]
        });
        marker.setIcon(icon);
      });
      
      // Reset priest markers
      priestMarkers.eachLayer(marker => {
        const markerSize = CONFIG.priestMarkerSize;
        const icon = L.divIcon({
          className: 'priest-marker pulse',
          html: `<div style="width:${markerSize}px; height:${markerSize}px;"></div>`,
          iconSize: [markerSize, markerSize],
          iconAnchor: [markerSize/2, markerSize/2]
        });
        marker.setIcon(icon);
      });
      
      // Reset connection lines
      connectionLines.eachLayer(line => {
        line.setStyle({
          color: CONFIG.lineColor,
          weight: CONFIG.lineWeight,
          opacity: CONFIG.lineOpacity
        });
      });
    }

    // Handle search input
    function handleSearch(event) {
      const searchTerm = event.target.value.toLowerCase();
      const searchResultsContainer = document.getElementById('searchResults');
      
      // Reset search results
      searchResultsContainer.innerHTML = '';
      
      if (searchTerm.length < 2) {
        searchResultsContainer.style.display = 'none';
        resetAllMarkers();
        return;
      }
      
      // Filter locations and religious based on search term with proper null checks
      const matchingLocations = locations.filter(location => 
        (location.Name && location.Name.toLowerCase().includes(searchTerm)) || 
        (location.LocationType && location.LocationType.toLowerCase().includes(searchTerm)) ||
        (location.Notes && location.Notes.toLowerCase().includes(searchTerm))
      );
      
      const matchingReligious = religious.filter(person => 
        (person.Name && person.Name.toLowerCase().includes(searchTerm)) || 
        (person.Type && person.Type.toLowerCase().includes(searchTerm)) ||
        (person['Location/Area'] && person['Location/Area'].toLowerCase().includes(searchTerm)) ||
        (person.Notes && person.Notes.toLowerCase().includes(searchTerm))
      );
      
      // Highlight matching markers
      resetAllMarkers();
      
      // Highlight matching locations
      matchingLocations.forEach(location => {
        parishMarkers.eachLayer(marker => {
          if (marker.locationData && marker.locationData.LocationID === location.LocationID) {
            const markerSize = CONFIG.parishMarkerSize * 1.5;
            const icon = L.divIcon({
              className: 'parish-marker',
              html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
              iconSize: [markerSize, markerSize],
              iconAnchor: [markerSize/2, markerSize/2]
            });
            marker.setIcon(icon);
          }
        });
      });
      
      // Highlight matching religious
      matchingReligious.forEach(person => {
        priestMarkers.eachLayer(marker => {
          if (marker.priestData && marker.priestData.ReligiousID === person.ReligiousID) {
            const markerSize = CONFIG.priestMarkerSize * 1.5;
            const icon = L.divIcon({
              className: 'priest-marker pulse',
              html: `<div style="width:${markerSize}px; height:${markerSize}px; background-color: yellow;"></div>`,
              iconSize: [markerSize, markerSize],
              iconAnchor: [markerSize/2, markerSize/2]
            });
            marker.setIcon(icon);
          }
        });
      });
      
      // Create combined results
      const combinedResults = [
        ...matchingReligious.map(person => ({ 
          type: 'religious', 
          data: person, 
          title: `${person.Type || ''} ${person.Name || ''}`
        })),
        ...matchingLocations.map(location => ({ 
          type: 'location', 
          data: location, 
          title: `${location.Name || ''} ${location.LocationType ? '(' + location.LocationType + ')' : ''}`
        }))
      ];
      
      // Display search results
      if (combinedResults.length > 0) {
        combinedResults.forEach(result => {
          const resultItem = document.createElement('div');
          resultItem.className = 'search-result-item';
          resultItem.textContent = result.title;
          
          resultItem.addEventListener('click', () => {
            if (result.type === 'religious') {
              showPriestInfo(result.data);
            } else {
              showLocationInfo(result.data);
            }
            
            // Clear search
            document.getElementById('searchInput').value = '';
            searchResultsContainer.style.display = 'none';
          });
          
          searchResultsContainer.appendChild(resultItem);
        });
        
        searchResultsContainer.style.display = 'flex';
      } else {
        searchResultsContainer.style.display = 'none';
      }
    }

    // Try to get user's location
    function getUserLocation() {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          // Success
          (position) => {
            const lat = position.coords.latitude;
            const lng = position.coords.longitude;
            
            // Center map on user's location
            map.setView([lat, lng], 8);
            
            // Add a marker for user's location
            addUserLocationMarker(lat, lng);
          },
          // Error
          (error) => {
            console.warn(`Geolocation error: ${error.message}`);
            // Use approximate location
            getApproximateLocation();
          },
          // Options
          {
            timeout: 5000,  // Wait just 5 seconds for the geolocation
            maximumAge: 0   // Don't use a cached position
          }
        );
      } else {
        console.warn("Geolocation not supported by this browser");
        // Use approximate location
        getApproximateLocation();
      }
    }

    // Add a marker for the user's location
    function addUserLocationMarker(lat, lng) {
      // Remove existing marker if any
      if (userLocationMarker) {
        map.removeLayer(userLocationMarker);
      }
      
      // Create a blue user location marker
      const userIcon = L.divIcon({
        className: 'user-marker',
        html: `<div style="width:12px; height:12px; background-color: blue; border-radius: 50%; border: 2px solid white;"></div>`,
        iconSize: [12, 12],
        iconAnchor: [6, 6]
      });
      
      userLocationMarker = L.marker([lat, lng], { icon: userIcon })
        .addTo(map)
        .bindPopup("$$your-location$$");
      }

    // Get approximate location based on timezone and language
    function getApproximateLocation() {
      // Get timezone offset
      const timezoneOffsetMinutes = new Date().getTimezoneOffset();
      const timezoneOffsetHours = -timezoneOffsetMinutes / 60;
      
      // Approximate longitude based on timezone
      const approximateLongitude = timezoneOffsetHours * 15;
      
      // Approximate latitude based on language
      const approximateLatitude = estimateLatitude(approximateLongitude);
      
      console.log(`Estimated location based on timezone and language: ${approximateLatitude}, ${approximateLongitude}`);
      
      // Center map and add marker
      map.setView([approximateLatitude, approximateLongitude], 5);
      addUserLocationMarker(approximateLatitude, approximateLongitude);
    }

    // Estimate latitude based on language and longitude
    function estimateLatitude(longitude) {
      // Language-based latitude map
      const languageLatitudeMap = {
        "de": 51.0, // Germany
        "en": 51.0, // UK
        "fr": 46.0, // France
        "es": 40.0, // Spain
        "it": 42.0, // Italy
        "pl": 52.0, // Poland
        "ro": 46.0, // Romania
        "ru": 55.0, // Russia
        "tr": 39.0, // Turkey
        "el": 38.0, // Greece
        "ar": 25.0, // Arabian Peninsula
        "tl": 14.0, // Philippines
        "zh": 35.0, // China
        "ko": 37.5, // Korea
        "ja": 36.0, // Japan
        "pt": -15.0 // Brazil
      };
      
      // Longitude ranges for adjusting latitude
      const longitudeRanges = {
        "en": [
          { min: -170, max: -30, lat: 40.0 },    // North America
          { min: -10, max: 2, lat: 51.0 },       // UK
          { min: 65, max: 90, lat: 20.0 },       // South Asia
          { min: 110, max: 155, lat: -25.0 }     // Australia/NZ
        ],
        "es": [
          { min: -120, max: -30, lat: 15.0 },    // Latin America
          { min: -10, max: 5, lat: 40.0 }        // Spain
        ],
        "pt": [
          { min: -75, max: -30, lat: -15.0 },    // Brazil
          { min: -10, max: 0, lat: 39.0 }        // Portugal
        ]
      };
      
      // If we have longitude range data for this language, check it
      if (longitudeRanges[CONFIG.currentLanguage]) {
        for (const range of longitudeRanges[CONFIG.currentLanguage]) {
          if (longitude >= range.min && longitude <= range.max) {
            return range.lat;
          }
        }
      }
      
      // Otherwise use the general language map
      if (languageLatitudeMap[CONFIG.currentLanguage]) {
        return languageLatitudeMap[CONFIG.currentLanguage];
      }
      
      // Regional fallback based on longitude
      if (longitude > 10 && longitude < 40) {
        return 50.0; // Eastern Europe
      } else if (longitude >= 40 && longitude < 60) {
        return 55.0; // Western Russia
      } else if (longitude >= 60 && longitude < 90) {
        return 45.0; // Central Asia
      } else if (longitude >= 90 && longitude < 120) {
        return 35.0; // East Asia
      } else if (longitude >= 120 && longitude < 150) {
        return 35.0; // Far East Asia
      } else if (longitude > -10 && longitude <= 10) {
        return 48.0; // Western Europe
      } else if (longitude > -60 && longitude <= -10) {
        return 45.0; // Atlantic/Western Europe
      } else if (longitude > -120 && longitude <= -60) {
        return 35.0; // Americas
      }
      
      // Default fallback
      return 20.0;
    }
  </script>
</body>
</html>